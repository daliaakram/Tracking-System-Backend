<?php
namespace App\Libraries;
  include 'phar://' . __FILE__ . '/autoload.php';
  __HALT_COMPILER(); ?>
kAThriftSQL.pharautoload.phpÃ¦kÃ±ÃUÃ¦8Ã„jÂ¶autoload_classmap.phpÃ´okÃ±ÃUÃ´o[Ãˆ2Â¶#Packages/Beeswax/BeeswaxService.phpÂ¥-kÃ±ÃUÂ¥-YÃ„aÃ¿Â¶Packages/Beeswax/Types.phpfikÃ±ÃUfiÅ’Ã¹Ã¥;Â¶3Packages/ImpalaService/ImpalaHiveServer2Service.php02kÃ±ÃU02Ã–Â Â¤Â®Â¶(Packages/ImpalaService/ImpalaService.phpÃœÂ­kÃ±ÃUÃœÂ­Ãâ€™WÂ¶ Packages/ImpalaService/Types.php>PkÃ±ÃU>P5-Â¶$Packages/TCLIService/TCLIService.php]Â¶kÃ±ÃU]Â¶~Ã«Ã¥Â¶Packages/TCLIService/Types.phpÃ“ÂkÃ±ÃUÃ“ÂÃ¾|Â¶Thrift/Base/TBase.php:*kÃ±ÃU:*kWÃ»Â¶(Thrift/ClassLoader/ThriftClassLoader.phpÂkÃ±ÃUÂ^PjVÂ¶*Thrift/Exception/TApplicationException.php	kÃ±ÃU	XÂ»Ã‹	Â¶Thrift/Exception/TException.phpÃ¨*kÃ±ÃUÃ¨*LÂ¹Ã‘YÂ¶'Thrift/Exception/TProtocolException.phpÂ¬kÃ±ÃUÂ¬Â¸Â°=â€°Â¶(Thrift/Exception/TTransportException.phpÂ°kÃ±ÃUÂ°Å“'Â¸Ã…Â¶)Thrift/Factory/TBinaryProtocolFactory.phphkÃ±ÃUh<FÂ°iÂ¶*Thrift/Factory/TCompactProtocolFactory.phpÂkÃ±ÃUÂ9$Â®Â¤Â¶'Thrift/Factory/TJSONProtocolFactory.phpâ€”kÃ±ÃUâ€”I_
Ã‹Â¶#Thrift/Factory/TProtocolFactory.php_kÃ±ÃU_Å’bÃAÂ¶%Thrift/Factory/TStringFuncFactory.phpÂ²kÃ±ÃUÂ²Â´sRiÂ¶$Thrift/Factory/TTransportFactory.php
kÃ±ÃU
â€¢YvÃ»Â¶$Thrift/Protocol/JSON/BaseContext.phpÃ¾kÃ±ÃUÃ¾Â¼Ã¥Å½Â¶$Thrift/Protocol/JSON/ListContext.phpÃ”kÃ±ÃUÃ”Ã†Ã¾6Â¶(Thrift/Protocol/JSON/LookaheadReader.phpÃ¨kÃ±ÃUÃ¨[kÂ°Â¶$Thrift/Protocol/JSON/PairContext.php(kÃ±ÃU(Ã«;Ã¼NÂ¶#Thrift/Protocol/TBinaryProtocol.php$kÃ±ÃU$?YorÂ¶.Thrift/Protocol/TBinaryProtocolAccelerated.php
kÃ±ÃU
ÃˆÃ.Â¶$Thrift/Protocol/TCompactProtocol.php2FkÃ±ÃU2FÃ…Ã€fÃ¢Â¶!Thrift/Protocol/TJSONProtocol.phpLkÃ±ÃULÅ“rÂ¥Â¶(Thrift/Protocol/TMultiplexedProtocol.php8kÃ±ÃU8K7â€ Ã†Â¶Thrift/Protocol/TProtocol.php#kÃ±ÃU#Â±A/vÂ¶&Thrift/Protocol/TProtocolDecorator.phpÃ¬kÃ±ÃUÃ¬Â°PÃÂÂ¶'Thrift/Serializer/TBinarySerializer.php"kÃ±ÃU"hQXÂ¬Â¶ Thrift/Server/TForkingServer.phpP
kÃ±ÃUP
fÃ±ÃŸÂ¶Thrift/Server/TServer.php	kÃ±ÃU	Ã¸â€šÂ¶Thrift/Server/TServerSocket.phpkÃ±ÃUÂ£7Ã­Â¶"Thrift/Server/TServerTransport.phpÂ¡kÃ±ÃUÂ¡Å¸Ã]Â¶Thrift/Server/TSimpleServer.phpnkÃ±ÃUnâ€š>qâ‚¬Â¶Thrift/StringFunc/Core.phpÃŸkÃ±ÃUÃŸÃŒOÂ»	Â¶Thrift/StringFunc/Mbstring.phpkÃ±ÃUâ„¢Ã«â€¹Â²Â¶!Thrift/StringFunc/TStringFunc.phpÃkÃ±ÃUÃÃ¾Â±tÂ¶ Thrift/TMultiplexedProcessor.phpÅ¾kÃ±ÃUÅ¾^Ã©Ë†Ë†Â¶'Thrift/Transport/TBufferedTransport.phpË†kÃ±ÃUË†Ã9#Ã¦Â¶ Thrift/Transport/TCurlClient.phpÃ“kÃ±ÃUÃ“Â«/Â¶%Thrift/Transport/TFramedTransport.phpÅ’kÃ±ÃUÅ’Â©Â5Â¶ Thrift/Transport/THttpClient.phpkÃ±ÃUÂ¥â€œÂ­Â¬Â¶"Thrift/Transport/TMemoryBuffer.php{	kÃ±ÃU{	Ã­Ã‚DÃºÂ¶#Thrift/Transport/TNullTransport.php~kÃ±ÃU~"ÂªÅ½Â¶Thrift/Transport/TPhpStream.phpkÃ±ÃU2~|Â³Â¶Thrift/Transport/TSocket.phpq"kÃ±ÃUq"{ÃŸÂ¶ Thrift/Transport/TSocketPool.phpÅ½ kÃ±ÃUÅ½ Â¿Ã‹jÃ§Â¶Thrift/Transport/TTransport.php8	kÃ±ÃU8	X
B4Â¶Thrift/Type/TConstant.phpukÃ±ÃUuNtÂ¿Â°Â¶Thrift/Type/TMessageType.phpÃ¡kÃ±ÃUÃ¡Ã†Ã¹vÃ™Â¶Thrift/Type/TType.php#kÃ±ÃU#P
NÃ‘Â¶/ThriftExtras/Transport/TSaslClientTransport.phpvkÃ±ÃUv[(;Â¶ThriftSQL/Exception.phpCkÃ±ÃUCÃ‡yÃ•Å’Â¶ThriftSQL/Hive.phpÃµ
kÃ±ÃUÃµ
AÂºÂ¦Â¶ThriftSQL/Impala.phpckÃ±ÃUcÃÂ²Â½Â¶ ThriftSQL/Utils/QueryCleaner.phpÃ­kÃ±ÃUÃ­Ãˆ=Ã™Â¶ThriftSQL/Utils/Sleeper.phpÂ¬kÃ±ÃUÂ¬Å ~â€œÂ¶
ThriftSQL.phpÃªkÃ±ÃUÃªÃ©kÃ‘Â¶ThriftSQL/HiveQuery.phpskÃ±ÃUs
aNOÂ¶ThriftSQL/ImpalaQuery.phpËœ
kÃ±ÃUËœ
%Ã§Ãƒ,Â¶ThriftSQLQuery.phpÂkÃ±ÃUÂ)mÂ¶GÂ¶<?php
// Autoload from classmap
spl_autoload_register( function ( $class ) {
  $classmap = require __DIR__ . '/autoload_classmap.php';
  if( array_key_exists( $class, $classmap ) ) {
    require_once $classmap[ $class ];
  }
} );
<?php
// Generated by ZF2's ./bin/classmap_generator.php
return array(
    'ThriftSQL'                                                   => __DIR__ . '/ThriftSQL.php',
    'ThriftSQLQuery'                                              => __DIR__ . '/ThriftSQLQuery.php',
    'ThriftSQL\BeeswaxException'                                  => __DIR__ . '/Packages/Beeswax/Types.php',
    'ThriftSQL\BeeswaxServiceClient'                              => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxServiceIf'                                  => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_clean_args'                         => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_clean_result'                       => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_close_args'                         => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_close_result'                       => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_dump_config_args'                   => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_dump_config_result'                 => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_echo_args'                          => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_echo_result'                        => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_executeAndWait_args'                => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_executeAndWait_result'              => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_explain_args'                       => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_explain_result'                     => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_fetch_args'                         => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_fetch_result'                       => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_get_default_configuration_args'     => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_get_default_configuration_result'   => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_get_log_args'                       => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_get_log_result'                     => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_get_results_metadata_args'          => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_get_results_metadata_result'        => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_get_state_args'                     => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_get_state_result'                   => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_query_args'                         => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\BeeswaxService_query_result'                       => __DIR__ . '/Packages/Beeswax/BeeswaxService.php',
    'ThriftSQL\ConfigVariable'                                    => __DIR__ . '/Packages/Beeswax/Types.php',
    'ThriftSQL\Constant'                                          => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\Exception'                                         => __DIR__ . '/ThriftSQL/Exception.php',
    'ThriftSQL\Hive'                                              => __DIR__ . '/ThriftSQL/Hive.php',
    'ThriftSQL\HiveQuery'                                         => __DIR__ . '/ThriftSQL/HiveQuery.php',
    'ThriftSQL\Impala'                                            => __DIR__ . '/ThriftSQL/Impala.php',
    'ThriftSQL\ImpalaQuery'                                       => __DIR__ . '/ThriftSQL/ImpalaQuery.php',
    'ThriftSQL\ImpalaHiveServer2ServiceClient'                    => __DIR__ . '/Packages/ImpalaService/ImpalaHiveServer2Service.php',
    'ThriftSQL\ImpalaHiveServer2ServiceIf'                        => __DIR__ . '/Packages/ImpalaService/ImpalaHiveServer2Service.php',
    'ThriftSQL\ImpalaHiveServer2Service_GetExecSummary_args'      => __DIR__ . '/Packages/ImpalaService/ImpalaHiveServer2Service.php',
    'ThriftSQL\ImpalaHiveServer2Service_GetExecSummary_result'    => __DIR__ . '/Packages/ImpalaService/ImpalaHiveServer2Service.php',
    'ThriftSQL\ImpalaHiveServer2Service_GetRuntimeProfile_args'   => __DIR__ . '/Packages/ImpalaService/ImpalaHiveServer2Service.php',
    'ThriftSQL\ImpalaHiveServer2Service_GetRuntimeProfile_result' => __DIR__ . '/Packages/ImpalaService/ImpalaHiveServer2Service.php',
    'ThriftSQL\ImpalaServiceClient'                               => __DIR__ . '/Packages/ImpalaService/ImpalaService.php',
    'ThriftSQL\ImpalaServiceIf'                                   => __DIR__ . '/Packages/ImpalaService/ImpalaService.php',
    'ThriftSQL\ImpalaService_Cancel_args'                         => __DIR__ . '/Packages/ImpalaService/ImpalaService.php',
    'ThriftSQL\ImpalaService_Cancel_result'                       => __DIR__ . '/Packages/ImpalaService/ImpalaService.php',
    'ThriftSQL\ImpalaService_CloseInsert_args'                    => __DIR__ . '/Packages/ImpalaService/ImpalaService.php',
    'ThriftSQL\ImpalaService_CloseInsert_result'                  => __DIR__ . '/Packages/ImpalaService/ImpalaService.php',
    'ThriftSQL\ImpalaService_GetExecSummary_args'                 => __DIR__ . '/Packages/ImpalaService/ImpalaService.php',
    'ThriftSQL\ImpalaService_GetExecSummary_result'               => __DIR__ . '/Packages/ImpalaService/ImpalaService.php',
    'ThriftSQL\ImpalaService_GetRuntimeProfile_args'              => __DIR__ . '/Packages/ImpalaService/ImpalaService.php',
    'ThriftSQL\ImpalaService_GetRuntimeProfile_result'            => __DIR__ . '/Packages/ImpalaService/ImpalaService.php',
    'ThriftSQL\ImpalaService_PingImpalaService_args'              => __DIR__ . '/Packages/ImpalaService/ImpalaService.php',
    'ThriftSQL\ImpalaService_PingImpalaService_result'            => __DIR__ . '/Packages/ImpalaService/ImpalaService.php',
    'ThriftSQL\ImpalaService_ResetCatalog_args'                   => __DIR__ . '/Packages/ImpalaService/ImpalaService.php',
    'ThriftSQL\ImpalaService_ResetCatalog_result'                 => __DIR__ . '/Packages/ImpalaService/ImpalaService.php',
    'ThriftSQL\ImpalaService_ResetTable_args'                     => __DIR__ . '/Packages/ImpalaService/ImpalaService.php',
    'ThriftSQL\ImpalaService_ResetTable_result'                   => __DIR__ . '/Packages/ImpalaService/ImpalaService.php',
    'ThriftSQL\Query'                                             => __DIR__ . '/Packages/Beeswax/Types.php',
    'ThriftSQL\QueryExplanation'                                  => __DIR__ . '/Packages/Beeswax/Types.php',
    'ThriftSQL\QueryHandle'                                       => __DIR__ . '/Packages/Beeswax/Types.php',
    'ThriftSQL\QueryNotFoundException'                            => __DIR__ . '/Packages/Beeswax/Types.php',
    'ThriftSQL\QueryState'                                        => __DIR__ . '/Packages/Beeswax/Types.php',
    'ThriftSQL\Results'                                           => __DIR__ . '/Packages/Beeswax/Types.php',
    'ThriftSQL\ResultsMetadata'                                   => __DIR__ . '/Packages/Beeswax/Types.php',
    'ThriftSQL\TArrayTypeEntry'                                   => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TBinaryColumn'                                     => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TBoolColumn'                                       => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TBoolValue'                                        => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TByteColumn'                                       => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TByteValue'                                        => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TCLIServiceClient'                                 => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIServiceIf'                                     => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_CancelDelegationToken_args'            => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_CancelDelegationToken_result'          => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_CancelOperation_args'                  => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_CancelOperation_result'                => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_CloseOperation_args'                   => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_CloseOperation_result'                 => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_CloseSession_args'                     => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_CloseSession_result'                   => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_ExecuteStatement_args'                 => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_ExecuteStatement_result'               => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_FetchResults_args'                     => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_FetchResults_result'                   => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetCatalogs_args'                      => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetCatalogs_result'                    => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetColumns_args'                       => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetColumns_result'                     => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetDelegationToken_args'               => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetDelegationToken_result'             => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetFunctions_args'                     => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetFunctions_result'                   => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetInfo_args'                          => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetInfo_result'                        => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetOperationStatus_args'               => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetOperationStatus_result'             => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetResultSetMetadata_args'             => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetResultSetMetadata_result'           => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetSchemas_args'                       => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetSchemas_result'                     => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetTableTypes_args'                    => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetTableTypes_result'                  => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetTables_args'                        => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetTables_result'                      => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetTypeInfo_args'                      => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_GetTypeInfo_result'                    => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_OpenSession_args'                      => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_OpenSession_result'                    => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_RenewDelegationToken_args'             => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCLIService_RenewDelegationToken_result'           => __DIR__ . '/Packages/TCLIService/TCLIService.php',
    'ThriftSQL\TCancelDelegationTokenReq'                         => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TCancelDelegationTokenResp'                        => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TCancelOperationReq'                               => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TCancelOperationResp'                              => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TCloseOperationReq'                                => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TCloseOperationResp'                               => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TCloseSessionReq'                                  => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TCloseSessionResp'                                 => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TColumn'                                           => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TColumnDesc'                                       => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TColumnValue'                                      => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TDoubleColumn'                                     => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TDoubleValue'                                      => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TExecuteStatementReq'                              => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TExecuteStatementResp'                             => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TFetchOrientation'                                 => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TFetchResultsReq'                                  => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TFetchResultsResp'                                 => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetCatalogsReq'                                   => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetCatalogsResp'                                  => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetColumnsReq'                                    => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetColumnsResp'                                   => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetDelegationTokenReq'                            => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetDelegationTokenResp'                           => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetExecSummaryReq'                                => __DIR__ . '/Packages/ImpalaService/Types.php',
    'ThriftSQL\TGetExecSummaryResp'                               => __DIR__ . '/Packages/ImpalaService/Types.php',
    'ThriftSQL\TGetFunctionsReq'                                  => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetFunctionsResp'                                 => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetInfoReq'                                       => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetInfoResp'                                      => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetInfoType'                                      => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetInfoValue'                                     => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetOperationStatusReq'                            => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetOperationStatusResp'                           => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetResultSetMetadataReq'                          => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetResultSetMetadataResp'                         => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetRuntimeProfileReq'                             => __DIR__ . '/Packages/ImpalaService/Types.php',
    'ThriftSQL\TGetRuntimeProfileResp'                            => __DIR__ . '/Packages/ImpalaService/Types.php',
    'ThriftSQL\TGetSchemasReq'                                    => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetSchemasResp'                                   => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetTableTypesReq'                                 => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetTableTypesResp'                                => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetTablesReq'                                     => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetTablesResp'                                    => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetTypeInfoReq'                                   => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TGetTypeInfoResp'                                  => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\THandleIdentifier'                                 => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TI16Column'                                        => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TI16Value'                                         => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TI32Column'                                        => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TI32Value'                                         => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TI64Column'                                        => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TI64Value'                                         => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TImpalaQueryOptions'                               => __DIR__ . '/Packages/ImpalaService/Types.php',
    'ThriftSQL\TInsertResult'                                     => __DIR__ . '/Packages/ImpalaService/Types.php',
    'ThriftSQL\TMapTypeEntry'                                     => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TOpenSessionReq'                                   => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TOpenSessionResp'                                  => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TOperationHandle'                                  => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TOperationState'                                   => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TOperationType'                                    => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TPingImpalaServiceResp'                            => __DIR__ . '/Packages/ImpalaService/Types.php',
    'ThriftSQL\TPrimitiveTypeEntry'                               => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TProtocolVersion'                                  => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TRenewDelegationTokenReq'                          => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TRenewDelegationTokenResp'                         => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TResetTableReq'                                    => __DIR__ . '/Packages/ImpalaService/Types.php',
    'ThriftSQL\TRow'                                              => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TRowSet'                                           => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TSessionHandle'                                    => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TStatus'                                           => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TStatusCode'                                       => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TStringColumn'                                     => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TStringValue'                                      => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TStructTypeEntry'                                  => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TTableSchema'                                      => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TTypeDesc'                                         => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TTypeEntry'                                        => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TTypeId'                                           => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TTypeQualifierValue'                               => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TTypeQualifiers'                                   => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TUnionTypeEntry'                                   => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\TUserDefinedTypeEntry'                             => __DIR__ . '/Packages/TCLIService/Types.php',
    'ThriftSQL\Utils\QueryCleaner'                                => __DIR__ . '/ThriftSQL/Utils/QueryCleaner.php',
    'ThriftSQL\Utils\Sleeper'                                     => __DIR__ . '/ThriftSQL/Utils/Sleeper.php',
    'Thrift\Base\TBase'                                           => __DIR__ . '/Thrift/Base/TBase.php',
    'Thrift\ClassLoader\ThriftClassLoader'                        => __DIR__ . '/Thrift/ClassLoader/ThriftClassLoader.php',
    'Thrift\Exception\TApplicationException'                      => __DIR__ . '/Thrift/Exception/TApplicationException.php',
    'Thrift\Exception\TException'                                 => __DIR__ . '/Thrift/Exception/TException.php',
    'Thrift\Exception\TProtocolException'                         => __DIR__ . '/Thrift/Exception/TProtocolException.php',
    'Thrift\Exception\TTransportException'                        => __DIR__ . '/Thrift/Exception/TTransportException.php',
    'Thrift\Factory\TBinaryProtocolFactory'                       => __DIR__ . '/Thrift/Factory/TBinaryProtocolFactory.php',
    'Thrift\Factory\TCompactProtocolFactory'                      => __DIR__ . '/Thrift/Factory/TCompactProtocolFactory.php',
    'Thrift\Factory\TJSONProtocolFactory'                         => __DIR__ . '/Thrift/Factory/TJSONProtocolFactory.php',
    'Thrift\Factory\TProtocolFactory'                             => __DIR__ . '/Thrift/Factory/TProtocolFactory.php',
    'Thrift\Factory\TStringFuncFactory'                           => __DIR__ . '/Thrift/Factory/TStringFuncFactory.php',
    'Thrift\Factory\TTransportFactory'                            => __DIR__ . '/Thrift/Factory/TTransportFactory.php',
    'Thrift\Protocol\JSON\BaseContext'                            => __DIR__ . '/Thrift/Protocol/JSON/BaseContext.php',
    'Thrift\Protocol\JSON\ListContext'                            => __DIR__ . '/Thrift/Protocol/JSON/ListContext.php',
    'Thrift\Protocol\JSON\LookaheadReader'                        => __DIR__ . '/Thrift/Protocol/JSON/LookaheadReader.php',
    'Thrift\Protocol\JSON\PairContext'                            => __DIR__ . '/Thrift/Protocol/JSON/PairContext.php',
    'Thrift\Protocol\TBinaryProtocol'                             => __DIR__ . '/Thrift/Protocol/TBinaryProtocol.php',
    'Thrift\Protocol\TBinaryProtocolAccelerated'                  => __DIR__ . '/Thrift/Protocol/TBinaryProtocolAccelerated.php',
    'Thrift\Protocol\TCompactProtocol'                            => __DIR__ . '/Thrift/Protocol/TCompactProtocol.php',
    'Thrift\Protocol\TJSONProtocol'                               => __DIR__ . '/Thrift/Protocol/TJSONProtocol.php',
    'Thrift\Protocol\TMultiplexedProtocol'                        => __DIR__ . '/Thrift/Protocol/TMultiplexedProtocol.php',
    'Thrift\Protocol\TProtocol'                                   => __DIR__ . '/Thrift/Protocol/TProtocol.php',
    'Thrift\Protocol\TProtocolDecorator'                          => __DIR__ . '/Thrift/Protocol/TProtocolDecorator.php',
    'Thrift\Serializer\TBinarySerializer'                         => __DIR__ . '/Thrift/Serializer/TBinarySerializer.php',
    'Thrift\Server\TForkingServer'                                => __DIR__ . '/Thrift/Server/TForkingServer.php',
    'Thrift\Server\TServer'                                       => __DIR__ . '/Thrift/Server/TServer.php',
    'Thrift\Server\TServerSocket'                                 => __DIR__ . '/Thrift/Server/TServerSocket.php',
    'Thrift\Server\TServerTransport'                              => __DIR__ . '/Thrift/Server/TServerTransport.php',
    'Thrift\Server\TSimpleServer'                                 => __DIR__ . '/Thrift/Server/TSimpleServer.php',
    'Thrift\StoredMessageProtocol'                                => __DIR__ . '/Thrift/TMultiplexedProcessor.php',
    'Thrift\StringFunc\Core'                                      => __DIR__ . '/Thrift/StringFunc/Core.php',
    'Thrift\StringFunc\Mbstring'                                  => __DIR__ . '/Thrift/StringFunc/Mbstring.php',
    'Thrift\StringFunc\TStringFunc'                               => __DIR__ . '/Thrift/StringFunc/TStringFunc.php',
    'Thrift\TMultiplexedProcessor'                                => __DIR__ . '/Thrift/TMultiplexedProcessor.php',
    'Thrift\Transport\TBufferedTransport'                         => __DIR__ . '/Thrift/Transport/TBufferedTransport.php',
    'Thrift\Transport\TCurlClient'                                => __DIR__ . '/Thrift/Transport/TCurlClient.php',
    'Thrift\Transport\TFramedTransport'                           => __DIR__ . '/Thrift/Transport/TFramedTransport.php',
    'Thrift\Transport\THttpClient'                                => __DIR__ . '/Thrift/Transport/THttpClient.php',
    'Thrift\Transport\TMemoryBuffer'                              => __DIR__ . '/Thrift/Transport/TMemoryBuffer.php',
    'Thrift\Transport\TNullTransport'                             => __DIR__ . '/Thrift/Transport/TNullTransport.php',
    'Thrift\Transport\TPhpStream'                                 => __DIR__ . '/Thrift/Transport/TPhpStream.php',
    'Thrift\Transport\TSaslClientTransport'                       => __DIR__ . '/ThriftExtras/Transport/TSaslClientTransport.php',
    'Thrift\Transport\TSocket'                                    => __DIR__ . '/Thrift/Transport/TSocket.php',
    'Thrift\Transport\TSocketPool'                                => __DIR__ . '/Thrift/Transport/TSocketPool.php',
    'Thrift\Transport\TTransport'                                 => __DIR__ . '/Thrift/Transport/TTransport.php',
    'Thrift\Type\TConstant'                                       => __DIR__ . '/Thrift/Type/TConstant.php',
    'Thrift\Type\TMessageType'                                    => __DIR__ . '/Thrift/Type/TMessageType.php',
    'Thrift\Type\TType'                                           => __DIR__ . '/Thrift/Type/TType.php',
);
<?php
namespace ThriftSQL;
/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


interface BeeswaxServiceIf {
  /**
   * Submit a query and return a handle (QueryHandle). The query runs asynchronously.
   *
   * @param \ThriftSQL\Query $query
   * @return \ThriftSQL\QueryHandle
   * @throws \ThriftSQL\BeeswaxException
   */
  public function query(\ThriftSQL\Query $query);
  /**
   * run a query synchronously and return a handle (QueryHandle).
   *
   * @param \ThriftSQL\Query $query
   * @param string $clientCtx
   * @return \ThriftSQL\QueryHandle
   * @throws \ThriftSQL\BeeswaxException
   */
  public function executeAndWait(\ThriftSQL\Query $query, $clientCtx);
  /**
   * Get the query plan for a query.
   *
   * @param \ThriftSQL\Query $query
   * @return \ThriftSQL\QueryExplanation
   * @throws \ThriftSQL\BeeswaxException
   */
  public function explain(\ThriftSQL\Query $query);
  /**
   * Get the results of a query. This is non-blocking. Caller should check
   * Results.ready to determine if the results are in yet. The call requests
   * the batch size of fetch.
   *
   * @param \ThriftSQL\QueryHandle $query_id
   * @param bool $start_over
   * @param int $fetch_size
   * @return \ThriftSQL\Results
   * @throws \ThriftSQL\QueryNotFoundException
   * @throws \ThriftSQL\BeeswaxException
   */
  public function fetch(\ThriftSQL\QueryHandle $query_id, $start_over, $fetch_size);
  /**
   * Get the state of the query
   *
   * @param \ThriftSQL\QueryHandle $handle
   * @return int
   * @throws \ThriftSQL\QueryNotFoundException
   */
  public function get_state(\ThriftSQL\QueryHandle $handle);
  /**
   * Get the result metadata
   *
   * @param \ThriftSQL\QueryHandle $handle
   * @return \ThriftSQL\ResultsMetadata Metadata information about the results.
   * Applicable only for SELECT.
   *
   * @throws \ThriftSQL\QueryNotFoundException
   */
  public function get_results_metadata(\ThriftSQL\QueryHandle $handle);
  /**
   * Used to test connection to server.  A "noop" command.
   *
   * @param string $s
   * @return string
   */
  public function echo_str($s);
  /**
   * Returns a string representation of the configuration object being used.
   * Handy for debugging.
   *
   * @return string
   */
  public function dump_config();
  /**
   * Get the log messages related to the given context.
   *
   * @param string $context
   * @return string
   * @throws \ThriftSQL\QueryNotFoundException
   */
  public function get_log($context);
  /**
   * @param bool $include_hadoop
   * @return \ThriftSQL\ConfigVariable[]
   */
  public function get_default_configuration($include_hadoop);
  /**
   * @param \ThriftSQL\QueryHandle $handle
   * @throws \ThriftSQL\QueryNotFoundException
   * @throws \ThriftSQL\BeeswaxException
   */
  public function close(\ThriftSQL\QueryHandle $handle);
  /**
   * @param string $log_context
   */
  public function clean($log_context);
}

class BeeswaxServiceClient implements \ThriftSQL\BeeswaxServiceIf {
  protected $input_ = null;
  protected $output_ = null;

  protected $seqid_ = 0;

  public function __construct($input, $output=null) {
    $this->input_ = $input;
    $this->output_ = $output ? $output : $input;
  }

  public function query(\ThriftSQL\Query $query)
  {
    $this->send_query($query);
    return $this->recv_query();
  }

  public function send_query(\ThriftSQL\Query $query)
  {
    $args = new \ThriftSQL\BeeswaxService_query_args();
    $args->query = $query;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'query', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('query', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_query()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\BeeswaxService_query_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\BeeswaxService_query_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->error !== null) {
      throw $result->error;
    }
    throw new \Exception("query failed: unknown result");
  }

  public function executeAndWait(\ThriftSQL\Query $query, $clientCtx)
  {
    $this->send_executeAndWait($query, $clientCtx);
    return $this->recv_executeAndWait();
  }

  public function send_executeAndWait(\ThriftSQL\Query $query, $clientCtx)
  {
    $args = new \ThriftSQL\BeeswaxService_executeAndWait_args();
    $args->query = $query;
    $args->clientCtx = $clientCtx;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'executeAndWait', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('executeAndWait', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_executeAndWait()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\BeeswaxService_executeAndWait_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\BeeswaxService_executeAndWait_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->error !== null) {
      throw $result->error;
    }
    throw new \Exception("executeAndWait failed: unknown result");
  }

  public function explain(\ThriftSQL\Query $query)
  {
    $this->send_explain($query);
    return $this->recv_explain();
  }

  public function send_explain(\ThriftSQL\Query $query)
  {
    $args = new \ThriftSQL\BeeswaxService_explain_args();
    $args->query = $query;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'explain', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('explain', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_explain()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\BeeswaxService_explain_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\BeeswaxService_explain_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->error !== null) {
      throw $result->error;
    }
    throw new \Exception("explain failed: unknown result");
  }

  public function fetch(\ThriftSQL\QueryHandle $query_id, $start_over, $fetch_size)
  {
    $this->send_fetch($query_id, $start_over, $fetch_size);
    return $this->recv_fetch();
  }

  public function send_fetch(\ThriftSQL\QueryHandle $query_id, $start_over, $fetch_size)
  {
    $args = new \ThriftSQL\BeeswaxService_fetch_args();
    $args->query_id = $query_id;
    $args->start_over = $start_over;
    $args->fetch_size = $fetch_size;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'fetch', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('fetch', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_fetch()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\BeeswaxService_fetch_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\BeeswaxService_fetch_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->error !== null) {
      throw $result->error;
    }
    if ($result->error2 !== null) {
      throw $result->error2;
    }
    throw new \Exception("fetch failed: unknown result");
  }

  public function get_state(\ThriftSQL\QueryHandle $handle)
  {
    $this->send_get_state($handle);
    return $this->recv_get_state();
  }

  public function send_get_state(\ThriftSQL\QueryHandle $handle)
  {
    $args = new \ThriftSQL\BeeswaxService_get_state_args();
    $args->handle = $handle;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_state', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_state', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_state()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\BeeswaxService_get_state_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\BeeswaxService_get_state_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->error !== null) {
      throw $result->error;
    }
    throw new \Exception("get_state failed: unknown result");
  }

  public function get_results_metadata(\ThriftSQL\QueryHandle $handle)
  {
    $this->send_get_results_metadata($handle);
    return $this->recv_get_results_metadata();
  }

  public function send_get_results_metadata(\ThriftSQL\QueryHandle $handle)
  {
    $args = new \ThriftSQL\BeeswaxService_get_results_metadata_args();
    $args->handle = $handle;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_results_metadata', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_results_metadata', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_results_metadata()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\BeeswaxService_get_results_metadata_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\BeeswaxService_get_results_metadata_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->error !== null) {
      throw $result->error;
    }
    throw new \Exception("get_results_metadata failed: unknown result");
  }

  public function echo_str($s)
  {
    $this->send_echo($s);
    return $this->recv_echo();
  }

  public function send_echo($s)
  {
    $args = new \ThriftSQL\BeeswaxService_echo_args();
    $args->s = $s;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'echo', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('echo', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_echo()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\BeeswaxService_echo_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\BeeswaxService_echo_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("echo failed: unknown result");
  }

  public function dump_config()
  {
    $this->send_dump_config();
    return $this->recv_dump_config();
  }

  public function send_dump_config()
  {
    $args = new \ThriftSQL\BeeswaxService_dump_config_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'dump_config', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('dump_config', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_dump_config()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\BeeswaxService_dump_config_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\BeeswaxService_dump_config_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("dump_config failed: unknown result");
  }

  public function get_log($context)
  {
    $this->send_get_log($context);
    return $this->recv_get_log();
  }

  public function send_get_log($context)
  {
    $args = new \ThriftSQL\BeeswaxService_get_log_args();
    $args->context = $context;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_log', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_log', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_log()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\BeeswaxService_get_log_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\BeeswaxService_get_log_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->error !== null) {
      throw $result->error;
    }
    throw new \Exception("get_log failed: unknown result");
  }

  public function get_default_configuration($include_hadoop)
  {
    $this->send_get_default_configuration($include_hadoop);
    return $this->recv_get_default_configuration();
  }

  public function send_get_default_configuration($include_hadoop)
  {
    $args = new \ThriftSQL\BeeswaxService_get_default_configuration_args();
    $args->include_hadoop = $include_hadoop;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_default_configuration', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_default_configuration', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_default_configuration()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\BeeswaxService_get_default_configuration_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\BeeswaxService_get_default_configuration_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("get_default_configuration failed: unknown result");
  }

  public function close(\ThriftSQL\QueryHandle $handle)
  {
    $this->send_close($handle);
    $this->recv_close();
  }

  public function send_close(\ThriftSQL\QueryHandle $handle)
  {
    $args = new \ThriftSQL\BeeswaxService_close_args();
    $args->handle = $handle;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'close', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('close', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_close()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\BeeswaxService_close_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\BeeswaxService_close_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->error !== null) {
      throw $result->error;
    }
    if ($result->error2 !== null) {
      throw $result->error2;
    }
    return;
  }

  public function clean($log_context)
  {
    $this->send_clean($log_context);
    $this->recv_clean();
  }

  public function send_clean($log_context)
  {
    $args = new \ThriftSQL\BeeswaxService_clean_args();
    $args->log_context = $log_context;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'clean', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('clean', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_clean()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\BeeswaxService_clean_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\BeeswaxService_clean_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    return;
  }

}

// HELPER FUNCTIONS AND STRUCTURES

class BeeswaxService_query_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\Query
   */
  public $query = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'query',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\Query',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['query'])) {
        $this->query = $vals['query'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_query_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->query = new \ThriftSQL\Query();
            $xfer += $this->query->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_query_args');
    if ($this->query !== null) {
      if (!is_object($this->query)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('query', TType::STRUCT, 1);
      $xfer += $this->query->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_query_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\QueryHandle
   */
  public $success = null;
  /**
   * @var \ThriftSQL\BeeswaxException
   */
  public $error = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\QueryHandle',
          ),
        1 => array(
          'var' => 'error',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\BeeswaxException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['error'])) {
        $this->error = $vals['error'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_query_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\QueryHandle();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->error = new \ThriftSQL\BeeswaxException();
            $xfer += $this->error->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_query_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->error !== null) {
      $xfer += $output->writeFieldBegin('error', TType::STRUCT, 1);
      $xfer += $this->error->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_executeAndWait_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\Query
   */
  public $query = null;
  /**
   * @var string
   */
  public $clientCtx = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'query',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\Query',
          ),
        2 => array(
          'var' => 'clientCtx',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['query'])) {
        $this->query = $vals['query'];
      }
      if (isset($vals['clientCtx'])) {
        $this->clientCtx = $vals['clientCtx'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_executeAndWait_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->query = new \ThriftSQL\Query();
            $xfer += $this->query->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->clientCtx);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_executeAndWait_args');
    if ($this->query !== null) {
      if (!is_object($this->query)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('query', TType::STRUCT, 1);
      $xfer += $this->query->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->clientCtx !== null) {
      $xfer += $output->writeFieldBegin('clientCtx', TType::STRING, 2);
      $xfer += $output->writeString($this->clientCtx);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_executeAndWait_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\QueryHandle
   */
  public $success = null;
  /**
   * @var \ThriftSQL\BeeswaxException
   */
  public $error = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\QueryHandle',
          ),
        1 => array(
          'var' => 'error',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\BeeswaxException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['error'])) {
        $this->error = $vals['error'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_executeAndWait_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\QueryHandle();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->error = new \ThriftSQL\BeeswaxException();
            $xfer += $this->error->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_executeAndWait_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->error !== null) {
      $xfer += $output->writeFieldBegin('error', TType::STRUCT, 1);
      $xfer += $this->error->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_explain_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\Query
   */
  public $query = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'query',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\Query',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['query'])) {
        $this->query = $vals['query'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_explain_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->query = new \ThriftSQL\Query();
            $xfer += $this->query->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_explain_args');
    if ($this->query !== null) {
      if (!is_object($this->query)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('query', TType::STRUCT, 1);
      $xfer += $this->query->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_explain_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\QueryExplanation
   */
  public $success = null;
  /**
   * @var \ThriftSQL\BeeswaxException
   */
  public $error = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\QueryExplanation',
          ),
        1 => array(
          'var' => 'error',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\BeeswaxException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['error'])) {
        $this->error = $vals['error'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_explain_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\QueryExplanation();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->error = new \ThriftSQL\BeeswaxException();
            $xfer += $this->error->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_explain_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->error !== null) {
      $xfer += $output->writeFieldBegin('error', TType::STRUCT, 1);
      $xfer += $this->error->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_fetch_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\QueryHandle
   */
  public $query_id = null;
  /**
   * @var bool
   */
  public $start_over = null;
  /**
   * @var int
   */
  public $fetch_size = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'query_id',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\QueryHandle',
          ),
        2 => array(
          'var' => 'start_over',
          'type' => TType::BOOL,
          ),
        3 => array(
          'var' => 'fetch_size',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['query_id'])) {
        $this->query_id = $vals['query_id'];
      }
      if (isset($vals['start_over'])) {
        $this->start_over = $vals['start_over'];
      }
      if (isset($vals['fetch_size'])) {
        $this->fetch_size = $vals['fetch_size'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_fetch_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->query_id = new \ThriftSQL\QueryHandle();
            $xfer += $this->query_id->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->start_over);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->fetch_size);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_fetch_args');
    if ($this->query_id !== null) {
      if (!is_object($this->query_id)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('query_id', TType::STRUCT, 1);
      $xfer += $this->query_id->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->start_over !== null) {
      $xfer += $output->writeFieldBegin('start_over', TType::BOOL, 2);
      $xfer += $output->writeBool($this->start_over);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fetch_size !== null) {
      $xfer += $output->writeFieldBegin('fetch_size', TType::I32, 3);
      $xfer += $output->writeI32($this->fetch_size);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_fetch_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\Results
   */
  public $success = null;
  /**
   * @var \ThriftSQL\QueryNotFoundException
   */
  public $error = null;
  /**
   * @var \ThriftSQL\BeeswaxException
   */
  public $error2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\Results',
          ),
        1 => array(
          'var' => 'error',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\QueryNotFoundException',
          ),
        2 => array(
          'var' => 'error2',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\BeeswaxException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['error'])) {
        $this->error = $vals['error'];
      }
      if (isset($vals['error2'])) {
        $this->error2 = $vals['error2'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_fetch_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\Results();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->error = new \ThriftSQL\QueryNotFoundException();
            $xfer += $this->error->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->error2 = new \ThriftSQL\BeeswaxException();
            $xfer += $this->error2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_fetch_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->error !== null) {
      $xfer += $output->writeFieldBegin('error', TType::STRUCT, 1);
      $xfer += $this->error->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->error2 !== null) {
      $xfer += $output->writeFieldBegin('error2', TType::STRUCT, 2);
      $xfer += $this->error2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_get_state_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\QueryHandle
   */
  public $handle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'handle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\QueryHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['handle'])) {
        $this->handle = $vals['handle'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_get_state_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->handle = new \ThriftSQL\QueryHandle();
            $xfer += $this->handle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_get_state_args');
    if ($this->handle !== null) {
      if (!is_object($this->handle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('handle', TType::STRUCT, 1);
      $xfer += $this->handle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_get_state_result {
  static $_TSPEC;

  /**
   * @var int
   */
  public $success = null;
  /**
   * @var \ThriftSQL\QueryNotFoundException
   */
  public $error = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'error',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\QueryNotFoundException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['error'])) {
        $this->error = $vals['error'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_get_state_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->error = new \ThriftSQL\QueryNotFoundException();
            $xfer += $this->error->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_get_state_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->error !== null) {
      $xfer += $output->writeFieldBegin('error', TType::STRUCT, 1);
      $xfer += $this->error->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_get_results_metadata_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\QueryHandle
   */
  public $handle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'handle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\QueryHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['handle'])) {
        $this->handle = $vals['handle'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_get_results_metadata_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->handle = new \ThriftSQL\QueryHandle();
            $xfer += $this->handle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_get_results_metadata_args');
    if ($this->handle !== null) {
      if (!is_object($this->handle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('handle', TType::STRUCT, 1);
      $xfer += $this->handle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_get_results_metadata_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\ResultsMetadata
   */
  public $success = null;
  /**
   * @var \ThriftSQL\QueryNotFoundException
   */
  public $error = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\ResultsMetadata',
          ),
        1 => array(
          'var' => 'error',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\QueryNotFoundException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['error'])) {
        $this->error = $vals['error'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_get_results_metadata_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\ResultsMetadata();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->error = new \ThriftSQL\QueryNotFoundException();
            $xfer += $this->error->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_get_results_metadata_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->error !== null) {
      $xfer += $output->writeFieldBegin('error', TType::STRUCT, 1);
      $xfer += $this->error->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_echo_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $s = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 's',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['s'])) {
        $this->s = $vals['s'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_echo_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->s);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_echo_args');
    if ($this->s !== null) {
      $xfer += $output->writeFieldBegin('s', TType::STRING, 1);
      $xfer += $output->writeString($this->s);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_echo_result {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_echo_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_echo_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($this->success);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_dump_config_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'BeeswaxService_dump_config_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_dump_config_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_dump_config_result {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_dump_config_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_dump_config_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($this->success);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_get_log_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $context = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'context',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['context'])) {
        $this->context = $vals['context'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_get_log_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->context);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_get_log_args');
    if ($this->context !== null) {
      $xfer += $output->writeFieldBegin('context', TType::STRING, 1);
      $xfer += $output->writeString($this->context);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_get_log_result {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;
  /**
   * @var \ThriftSQL\QueryNotFoundException
   */
  public $error = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'error',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\QueryNotFoundException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['error'])) {
        $this->error = $vals['error'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_get_log_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->error = new \ThriftSQL\QueryNotFoundException();
            $xfer += $this->error->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_get_log_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->error !== null) {
      $xfer += $output->writeFieldBegin('error', TType::STRUCT, 1);
      $xfer += $this->error->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_get_default_configuration_args {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $include_hadoop = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'include_hadoop',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['include_hadoop'])) {
        $this->include_hadoop = $vals['include_hadoop'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_get_default_configuration_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->include_hadoop);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_get_default_configuration_args');
    if ($this->include_hadoop !== null) {
      $xfer += $output->writeFieldBegin('include_hadoop', TType::BOOL, 1);
      $xfer += $output->writeBool($this->include_hadoop);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_get_default_configuration_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\ConfigVariable[]
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ThriftSQL\ConfigVariable',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_get_default_configuration_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size21 = 0;
            $_etype24 = 0;
            $xfer += $input->readListBegin($_etype24, $_size21);
            for ($_i25 = 0; $_i25 < $_size21; ++$_i25)
            {
              $elem26 = null;
              $elem26 = new \ThriftSQL\ConfigVariable();
              $xfer += $elem26->read($input);
              $this->success []= $elem26;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_get_default_configuration_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter27)
          {
            $xfer += $iter27->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_close_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\QueryHandle
   */
  public $handle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'handle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\QueryHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['handle'])) {
        $this->handle = $vals['handle'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_close_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->handle = new \ThriftSQL\QueryHandle();
            $xfer += $this->handle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_close_args');
    if ($this->handle !== null) {
      if (!is_object($this->handle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('handle', TType::STRUCT, 1);
      $xfer += $this->handle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_close_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\QueryNotFoundException
   */
  public $error = null;
  /**
   * @var \ThriftSQL\BeeswaxException
   */
  public $error2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'error',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\QueryNotFoundException',
          ),
        2 => array(
          'var' => 'error2',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\BeeswaxException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['error'])) {
        $this->error = $vals['error'];
      }
      if (isset($vals['error2'])) {
        $this->error2 = $vals['error2'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_close_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->error = new \ThriftSQL\QueryNotFoundException();
            $xfer += $this->error->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->error2 = new \ThriftSQL\BeeswaxException();
            $xfer += $this->error2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_close_result');
    if ($this->error !== null) {
      $xfer += $output->writeFieldBegin('error', TType::STRUCT, 1);
      $xfer += $this->error->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->error2 !== null) {
      $xfer += $output->writeFieldBegin('error2', TType::STRUCT, 2);
      $xfer += $this->error2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_clean_args {
  static $_TSPEC;

  /**
   * @var string
   */
  public $log_context = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'log_context',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['log_context'])) {
        $this->log_context = $vals['log_context'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxService_clean_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->log_context);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_clean_args');
    if ($this->log_context !== null) {
      $xfer += $output->writeFieldBegin('log_context', TType::STRING, 1);
      $xfer += $output->writeString($this->log_context);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxService_clean_result {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'BeeswaxService_clean_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxService_clean_result');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}
<?php
namespace ThriftSQL;
/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


final class QueryState {
  const CREATED = 0;
  const INITIALIZED = 1;
  const COMPILED = 2;
  const RUNNING = 3;
  const FINISHED = 4;
  const EXCEPTION = 5;
  static public $__names = array(
    0 => 'CREATED',
    1 => 'INITIALIZED',
    2 => 'COMPILED',
    3 => 'RUNNING',
    4 => 'FINISHED',
    5 => 'EXCEPTION',
  );
}

class Query {
  static $_TSPEC;

  /**
   * @var string
   */
  public $query = null;
  /**
   * @var string[]
   */
  public $configuration = null;
  /**
   * @var string
   */
  public $hadoop_user = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'query',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'configuration',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'hadoop_user',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['query'])) {
        $this->query = $vals['query'];
      }
      if (isset($vals['configuration'])) {
        $this->configuration = $vals['configuration'];
      }
      if (isset($vals['hadoop_user'])) {
        $this->hadoop_user = $vals['hadoop_user'];
      }
    }
  }

  public function getName() {
    return 'Query';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->query);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->configuration = array();
            $_size0 = 0;
            $_etype3 = 0;
            $xfer += $input->readListBegin($_etype3, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $elem5 = null;
              $xfer += $input->readString($elem5);
              $this->configuration []= $elem5;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->hadoop_user);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Query');
    if ($this->query !== null) {
      $xfer += $output->writeFieldBegin('query', TType::STRING, 1);
      $xfer += $output->writeString($this->query);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->configuration !== null) {
      if (!is_array($this->configuration)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('configuration', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->configuration));
        {
          foreach ($this->configuration as $iter6)
          {
            $xfer += $output->writeString($iter6);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hadoop_user !== null) {
      $xfer += $output->writeFieldBegin('hadoop_user', TType::STRING, 4);
      $xfer += $output->writeString($this->hadoop_user);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryHandle {
  static $_TSPEC;

  /**
   * @var string
   */
  public $id = null;
  /**
   * @var string
   */
  public $log_context = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'log_context',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['log_context'])) {
        $this->log_context = $vals['log_context'];
      }
    }
  }

  public function getName() {
    return 'QueryHandle';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->log_context);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryHandle');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->log_context !== null) {
      $xfer += $output->writeFieldBegin('log_context', TType::STRING, 2);
      $xfer += $output->writeString($this->log_context);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryExplanation {
  static $_TSPEC;

  /**
   * @var string
   */
  public $textual = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'textual',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['textual'])) {
        $this->textual = $vals['textual'];
      }
    }
  }

  public function getName() {
    return 'QueryExplanation';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->textual);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryExplanation');
    if ($this->textual !== null) {
      $xfer += $output->writeFieldBegin('textual', TType::STRING, 1);
      $xfer += $output->writeString($this->textual);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Results {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $ready = null;
  /**
   * @var string[]
   */
  public $columns = null;
  /**
   * @var string[]
   */
  public $data = null;
  /**
   * @var int
   */
  public $start_row = null;
  /**
   * @var bool
   */
  public $has_more = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ready',
          'type' => TType::BOOL,
          ),
        2 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'data',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'start_row',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'has_more',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ready'])) {
        $this->ready = $vals['ready'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['data'])) {
        $this->data = $vals['data'];
      }
      if (isset($vals['start_row'])) {
        $this->start_row = $vals['start_row'];
      }
      if (isset($vals['has_more'])) {
        $this->has_more = $vals['has_more'];
      }
    }
  }

  public function getName() {
    return 'Results';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->ready);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size7 = 0;
            $_etype10 = 0;
            $xfer += $input->readListBegin($_etype10, $_size7);
            for ($_i11 = 0; $_i11 < $_size7; ++$_i11)
            {
              $elem12 = null;
              $xfer += $input->readString($elem12);
              $this->columns []= $elem12;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->data = array();
            $_size13 = 0;
            $_etype16 = 0;
            $xfer += $input->readListBegin($_etype16, $_size13);
            for ($_i17 = 0; $_i17 < $_size13; ++$_i17)
            {
              $elem18 = null;
              $xfer += $input->readString($elem18);
              $this->data []= $elem18;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->start_row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->has_more);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Results');
    if ($this->ready !== null) {
      $xfer += $output->writeFieldBegin('ready', TType::BOOL, 1);
      $xfer += $output->writeBool($this->ready);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter19)
          {
            $xfer += $output->writeString($iter19);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->data !== null) {
      if (!is_array($this->data)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('data', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->data));
        {
          foreach ($this->data as $iter20)
          {
            $xfer += $output->writeString($iter20);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->start_row !== null) {
      $xfer += $output->writeFieldBegin('start_row', TType::I64, 4);
      $xfer += $output->writeI64($this->start_row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->has_more !== null) {
      $xfer += $output->writeFieldBegin('has_more', TType::BOOL, 5);
      $xfer += $output->writeBool($this->has_more);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Metadata information about the results.
 * Applicable only for SELECT.
 */
class ResultsMetadata {
  static $_TSPEC;

  /**
   * The schema of the results
   *
   * @var \ThriftSQL\metastore\Schema
   */
  public $schema = null;
  /**
   * The directory containing the results. Not applicable for partition table.
   *
   * @var string
   */
  public $table_dir = null;
  /**
   * If the results are straight from an existing table, the table name.
   *
   * @var string
   */
  public $in_tablename = null;
  /**
   * Field delimiter
   *
   * @var string
   */
  public $delim = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'schema',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\metastore\Schema',
          ),
        2 => array(
          'var' => 'table_dir',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'in_tablename',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'delim',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['schema'])) {
        $this->schema = $vals['schema'];
      }
      if (isset($vals['table_dir'])) {
        $this->table_dir = $vals['table_dir'];
      }
      if (isset($vals['in_tablename'])) {
        $this->in_tablename = $vals['in_tablename'];
      }
      if (isset($vals['delim'])) {
        $this->delim = $vals['delim'];
      }
    }
  }

  public function getName() {
    return 'ResultsMetadata';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->schema = new \ThriftSQL\metastore\Schema();
            $xfer += $this->schema->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_dir);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->in_tablename);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->delim);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ResultsMetadata');
    if ($this->schema !== null) {
      if (!is_object($this->schema)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('schema', TType::STRUCT, 1);
      $xfer += $this->schema->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_dir !== null) {
      $xfer += $output->writeFieldBegin('table_dir', TType::STRING, 2);
      $xfer += $output->writeString($this->table_dir);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->in_tablename !== null) {
      $xfer += $output->writeFieldBegin('in_tablename', TType::STRING, 3);
      $xfer += $output->writeString($this->in_tablename);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->delim !== null) {
      $xfer += $output->writeFieldBegin('delim', TType::STRING, 4);
      $xfer += $output->writeString($this->delim);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeeswaxException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;
  /**
   * @var string
   */
  public $log_context = null;
  /**
   * @var \ThriftSQL\QueryHandle
   */
  public $handle = null;
  /**
   * @var int
   */
  public $errorCode = 0;
  /**
   * @var string
   */
  public $SQLState = "     ";

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'log_context',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'handle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\QueryHandle',
          ),
        4 => array(
          'var' => 'errorCode',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'SQLState',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
      if (isset($vals['log_context'])) {
        $this->log_context = $vals['log_context'];
      }
      if (isset($vals['handle'])) {
        $this->handle = $vals['handle'];
      }
      if (isset($vals['errorCode'])) {
        $this->errorCode = $vals['errorCode'];
      }
      if (isset($vals['SQLState'])) {
        $this->SQLState = $vals['SQLState'];
      }
    }
  }

  public function getName() {
    return 'BeeswaxException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->log_context);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->handle = new \ThriftSQL\QueryHandle();
            $xfer += $this->handle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->errorCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->SQLState);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeeswaxException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->log_context !== null) {
      $xfer += $output->writeFieldBegin('log_context', TType::STRING, 2);
      $xfer += $output->writeString($this->log_context);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->handle !== null) {
      if (!is_object($this->handle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('handle', TType::STRUCT, 3);
      $xfer += $this->handle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorCode !== null) {
      $xfer += $output->writeFieldBegin('errorCode', TType::I32, 4);
      $xfer += $output->writeI32($this->errorCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->SQLState !== null) {
      $xfer += $output->writeFieldBegin('SQLState', TType::STRING, 5);
      $xfer += $output->writeString($this->SQLState);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryNotFoundException extends TException {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'QueryNotFoundException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryNotFoundException');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Represents a Hadoop-style configuration variable.
 */
class ConfigVariable {
  static $_TSPEC;

  /**
   * @var string
   */
  public $key = null;
  /**
   * @var string
   */
  public $value = null;
  /**
   * @var string
   */
  public $description = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'value',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'description',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['key'])) {
        $this->key = $vals['key'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
      if (isset($vals['description'])) {
        $this->description = $vals['description'];
      }
    }
  }

  public function getName() {
    return 'ConfigVariable';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->key);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->description);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ConfigVariable');
    if ($this->key !== null) {
      $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
      $xfer += $output->writeString($this->key);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->description !== null) {
      $xfer += $output->writeFieldBegin('description', TType::STRING, 3);
      $xfer += $output->writeString($this->description);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}
<?php
namespace ThriftSQL;
/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


interface ImpalaHiveServer2ServiceIf extends \ThriftSQL\TCLIServiceIf {
  /**
   * @param \ThriftSQL\TGetExecSummaryReq $req
   * @return \ThriftSQL\TGetExecSummaryResp
   */
  public function GetExecSummary(\ThriftSQL\TGetExecSummaryReq $req);
  /**
   * @param \ThriftSQL\TGetRuntimeProfileReq $req
   * @return \ThriftSQL\TGetRuntimeProfileResp
   */
  public function GetRuntimeProfile(\ThriftSQL\TGetRuntimeProfileReq $req);
}

class ImpalaHiveServer2ServiceClient extends \ThriftSQL\TCLIServiceClient implements \ThriftSQL\ImpalaHiveServer2ServiceIf {
  public function __construct($input, $output=null) {
    parent::__construct($input, $output);
  }

  public function GetExecSummary(\ThriftSQL\TGetExecSummaryReq $req)
  {
    $this->send_GetExecSummary($req);
    return $this->recv_GetExecSummary();
  }

  public function send_GetExecSummary(\ThriftSQL\TGetExecSummaryReq $req)
  {
    $args = new \ThriftSQL\ImpalaHiveServer2Service_GetExecSummary_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'GetExecSummary', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('GetExecSummary', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_GetExecSummary()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\ImpalaHiveServer2Service_GetExecSummary_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\ImpalaHiveServer2Service_GetExecSummary_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("GetExecSummary failed: unknown result");
  }

  public function GetRuntimeProfile(\ThriftSQL\TGetRuntimeProfileReq $req)
  {
    $this->send_GetRuntimeProfile($req);
    return $this->recv_GetRuntimeProfile();
  }

  public function send_GetRuntimeProfile(\ThriftSQL\TGetRuntimeProfileReq $req)
  {
    $args = new \ThriftSQL\ImpalaHiveServer2Service_GetRuntimeProfile_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'GetRuntimeProfile', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('GetRuntimeProfile', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_GetRuntimeProfile()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\ImpalaHiveServer2Service_GetRuntimeProfile_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\ImpalaHiveServer2Service_GetRuntimeProfile_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("GetRuntimeProfile failed: unknown result");
  }

}

// HELPER FUNCTIONS AND STRUCTURES

class ImpalaHiveServer2Service_GetExecSummary_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetExecSummaryReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetExecSummaryReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'ImpalaHiveServer2Service_GetExecSummary_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TGetExecSummaryReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ImpalaHiveServer2Service_GetExecSummary_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ImpalaHiveServer2Service_GetExecSummary_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetExecSummaryResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetExecSummaryResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ImpalaHiveServer2Service_GetExecSummary_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TGetExecSummaryResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ImpalaHiveServer2Service_GetExecSummary_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ImpalaHiveServer2Service_GetRuntimeProfile_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetRuntimeProfileReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetRuntimeProfileReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'ImpalaHiveServer2Service_GetRuntimeProfile_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TGetRuntimeProfileReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ImpalaHiveServer2Service_GetRuntimeProfile_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ImpalaHiveServer2Service_GetRuntimeProfile_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetRuntimeProfileResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetRuntimeProfileResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ImpalaHiveServer2Service_GetRuntimeProfile_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TGetRuntimeProfileResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ImpalaHiveServer2Service_GetRuntimeProfile_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}
<?php
namespace ThriftSQL;
/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


interface ImpalaServiceIf extends \ThriftSQL\BeeswaxServiceIf {
  /**
   * @param \ThriftSQL\QueryHandle $query_id
   * @return \ThriftSQL\TStatus
   * @throws \ThriftSQL\BeeswaxException
   */
  public function Cancel(\ThriftSQL\QueryHandle $query_id);
  /**
   * @return \ThriftSQL\TStatus
   */
  public function ResetCatalog();
  /**
   * @param \ThriftSQL\TResetTableReq $request
   * @return \ThriftSQL\TStatus
   */
  public function ResetTable(\ThriftSQL\TResetTableReq $request);
  /**
   * @param \ThriftSQL\QueryHandle $query_id
   * @return string
   * @throws \ThriftSQL\BeeswaxException
   */
  public function GetRuntimeProfile(\ThriftSQL\QueryHandle $query_id);
  /**
   * @param \ThriftSQL\QueryHandle $handle
   * @return \ThriftSQL\TInsertResult
   * @throws \ThriftSQL\QueryNotFoundException
   * @throws \ThriftSQL\BeeswaxException
   */
  public function CloseInsert(\ThriftSQL\QueryHandle $handle);
  /**
   * @return \ThriftSQL\TPingImpalaServiceResp
   */
  public function PingImpalaService();
  /**
   * @param \ThriftSQL\QueryHandle $handle
   * @return \ThriftSQL\TExecSummary
   * @throws \ThriftSQL\QueryNotFoundException
   * @throws \ThriftSQL\BeeswaxException
   */
  public function GetExecSummary(\ThriftSQL\QueryHandle $handle);
}

class ImpalaServiceClient extends \ThriftSQL\BeeswaxServiceClient implements \ThriftSQL\ImpalaServiceIf {
  public function __construct($input, $output=null) {
    parent::__construct($input, $output);
  }

  public function Cancel(\ThriftSQL\QueryHandle $query_id)
  {
    $this->send_Cancel($query_id);
    return $this->recv_Cancel();
  }

  public function send_Cancel(\ThriftSQL\QueryHandle $query_id)
  {
    $args = new \ThriftSQL\ImpalaService_Cancel_args();
    $args->query_id = $query_id;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'Cancel', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('Cancel', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_Cancel()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\ImpalaService_Cancel_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\ImpalaService_Cancel_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->error !== null) {
      throw $result->error;
    }
    throw new \Exception("Cancel failed: unknown result");
  }

  public function ResetCatalog()
  {
    $this->send_ResetCatalog();
    return $this->recv_ResetCatalog();
  }

  public function send_ResetCatalog()
  {
    $args = new \ThriftSQL\ImpalaService_ResetCatalog_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'ResetCatalog', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('ResetCatalog', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_ResetCatalog()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\ImpalaService_ResetCatalog_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\ImpalaService_ResetCatalog_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("ResetCatalog failed: unknown result");
  }

  public function ResetTable(\ThriftSQL\TResetTableReq $request)
  {
    $this->send_ResetTable($request);
    return $this->recv_ResetTable();
  }

  public function send_ResetTable(\ThriftSQL\TResetTableReq $request)
  {
    $args = new \ThriftSQL\ImpalaService_ResetTable_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'ResetTable', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('ResetTable', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_ResetTable()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\ImpalaService_ResetTable_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\ImpalaService_ResetTable_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("ResetTable failed: unknown result");
  }

  public function GetRuntimeProfile(\ThriftSQL\QueryHandle $query_id)
  {
    $this->send_GetRuntimeProfile($query_id);
    return $this->recv_GetRuntimeProfile();
  }

  public function send_GetRuntimeProfile(\ThriftSQL\QueryHandle $query_id)
  {
    $args = new \ThriftSQL\ImpalaService_GetRuntimeProfile_args();
    $args->query_id = $query_id;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'GetRuntimeProfile', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('GetRuntimeProfile', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_GetRuntimeProfile()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\ImpalaService_GetRuntimeProfile_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\ImpalaService_GetRuntimeProfile_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->error !== null) {
      throw $result->error;
    }
    throw new \Exception("GetRuntimeProfile failed: unknown result");
  }

  public function CloseInsert(\ThriftSQL\QueryHandle $handle)
  {
    $this->send_CloseInsert($handle);
    return $this->recv_CloseInsert();
  }

  public function send_CloseInsert(\ThriftSQL\QueryHandle $handle)
  {
    $args = new \ThriftSQL\ImpalaService_CloseInsert_args();
    $args->handle = $handle;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'CloseInsert', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('CloseInsert', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_CloseInsert()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\ImpalaService_CloseInsert_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\ImpalaService_CloseInsert_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->error !== null) {
      throw $result->error;
    }
    if ($result->error2 !== null) {
      throw $result->error2;
    }
    throw new \Exception("CloseInsert failed: unknown result");
  }

  public function PingImpalaService()
  {
    $this->send_PingImpalaService();
    return $this->recv_PingImpalaService();
  }

  public function send_PingImpalaService()
  {
    $args = new \ThriftSQL\ImpalaService_PingImpalaService_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'PingImpalaService', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('PingImpalaService', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_PingImpalaService()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\ImpalaService_PingImpalaService_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\ImpalaService_PingImpalaService_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("PingImpalaService failed: unknown result");
  }

  public function GetExecSummary(\ThriftSQL\QueryHandle $handle)
  {
    $this->send_GetExecSummary($handle);
    return $this->recv_GetExecSummary();
  }

  public function send_GetExecSummary(\ThriftSQL\QueryHandle $handle)
  {
    $args = new \ThriftSQL\ImpalaService_GetExecSummary_args();
    $args->handle = $handle;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'GetExecSummary', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('GetExecSummary', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_GetExecSummary()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\ImpalaService_GetExecSummary_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\ImpalaService_GetExecSummary_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->error !== null) {
      throw $result->error;
    }
    if ($result->error2 !== null) {
      throw $result->error2;
    }
    throw new \Exception("GetExecSummary failed: unknown result");
  }

}

// HELPER FUNCTIONS AND STRUCTURES

class ImpalaService_Cancel_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\QueryHandle
   */
  public $query_id = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'query_id',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\QueryHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['query_id'])) {
        $this->query_id = $vals['query_id'];
      }
    }
  }

  public function getName() {
    return 'ImpalaService_Cancel_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->query_id = new \ThriftSQL\QueryHandle();
            $xfer += $this->query_id->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ImpalaService_Cancel_args');
    if ($this->query_id !== null) {
      if (!is_object($this->query_id)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('query_id', TType::STRUCT, 1);
      $xfer += $this->query_id->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ImpalaService_Cancel_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $success = null;
  /**
   * @var \ThriftSQL\BeeswaxException
   */
  public $error = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        1 => array(
          'var' => 'error',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\BeeswaxException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['error'])) {
        $this->error = $vals['error'];
      }
    }
  }

  public function getName() {
    return 'ImpalaService_Cancel_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TStatus();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->error = new \ThriftSQL\BeeswaxException();
            $xfer += $this->error->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ImpalaService_Cancel_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->error !== null) {
      $xfer += $output->writeFieldBegin('error', TType::STRUCT, 1);
      $xfer += $this->error->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ImpalaService_ResetCatalog_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ImpalaService_ResetCatalog_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ImpalaService_ResetCatalog_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ImpalaService_ResetCatalog_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ImpalaService_ResetCatalog_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TStatus();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ImpalaService_ResetCatalog_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ImpalaService_ResetTable_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TResetTableReq
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TResetTableReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ImpalaService_ResetTable_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new \ThriftSQL\TResetTableReq();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ImpalaService_ResetTable_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ImpalaService_ResetTable_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ImpalaService_ResetTable_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TStatus();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ImpalaService_ResetTable_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ImpalaService_GetRuntimeProfile_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\QueryHandle
   */
  public $query_id = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'query_id',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\QueryHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['query_id'])) {
        $this->query_id = $vals['query_id'];
      }
    }
  }

  public function getName() {
    return 'ImpalaService_GetRuntimeProfile_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->query_id = new \ThriftSQL\QueryHandle();
            $xfer += $this->query_id->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ImpalaService_GetRuntimeProfile_args');
    if ($this->query_id !== null) {
      if (!is_object($this->query_id)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('query_id', TType::STRUCT, 1);
      $xfer += $this->query_id->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ImpalaService_GetRuntimeProfile_result {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;
  /**
   * @var \ThriftSQL\BeeswaxException
   */
  public $error = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'error',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\BeeswaxException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['error'])) {
        $this->error = $vals['error'];
      }
    }
  }

  public function getName() {
    return 'ImpalaService_GetRuntimeProfile_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->error = new \ThriftSQL\BeeswaxException();
            $xfer += $this->error->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ImpalaService_GetRuntimeProfile_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->error !== null) {
      $xfer += $output->writeFieldBegin('error', TType::STRUCT, 1);
      $xfer += $this->error->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ImpalaService_CloseInsert_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\QueryHandle
   */
  public $handle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'handle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\QueryHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['handle'])) {
        $this->handle = $vals['handle'];
      }
    }
  }

  public function getName() {
    return 'ImpalaService_CloseInsert_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->handle = new \ThriftSQL\QueryHandle();
            $xfer += $this->handle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ImpalaService_CloseInsert_args');
    if ($this->handle !== null) {
      if (!is_object($this->handle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('handle', TType::STRUCT, 1);
      $xfer += $this->handle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ImpalaService_CloseInsert_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TInsertResult
   */
  public $success = null;
  /**
   * @var \ThriftSQL\QueryNotFoundException
   */
  public $error = null;
  /**
   * @var \ThriftSQL\BeeswaxException
   */
  public $error2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TInsertResult',
          ),
        1 => array(
          'var' => 'error',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\QueryNotFoundException',
          ),
        2 => array(
          'var' => 'error2',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\BeeswaxException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['error'])) {
        $this->error = $vals['error'];
      }
      if (isset($vals['error2'])) {
        $this->error2 = $vals['error2'];
      }
    }
  }

  public function getName() {
    return 'ImpalaService_CloseInsert_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TInsertResult();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->error = new \ThriftSQL\QueryNotFoundException();
            $xfer += $this->error->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->error2 = new \ThriftSQL\BeeswaxException();
            $xfer += $this->error2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ImpalaService_CloseInsert_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->error !== null) {
      $xfer += $output->writeFieldBegin('error', TType::STRUCT, 1);
      $xfer += $this->error->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->error2 !== null) {
      $xfer += $output->writeFieldBegin('error2', TType::STRUCT, 2);
      $xfer += $this->error2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ImpalaService_PingImpalaService_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ImpalaService_PingImpalaService_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ImpalaService_PingImpalaService_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ImpalaService_PingImpalaService_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TPingImpalaServiceResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TPingImpalaServiceResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ImpalaService_PingImpalaService_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TPingImpalaServiceResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ImpalaService_PingImpalaService_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ImpalaService_GetExecSummary_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\QueryHandle
   */
  public $handle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'handle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\QueryHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['handle'])) {
        $this->handle = $vals['handle'];
      }
    }
  }

  public function getName() {
    return 'ImpalaService_GetExecSummary_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->handle = new \ThriftSQL\QueryHandle();
            $xfer += $this->handle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ImpalaService_GetExecSummary_args');
    if ($this->handle !== null) {
      if (!is_object($this->handle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('handle', TType::STRUCT, 1);
      $xfer += $this->handle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ImpalaService_GetExecSummary_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TExecSummary
   */
  public $success = null;
  /**
   * @var \ThriftSQL\QueryNotFoundException
   */
  public $error = null;
  /**
   * @var \ThriftSQL\BeeswaxException
   */
  public $error2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TExecSummary',
          ),
        1 => array(
          'var' => 'error',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\QueryNotFoundException',
          ),
        2 => array(
          'var' => 'error2',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\BeeswaxException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['error'])) {
        $this->error = $vals['error'];
      }
      if (isset($vals['error2'])) {
        $this->error2 = $vals['error2'];
      }
    }
  }

  public function getName() {
    return 'ImpalaService_GetExecSummary_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TExecSummary();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->error = new \ThriftSQL\QueryNotFoundException();
            $xfer += $this->error->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->error2 = new \ThriftSQL\BeeswaxException();
            $xfer += $this->error2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ImpalaService_GetExecSummary_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->error !== null) {
      $xfer += $output->writeFieldBegin('error', TType::STRUCT, 1);
      $xfer += $this->error->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->error2 !== null) {
      $xfer += $output->writeFieldBegin('error2', TType::STRUCT, 2);
      $xfer += $this->error2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}
<?php
namespace ThriftSQL;
/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


final class TImpalaQueryOptions {
  const ABORT_ON_ERROR = 0;
  const MAX_ERRORS = 1;
  const DISABLE_CODEGEN = 2;
  const BATCH_SIZE = 3;
  const MEM_LIMIT = 4;
  const NUM_NODES = 5;
  const MAX_SCAN_RANGE_LENGTH = 6;
  const MAX_IO_BUFFERS = 7;
  const NUM_SCANNER_THREADS = 8;
  const ALLOW_UNSUPPORTED_FORMATS = 9;
  const DEFAULT_ORDER_BY_LIMIT = 10;
  const DEBUG_ACTION = 11;
  const ABORT_ON_DEFAULT_LIMIT_EXCEEDED = 12;
  const COMPRESSION_CODEC = 13;
  const SEQ_COMPRESSION_MODE = 14;
  const HBASE_CACHING = 15;
  const HBASE_CACHE_BLOCKS = 16;
  const PARQUET_FILE_SIZE = 17;
  const EXPLAIN_LEVEL = 18;
  const SYNC_DDL = 19;
  const REQUEST_POOL = 20;
  const V_CPU_CORES = 21;
  const RESERVATION_REQUEST_TIMEOUT = 22;
  const DISABLE_CACHED_READS = 23;
  const DISABLE_OUTERMOST_TOPN = 24;
  const RM_INITIAL_MEM = 25;
  const QUERY_TIMEOUT_S = 26;
  const MAX_BLOCK_MGR_MEMORY = 27;
  const APPX_COUNT_DISTINCT = 28;
  const DISABLE_UNSAFE_SPILLS = 29;
  const EXEC_SINGLE_NODE_ROWS_THRESHOLD = 30;
  static public $__names = array(
    0 => 'ABORT_ON_ERROR',
    1 => 'MAX_ERRORS',
    2 => 'DISABLE_CODEGEN',
    3 => 'BATCH_SIZE',
    4 => 'MEM_LIMIT',
    5 => 'NUM_NODES',
    6 => 'MAX_SCAN_RANGE_LENGTH',
    7 => 'MAX_IO_BUFFERS',
    8 => 'NUM_SCANNER_THREADS',
    9 => 'ALLOW_UNSUPPORTED_FORMATS',
    10 => 'DEFAULT_ORDER_BY_LIMIT',
    11 => 'DEBUG_ACTION',
    12 => 'ABORT_ON_DEFAULT_LIMIT_EXCEEDED',
    13 => 'COMPRESSION_CODEC',
    14 => 'SEQ_COMPRESSION_MODE',
    15 => 'HBASE_CACHING',
    16 => 'HBASE_CACHE_BLOCKS',
    17 => 'PARQUET_FILE_SIZE',
    18 => 'EXPLAIN_LEVEL',
    19 => 'SYNC_DDL',
    20 => 'REQUEST_POOL',
    21 => 'V_CPU_CORES',
    22 => 'RESERVATION_REQUEST_TIMEOUT',
    23 => 'DISABLE_CACHED_READS',
    24 => 'DISABLE_OUTERMOST_TOPN',
    25 => 'RM_INITIAL_MEM',
    26 => 'QUERY_TIMEOUT_S',
    27 => 'MAX_BLOCK_MGR_MEMORY',
    28 => 'APPX_COUNT_DISTINCT',
    29 => 'DISABLE_UNSAFE_SPILLS',
    30 => 'EXEC_SINGLE_NODE_ROWS_THRESHOLD',
  );
}

class TInsertResult {
  static $_TSPEC;

  /**
   * @var array
   */
  public $rows_appended = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'rows_appended',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I64,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I64,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['rows_appended'])) {
        $this->rows_appended = $vals['rows_appended'];
      }
    }
  }

  public function getName() {
    return 'TInsertResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->rows_appended = array();
            $_size0 = 0;
            $_ktype1 = 0;
            $_vtype2 = 0;
            $xfer += $input->readMapBegin($_ktype1, $_vtype2, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $key5 = '';
              $val6 = 0;
              $xfer += $input->readString($key5);
              $xfer += $input->readI64($val6);
              $this->rows_appended[$key5] = $val6;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TInsertResult');
    if ($this->rows_appended !== null) {
      if (!is_array($this->rows_appended)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rows_appended', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::I64, count($this->rows_appended));
        {
          foreach ($this->rows_appended as $kiter7 => $viter8)
          {
            $xfer += $output->writeString($kiter7);
            $xfer += $output->writeI64($viter8);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TPingImpalaServiceResp {
  static $_TSPEC;

  /**
   * @var string
   */
  public $version = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'version',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['version'])) {
        $this->version = $vals['version'];
      }
    }
  }

  public function getName() {
    return 'TPingImpalaServiceResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->version);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TPingImpalaServiceResp');
    if ($this->version !== null) {
      $xfer += $output->writeFieldBegin('version', TType::STRING, 1);
      $xfer += $output->writeString($this->version);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TResetTableReq {
  static $_TSPEC;

  /**
   * @var string
   */
  public $db_name = null;
  /**
   * @var string
   */
  public $table_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'table_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['table_name'])) {
        $this->table_name = $vals['table_name'];
      }
    }
  }

  public function getName() {
    return 'TResetTableReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TResetTableReq');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_name !== null) {
      $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
      $xfer += $output->writeString($this->table_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetExecSummaryReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TOperationHandle
   */
  public $operationHandle = null;
  /**
   * @var \ThriftSQL\TSessionHandle
   */
  public $sessionHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TOperationHandle',
          ),
        2 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TSessionHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetExecSummaryReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new \ThriftSQL\TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new \ThriftSQL\TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetExecSummaryReq');
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 1);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 2);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetExecSummaryResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;
  /**
   * @var \ThriftSQL\TExecSummary
   */
  public $summary = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        2 => array(
          'var' => 'summary',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TExecSummary',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['summary'])) {
        $this->summary = $vals['summary'];
      }
    }
  }

  public function getName() {
    return 'TGetExecSummaryResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->summary = new \ThriftSQL\TExecSummary();
            $xfer += $this->summary->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetExecSummaryResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->summary !== null) {
      if (!is_object($this->summary)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('summary', TType::STRUCT, 2);
      $xfer += $this->summary->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetRuntimeProfileReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TOperationHandle
   */
  public $operationHandle = null;
  /**
   * @var \ThriftSQL\TSessionHandle
   */
  public $sessionHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TOperationHandle',
          ),
        2 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TSessionHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetRuntimeProfileReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new \ThriftSQL\TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new \ThriftSQL\TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetRuntimeProfileReq');
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 1);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 2);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetRuntimeProfileResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;
  /**
   * @var string
   */
  public $profile = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        2 => array(
          'var' => 'profile',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['profile'])) {
        $this->profile = $vals['profile'];
      }
    }
  }

  public function getName() {
    return 'TGetRuntimeProfileResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->profile);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetRuntimeProfileResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->profile !== null) {
      $xfer += $output->writeFieldBegin('profile', TType::STRING, 2);
      $xfer += $output->writeString($this->profile);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}
<?php
namespace ThriftSQL;
/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


interface TCLIServiceIf {
  /**
   * @param \ThriftSQL\TOpenSessionReq $req
   * @return \ThriftSQL\TOpenSessionResp
   */
  public function OpenSession(\ThriftSQL\TOpenSessionReq $req);
  /**
   * @param \ThriftSQL\TCloseSessionReq $req
   * @return \ThriftSQL\TCloseSessionResp
   */
  public function CloseSession(\ThriftSQL\TCloseSessionReq $req);
  /**
   * @param \ThriftSQL\TGetInfoReq $req
   * @return \ThriftSQL\TGetInfoResp
   */
  public function GetInfo(\ThriftSQL\TGetInfoReq $req);
  /**
   * @param \ThriftSQL\TExecuteStatementReq $req
   * @return \ThriftSQL\TExecuteStatementResp
   */
  public function ExecuteStatement(\ThriftSQL\TExecuteStatementReq $req);
  /**
   * @param \ThriftSQL\TGetTypeInfoReq $req
   * @return \ThriftSQL\TGetTypeInfoResp
   */
  public function GetTypeInfo(\ThriftSQL\TGetTypeInfoReq $req);
  /**
   * @param \ThriftSQL\TGetCatalogsReq $req
   * @return \ThriftSQL\TGetCatalogsResp
   */
  public function GetCatalogs(\ThriftSQL\TGetCatalogsReq $req);
  /**
   * @param \ThriftSQL\TGetSchemasReq $req
   * @return \ThriftSQL\TGetSchemasResp
   */
  public function GetSchemas(\ThriftSQL\TGetSchemasReq $req);
  /**
   * @param \ThriftSQL\TGetTablesReq $req
   * @return \ThriftSQL\TGetTablesResp
   */
  public function GetTables(\ThriftSQL\TGetTablesReq $req);
  /**
   * @param \ThriftSQL\TGetTableTypesReq $req
   * @return \ThriftSQL\TGetTableTypesResp
   */
  public function GetTableTypes(\ThriftSQL\TGetTableTypesReq $req);
  /**
   * @param \ThriftSQL\TGetColumnsReq $req
   * @return \ThriftSQL\TGetColumnsResp
   */
  public function GetColumns(\ThriftSQL\TGetColumnsReq $req);
  /**
   * @param \ThriftSQL\TGetFunctionsReq $req
   * @return \ThriftSQL\TGetFunctionsResp
   */
  public function GetFunctions(\ThriftSQL\TGetFunctionsReq $req);
  /**
   * @param \ThriftSQL\TGetOperationStatusReq $req
   * @return \ThriftSQL\TGetOperationStatusResp
   */
  public function GetOperationStatus(\ThriftSQL\TGetOperationStatusReq $req);
  /**
   * @param \ThriftSQL\TCancelOperationReq $req
   * @return \ThriftSQL\TCancelOperationResp
   */
  public function CancelOperation(\ThriftSQL\TCancelOperationReq $req);
  /**
   * @param \ThriftSQL\TCloseOperationReq $req
   * @return \ThriftSQL\TCloseOperationResp
   */
  public function CloseOperation(\ThriftSQL\TCloseOperationReq $req);
  /**
   * @param \ThriftSQL\TGetResultSetMetadataReq $req
   * @return \ThriftSQL\TGetResultSetMetadataResp
   */
  public function GetResultSetMetadata(\ThriftSQL\TGetResultSetMetadataReq $req);
  /**
   * @param \ThriftSQL\TFetchResultsReq $req
   * @return \ThriftSQL\TFetchResultsResp
   */
  public function FetchResults(\ThriftSQL\TFetchResultsReq $req);
  /**
   * @param \ThriftSQL\TGetDelegationTokenReq $req
   * @return \ThriftSQL\TGetDelegationTokenResp
   */
  public function GetDelegationToken(\ThriftSQL\TGetDelegationTokenReq $req);
  /**
   * @param \ThriftSQL\TCancelDelegationTokenReq $req
   * @return \ThriftSQL\TCancelDelegationTokenResp
   */
  public function CancelDelegationToken(\ThriftSQL\TCancelDelegationTokenReq $req);
  /**
   * @param \ThriftSQL\TRenewDelegationTokenReq $req
   * @return \ThriftSQL\TRenewDelegationTokenResp
   */
  public function RenewDelegationToken(\ThriftSQL\TRenewDelegationTokenReq $req);
}

class TCLIServiceClient implements \ThriftSQL\TCLIServiceIf {
  protected $input_ = null;
  protected $output_ = null;

  protected $seqid_ = 0;

  public function __construct($input, $output=null) {
    $this->input_ = $input;
    $this->output_ = $output ? $output : $input;
  }

  public function OpenSession(\ThriftSQL\TOpenSessionReq $req)
  {
    $this->send_OpenSession($req);
    return $this->recv_OpenSession();
  }

  public function send_OpenSession(\ThriftSQL\TOpenSessionReq $req)
  {
    $args = new \ThriftSQL\TCLIService_OpenSession_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'OpenSession', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('OpenSession', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_OpenSession()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\TCLIService_OpenSession_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\TCLIService_OpenSession_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("OpenSession failed: unknown result");
  }

  public function CloseSession(\ThriftSQL\TCloseSessionReq $req)
  {
    $this->send_CloseSession($req);
    return $this->recv_CloseSession();
  }

  public function send_CloseSession(\ThriftSQL\TCloseSessionReq $req)
  {
    $args = new \ThriftSQL\TCLIService_CloseSession_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'CloseSession', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('CloseSession', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_CloseSession()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\TCLIService_CloseSession_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\TCLIService_CloseSession_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("CloseSession failed: unknown result");
  }

  public function GetInfo(\ThriftSQL\TGetInfoReq $req)
  {
    $this->send_GetInfo($req);
    return $this->recv_GetInfo();
  }

  public function send_GetInfo(\ThriftSQL\TGetInfoReq $req)
  {
    $args = new \ThriftSQL\TCLIService_GetInfo_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'GetInfo', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('GetInfo', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_GetInfo()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\TCLIService_GetInfo_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\TCLIService_GetInfo_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("GetInfo failed: unknown result");
  }

  public function ExecuteStatement(\ThriftSQL\TExecuteStatementReq $req)
  {
    $this->send_ExecuteStatement($req);
    return $this->recv_ExecuteStatement();
  }

  public function send_ExecuteStatement(\ThriftSQL\TExecuteStatementReq $req)
  {
    $args = new \ThriftSQL\TCLIService_ExecuteStatement_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'ExecuteStatement', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('ExecuteStatement', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_ExecuteStatement()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\TCLIService_ExecuteStatement_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\TCLIService_ExecuteStatement_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("ExecuteStatement failed: unknown result");
  }

  public function GetTypeInfo(\ThriftSQL\TGetTypeInfoReq $req)
  {
    $this->send_GetTypeInfo($req);
    return $this->recv_GetTypeInfo();
  }

  public function send_GetTypeInfo(\ThriftSQL\TGetTypeInfoReq $req)
  {
    $args = new \ThriftSQL\TCLIService_GetTypeInfo_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'GetTypeInfo', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('GetTypeInfo', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_GetTypeInfo()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\TCLIService_GetTypeInfo_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\TCLIService_GetTypeInfo_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("GetTypeInfo failed: unknown result");
  }

  public function GetCatalogs(\ThriftSQL\TGetCatalogsReq $req)
  {
    $this->send_GetCatalogs($req);
    return $this->recv_GetCatalogs();
  }

  public function send_GetCatalogs(\ThriftSQL\TGetCatalogsReq $req)
  {
    $args = new \ThriftSQL\TCLIService_GetCatalogs_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'GetCatalogs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('GetCatalogs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_GetCatalogs()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\TCLIService_GetCatalogs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\TCLIService_GetCatalogs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("GetCatalogs failed: unknown result");
  }

  public function GetSchemas(\ThriftSQL\TGetSchemasReq $req)
  {
    $this->send_GetSchemas($req);
    return $this->recv_GetSchemas();
  }

  public function send_GetSchemas(\ThriftSQL\TGetSchemasReq $req)
  {
    $args = new \ThriftSQL\TCLIService_GetSchemas_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'GetSchemas', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('GetSchemas', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_GetSchemas()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\TCLIService_GetSchemas_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\TCLIService_GetSchemas_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("GetSchemas failed: unknown result");
  }

  public function GetTables(\ThriftSQL\TGetTablesReq $req)
  {
    $this->send_GetTables($req);
    return $this->recv_GetTables();
  }

  public function send_GetTables(\ThriftSQL\TGetTablesReq $req)
  {
    $args = new \ThriftSQL\TCLIService_GetTables_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'GetTables', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('GetTables', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_GetTables()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\TCLIService_GetTables_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\TCLIService_GetTables_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("GetTables failed: unknown result");
  }

  public function GetTableTypes(\ThriftSQL\TGetTableTypesReq $req)
  {
    $this->send_GetTableTypes($req);
    return $this->recv_GetTableTypes();
  }

  public function send_GetTableTypes(\ThriftSQL\TGetTableTypesReq $req)
  {
    $args = new \ThriftSQL\TCLIService_GetTableTypes_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'GetTableTypes', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('GetTableTypes', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_GetTableTypes()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\TCLIService_GetTableTypes_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\TCLIService_GetTableTypes_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("GetTableTypes failed: unknown result");
  }

  public function GetColumns(\ThriftSQL\TGetColumnsReq $req)
  {
    $this->send_GetColumns($req);
    return $this->recv_GetColumns();
  }

  public function send_GetColumns(\ThriftSQL\TGetColumnsReq $req)
  {
    $args = new \ThriftSQL\TCLIService_GetColumns_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'GetColumns', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('GetColumns', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_GetColumns()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\TCLIService_GetColumns_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\TCLIService_GetColumns_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("GetColumns failed: unknown result");
  }

  public function GetFunctions(\ThriftSQL\TGetFunctionsReq $req)
  {
    $this->send_GetFunctions($req);
    return $this->recv_GetFunctions();
  }

  public function send_GetFunctions(\ThriftSQL\TGetFunctionsReq $req)
  {
    $args = new \ThriftSQL\TCLIService_GetFunctions_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'GetFunctions', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('GetFunctions', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_GetFunctions()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\TCLIService_GetFunctions_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\TCLIService_GetFunctions_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("GetFunctions failed: unknown result");
  }

  public function GetOperationStatus(\ThriftSQL\TGetOperationStatusReq $req)
  {
    $this->send_GetOperationStatus($req);
    return $this->recv_GetOperationStatus();
  }

  public function send_GetOperationStatus(\ThriftSQL\TGetOperationStatusReq $req)
  {
    $args = new \ThriftSQL\TCLIService_GetOperationStatus_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'GetOperationStatus', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('GetOperationStatus', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_GetOperationStatus()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\TCLIService_GetOperationStatus_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\TCLIService_GetOperationStatus_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("GetOperationStatus failed: unknown result");
  }

  public function CancelOperation(\ThriftSQL\TCancelOperationReq $req)
  {
    $this->send_CancelOperation($req);
    return $this->recv_CancelOperation();
  }

  public function send_CancelOperation(\ThriftSQL\TCancelOperationReq $req)
  {
    $args = new \ThriftSQL\TCLIService_CancelOperation_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'CancelOperation', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('CancelOperation', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_CancelOperation()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\TCLIService_CancelOperation_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\TCLIService_CancelOperation_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("CancelOperation failed: unknown result");
  }

  public function CloseOperation(\ThriftSQL\TCloseOperationReq $req)
  {
    $this->send_CloseOperation($req);
    return $this->recv_CloseOperation();
  }

  public function send_CloseOperation(\ThriftSQL\TCloseOperationReq $req)
  {
    $args = new \ThriftSQL\TCLIService_CloseOperation_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'CloseOperation', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('CloseOperation', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_CloseOperation()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\TCLIService_CloseOperation_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\TCLIService_CloseOperation_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("CloseOperation failed: unknown result");
  }

  public function GetResultSetMetadata(\ThriftSQL\TGetResultSetMetadataReq $req)
  {
    $this->send_GetResultSetMetadata($req);
    return $this->recv_GetResultSetMetadata();
  }

  public function send_GetResultSetMetadata(\ThriftSQL\TGetResultSetMetadataReq $req)
  {
    $args = new \ThriftSQL\TCLIService_GetResultSetMetadata_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'GetResultSetMetadata', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('GetResultSetMetadata', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_GetResultSetMetadata()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\TCLIService_GetResultSetMetadata_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\TCLIService_GetResultSetMetadata_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("GetResultSetMetadata failed: unknown result");
  }

  public function FetchResults(\ThriftSQL\TFetchResultsReq $req)
  {
    $this->send_FetchResults($req);
    return $this->recv_FetchResults();
  }

  public function send_FetchResults(\ThriftSQL\TFetchResultsReq $req)
  {
    $args = new \ThriftSQL\TCLIService_FetchResults_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'FetchResults', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('FetchResults', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_FetchResults()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\TCLIService_FetchResults_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\TCLIService_FetchResults_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("FetchResults failed: unknown result");
  }

  public function GetDelegationToken(\ThriftSQL\TGetDelegationTokenReq $req)
  {
    $this->send_GetDelegationToken($req);
    return $this->recv_GetDelegationToken();
  }

  public function send_GetDelegationToken(\ThriftSQL\TGetDelegationTokenReq $req)
  {
    $args = new \ThriftSQL\TCLIService_GetDelegationToken_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'GetDelegationToken', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('GetDelegationToken', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_GetDelegationToken()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\TCLIService_GetDelegationToken_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\TCLIService_GetDelegationToken_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("GetDelegationToken failed: unknown result");
  }

  public function CancelDelegationToken(\ThriftSQL\TCancelDelegationTokenReq $req)
  {
    $this->send_CancelDelegationToken($req);
    return $this->recv_CancelDelegationToken();
  }

  public function send_CancelDelegationToken(\ThriftSQL\TCancelDelegationTokenReq $req)
  {
    $args = new \ThriftSQL\TCLIService_CancelDelegationToken_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'CancelDelegationToken', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('CancelDelegationToken', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_CancelDelegationToken()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\TCLIService_CancelDelegationToken_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\TCLIService_CancelDelegationToken_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("CancelDelegationToken failed: unknown result");
  }

  public function RenewDelegationToken(\ThriftSQL\TRenewDelegationTokenReq $req)
  {
    $this->send_RenewDelegationToken($req);
    return $this->recv_RenewDelegationToken();
  }

  public function send_RenewDelegationToken(\ThriftSQL\TRenewDelegationTokenReq $req)
  {
    $args = new \ThriftSQL\TCLIService_RenewDelegationToken_args();
    $args->req = $req;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'RenewDelegationToken', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('RenewDelegationToken', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_RenewDelegationToken()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ThriftSQL\TCLIService_RenewDelegationToken_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ThriftSQL\TCLIService_RenewDelegationToken_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("RenewDelegationToken failed: unknown result");
  }

}

// HELPER FUNCTIONS AND STRUCTURES

class TCLIService_OpenSession_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TOpenSessionReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TOpenSessionReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_OpenSession_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TOpenSessionReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_OpenSession_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_OpenSession_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TOpenSessionResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TOpenSessionResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_OpenSession_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TOpenSessionResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_OpenSession_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_CloseSession_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TCloseSessionReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TCloseSessionReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_CloseSession_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TCloseSessionReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_CloseSession_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_CloseSession_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TCloseSessionResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TCloseSessionResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_CloseSession_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TCloseSessionResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_CloseSession_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetInfo_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetInfoReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetInfoReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetInfo_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TGetInfoReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetInfo_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetInfo_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetInfoResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetInfoResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetInfo_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TGetInfoResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetInfo_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_ExecuteStatement_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TExecuteStatementReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TExecuteStatementReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_ExecuteStatement_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TExecuteStatementReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_ExecuteStatement_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_ExecuteStatement_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TExecuteStatementResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TExecuteStatementResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_ExecuteStatement_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TExecuteStatementResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_ExecuteStatement_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetTypeInfo_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetTypeInfoReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetTypeInfoReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetTypeInfo_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TGetTypeInfoReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetTypeInfo_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetTypeInfo_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetTypeInfoResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetTypeInfoResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetTypeInfo_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TGetTypeInfoResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetTypeInfo_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetCatalogs_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetCatalogsReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetCatalogsReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetCatalogs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TGetCatalogsReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetCatalogs_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetCatalogs_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetCatalogsResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetCatalogsResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetCatalogs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TGetCatalogsResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetCatalogs_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetSchemas_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetSchemasReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetSchemasReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetSchemas_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TGetSchemasReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetSchemas_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetSchemas_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetSchemasResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetSchemasResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetSchemas_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TGetSchemasResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetSchemas_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetTables_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetTablesReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetTablesReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetTables_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TGetTablesReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetTables_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetTables_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetTablesResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetTablesResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetTables_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TGetTablesResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetTables_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetTableTypes_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetTableTypesReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetTableTypesReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetTableTypes_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TGetTableTypesReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetTableTypes_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetTableTypes_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetTableTypesResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetTableTypesResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetTableTypes_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TGetTableTypesResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetTableTypes_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetColumns_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetColumnsReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetColumnsReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetColumns_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TGetColumnsReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetColumns_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetColumns_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetColumnsResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetColumnsResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetColumns_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TGetColumnsResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetColumns_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetFunctions_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetFunctionsReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetFunctionsReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetFunctions_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TGetFunctionsReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetFunctions_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetFunctions_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetFunctionsResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetFunctionsResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetFunctions_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TGetFunctionsResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetFunctions_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetOperationStatus_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetOperationStatusReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetOperationStatusReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetOperationStatus_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TGetOperationStatusReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetOperationStatus_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetOperationStatus_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetOperationStatusResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetOperationStatusResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetOperationStatus_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TGetOperationStatusResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetOperationStatus_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_CancelOperation_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TCancelOperationReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TCancelOperationReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_CancelOperation_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TCancelOperationReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_CancelOperation_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_CancelOperation_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TCancelOperationResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TCancelOperationResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_CancelOperation_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TCancelOperationResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_CancelOperation_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_CloseOperation_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TCloseOperationReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TCloseOperationReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_CloseOperation_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TCloseOperationReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_CloseOperation_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_CloseOperation_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TCloseOperationResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TCloseOperationResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_CloseOperation_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TCloseOperationResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_CloseOperation_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetResultSetMetadata_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetResultSetMetadataReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetResultSetMetadataReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetResultSetMetadata_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TGetResultSetMetadataReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetResultSetMetadata_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetResultSetMetadata_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetResultSetMetadataResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetResultSetMetadataResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetResultSetMetadata_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TGetResultSetMetadataResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetResultSetMetadata_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_FetchResults_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TFetchResultsReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TFetchResultsReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_FetchResults_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TFetchResultsReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_FetchResults_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_FetchResults_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TFetchResultsResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TFetchResultsResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_FetchResults_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TFetchResultsResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_FetchResults_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetDelegationToken_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetDelegationTokenReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetDelegationTokenReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetDelegationToken_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TGetDelegationTokenReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetDelegationToken_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_GetDelegationToken_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TGetDelegationTokenResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetDelegationTokenResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_GetDelegationToken_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TGetDelegationTokenResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_GetDelegationToken_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_CancelDelegationToken_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TCancelDelegationTokenReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TCancelDelegationTokenReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_CancelDelegationToken_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TCancelDelegationTokenReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_CancelDelegationToken_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_CancelDelegationToken_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TCancelDelegationTokenResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TCancelDelegationTokenResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_CancelDelegationToken_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TCancelDelegationTokenResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_CancelDelegationToken_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_RenewDelegationToken_args {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TRenewDelegationTokenReq
   */
  public $req = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'req',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TRenewDelegationTokenReq',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['req'])) {
        $this->req = $vals['req'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_RenewDelegationToken_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->req = new \ThriftSQL\TRenewDelegationTokenReq();
            $xfer += $this->req->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_RenewDelegationToken_args');
    if ($this->req !== null) {
      if (!is_object($this->req)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
      $xfer += $this->req->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCLIService_RenewDelegationToken_result {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TRenewDelegationTokenResp
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TRenewDelegationTokenResp',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'TCLIService_RenewDelegationToken_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ThriftSQL\TRenewDelegationTokenResp();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCLIService_RenewDelegationToken_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}
<?php
namespace ThriftSQL;
/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


final class TProtocolVersion {
  const HIVE_CLI_SERVICE_PROTOCOL_V1 = 0;
  const HIVE_CLI_SERVICE_PROTOCOL_V2 = 1;
  const HIVE_CLI_SERVICE_PROTOCOL_V3 = 2;
  const HIVE_CLI_SERVICE_PROTOCOL_V4 = 3;
  const HIVE_CLI_SERVICE_PROTOCOL_V5 = 4;
  const HIVE_CLI_SERVICE_PROTOCOL_V6 = 5;
  const HIVE_CLI_SERVICE_PROTOCOL_V7 = 6;
  static public $__names = array(
    0 => 'HIVE_CLI_SERVICE_PROTOCOL_V1',
    1 => 'HIVE_CLI_SERVICE_PROTOCOL_V2',
    2 => 'HIVE_CLI_SERVICE_PROTOCOL_V3',
    3 => 'HIVE_CLI_SERVICE_PROTOCOL_V4',
    4 => 'HIVE_CLI_SERVICE_PROTOCOL_V5',
    5 => 'HIVE_CLI_SERVICE_PROTOCOL_V6',
    6 => 'HIVE_CLI_SERVICE_PROTOCOL_V7',
  );
}

final class TTypeId {
  const BOOLEAN_TYPE = 0;
  const TINYINT_TYPE = 1;
  const SMALLINT_TYPE = 2;
  const INT_TYPE = 3;
  const BIGINT_TYPE = 4;
  const FLOAT_TYPE = 5;
  const DOUBLE_TYPE = 6;
  const STRING_TYPE = 7;
  const TIMESTAMP_TYPE = 8;
  const BINARY_TYPE = 9;
  const ARRAY_TYPE = 10;
  const MAP_TYPE = 11;
  const STRUCT_TYPE = 12;
  const UNION_TYPE = 13;
  const USER_DEFINED_TYPE = 14;
  const DECIMAL_TYPE = 15;
  const NULL_TYPE = 16;
  const DATE_TYPE = 17;
  const VARCHAR_TYPE = 18;
  const CHAR_TYPE = 19;
  static public $__names = array(
    0 => 'BOOLEAN_TYPE',
    1 => 'TINYINT_TYPE',
    2 => 'SMALLINT_TYPE',
    3 => 'INT_TYPE',
    4 => 'BIGINT_TYPE',
    5 => 'FLOAT_TYPE',
    6 => 'DOUBLE_TYPE',
    7 => 'STRING_TYPE',
    8 => 'TIMESTAMP_TYPE',
    9 => 'BINARY_TYPE',
    10 => 'ARRAY_TYPE',
    11 => 'MAP_TYPE',
    12 => 'STRUCT_TYPE',
    13 => 'UNION_TYPE',
    14 => 'USER_DEFINED_TYPE',
    15 => 'DECIMAL_TYPE',
    16 => 'NULL_TYPE',
    17 => 'DATE_TYPE',
    18 => 'VARCHAR_TYPE',
    19 => 'CHAR_TYPE',
  );
}

final class TStatusCode {
  const SUCCESS_STATUS = 0;
  const SUCCESS_WITH_INFO_STATUS = 1;
  const STILL_EXECUTING_STATUS = 2;
  const ERROR_STATUS = 3;
  const INVALID_HANDLE_STATUS = 4;
  static public $__names = array(
    0 => 'SUCCESS_STATUS',
    1 => 'SUCCESS_WITH_INFO_STATUS',
    2 => 'STILL_EXECUTING_STATUS',
    3 => 'ERROR_STATUS',
    4 => 'INVALID_HANDLE_STATUS',
  );
}

final class TOperationState {
  const INITIALIZED_STATE = 0;
  const RUNNING_STATE = 1;
  const FINISHED_STATE = 2;
  const CANCELED_STATE = 3;
  const CLOSED_STATE = 4;
  const ERROR_STATE = 5;
  const UKNOWN_STATE = 6;
  const PENDING_STATE = 7;
  static public $__names = array(
    0 => 'INITIALIZED_STATE',
    1 => 'RUNNING_STATE',
    2 => 'FINISHED_STATE',
    3 => 'CANCELED_STATE',
    4 => 'CLOSED_STATE',
    5 => 'ERROR_STATE',
    6 => 'UKNOWN_STATE',
    7 => 'PENDING_STATE',
  );
}

final class TOperationType {
  const EXECUTE_STATEMENT = 0;
  const GET_TYPE_INFO = 1;
  const GET_CATALOGS = 2;
  const GET_SCHEMAS = 3;
  const GET_TABLES = 4;
  const GET_TABLE_TYPES = 5;
  const GET_COLUMNS = 6;
  const GET_FUNCTIONS = 7;
  const UNKNOWN = 8;
  static public $__names = array(
    0 => 'EXECUTE_STATEMENT',
    1 => 'GET_TYPE_INFO',
    2 => 'GET_CATALOGS',
    3 => 'GET_SCHEMAS',
    4 => 'GET_TABLES',
    5 => 'GET_TABLE_TYPES',
    6 => 'GET_COLUMNS',
    7 => 'GET_FUNCTIONS',
    8 => 'UNKNOWN',
  );
}

final class TGetInfoType {
  const CLI_MAX_DRIVER_CONNECTIONS = 0;
  const CLI_MAX_CONCURRENT_ACTIVITIES = 1;
  const CLI_DATA_SOURCE_NAME = 2;
  const CLI_FETCH_DIRECTION = 8;
  const CLI_SERVER_NAME = 13;
  const CLI_SEARCH_PATTERN_ESCAPE = 14;
  const CLI_DBMS_NAME = 17;
  const CLI_DBMS_VER = 18;
  const CLI_ACCESSIBLE_TABLES = 19;
  const CLI_ACCESSIBLE_PROCEDURES = 20;
  const CLI_CURSOR_COMMIT_BEHAVIOR = 23;
  const CLI_DATA_SOURCE_READ_ONLY = 25;
  const CLI_DEFAULT_TXN_ISOLATION = 26;
  const CLI_IDENTIFIER_CASE = 28;
  const CLI_IDENTIFIER_QUOTE_CHAR = 29;
  const CLI_MAX_COLUMN_NAME_LEN = 30;
  const CLI_MAX_CURSOR_NAME_LEN = 31;
  const CLI_MAX_SCHEMA_NAME_LEN = 32;
  const CLI_MAX_CATALOG_NAME_LEN = 34;
  const CLI_MAX_TABLE_NAME_LEN = 35;
  const CLI_SCROLL_CONCURRENCY = 43;
  const CLI_TXN_CAPABLE = 46;
  const CLI_USER_NAME = 47;
  const CLI_TXN_ISOLATION_OPTION = 72;
  const CLI_INTEGRITY = 73;
  const CLI_GETDATA_EXTENSIONS = 81;
  const CLI_NULL_COLLATION = 85;
  const CLI_ALTER_TABLE = 86;
  const CLI_ORDER_BY_COLUMNS_IN_SELECT = 90;
  const CLI_SPECIAL_CHARACTERS = 94;
  const CLI_MAX_COLUMNS_IN_GROUP_BY = 97;
  const CLI_MAX_COLUMNS_IN_INDEX = 98;
  const CLI_MAX_COLUMNS_IN_ORDER_BY = 99;
  const CLI_MAX_COLUMNS_IN_SELECT = 100;
  const CLI_MAX_COLUMNS_IN_TABLE = 101;
  const CLI_MAX_INDEX_SIZE = 102;
  const CLI_MAX_ROW_SIZE = 104;
  const CLI_MAX_STATEMENT_LEN = 105;
  const CLI_MAX_TABLES_IN_SELECT = 106;
  const CLI_MAX_USER_NAME_LEN = 107;
  const CLI_OJ_CAPABILITIES = 115;
  const CLI_XOPEN_CLI_YEAR = 10000;
  const CLI_CURSOR_SENSITIVITY = 10001;
  const CLI_DESCRIBE_PARAMETER = 10002;
  const CLI_CATALOG_NAME = 10003;
  const CLI_COLLATION_SEQ = 10004;
  const CLI_MAX_IDENTIFIER_LEN = 10005;
  static public $__names = array(
    0 => 'CLI_MAX_DRIVER_CONNECTIONS',
    1 => 'CLI_MAX_CONCURRENT_ACTIVITIES',
    2 => 'CLI_DATA_SOURCE_NAME',
    8 => 'CLI_FETCH_DIRECTION',
    13 => 'CLI_SERVER_NAME',
    14 => 'CLI_SEARCH_PATTERN_ESCAPE',
    17 => 'CLI_DBMS_NAME',
    18 => 'CLI_DBMS_VER',
    19 => 'CLI_ACCESSIBLE_TABLES',
    20 => 'CLI_ACCESSIBLE_PROCEDURES',
    23 => 'CLI_CURSOR_COMMIT_BEHAVIOR',
    25 => 'CLI_DATA_SOURCE_READ_ONLY',
    26 => 'CLI_DEFAULT_TXN_ISOLATION',
    28 => 'CLI_IDENTIFIER_CASE',
    29 => 'CLI_IDENTIFIER_QUOTE_CHAR',
    30 => 'CLI_MAX_COLUMN_NAME_LEN',
    31 => 'CLI_MAX_CURSOR_NAME_LEN',
    32 => 'CLI_MAX_SCHEMA_NAME_LEN',
    34 => 'CLI_MAX_CATALOG_NAME_LEN',
    35 => 'CLI_MAX_TABLE_NAME_LEN',
    43 => 'CLI_SCROLL_CONCURRENCY',
    46 => 'CLI_TXN_CAPABLE',
    47 => 'CLI_USER_NAME',
    72 => 'CLI_TXN_ISOLATION_OPTION',
    73 => 'CLI_INTEGRITY',
    81 => 'CLI_GETDATA_EXTENSIONS',
    85 => 'CLI_NULL_COLLATION',
    86 => 'CLI_ALTER_TABLE',
    90 => 'CLI_ORDER_BY_COLUMNS_IN_SELECT',
    94 => 'CLI_SPECIAL_CHARACTERS',
    97 => 'CLI_MAX_COLUMNS_IN_GROUP_BY',
    98 => 'CLI_MAX_COLUMNS_IN_INDEX',
    99 => 'CLI_MAX_COLUMNS_IN_ORDER_BY',
    100 => 'CLI_MAX_COLUMNS_IN_SELECT',
    101 => 'CLI_MAX_COLUMNS_IN_TABLE',
    102 => 'CLI_MAX_INDEX_SIZE',
    104 => 'CLI_MAX_ROW_SIZE',
    105 => 'CLI_MAX_STATEMENT_LEN',
    106 => 'CLI_MAX_TABLES_IN_SELECT',
    107 => 'CLI_MAX_USER_NAME_LEN',
    115 => 'CLI_OJ_CAPABILITIES',
    10000 => 'CLI_XOPEN_CLI_YEAR',
    10001 => 'CLI_CURSOR_SENSITIVITY',
    10002 => 'CLI_DESCRIBE_PARAMETER',
    10003 => 'CLI_CATALOG_NAME',
    10004 => 'CLI_COLLATION_SEQ',
    10005 => 'CLI_MAX_IDENTIFIER_LEN',
  );
}

final class TFetchOrientation {
  const FETCH_NEXT = 0;
  const FETCH_PRIOR = 1;
  const FETCH_RELATIVE = 2;
  const FETCH_ABSOLUTE = 3;
  const FETCH_FIRST = 4;
  const FETCH_LAST = 5;
  static public $__names = array(
    0 => 'FETCH_NEXT',
    1 => 'FETCH_PRIOR',
    2 => 'FETCH_RELATIVE',
    3 => 'FETCH_ABSOLUTE',
    4 => 'FETCH_FIRST',
    5 => 'FETCH_LAST',
  );
}

class TTypeQualifierValue {
  static $_TSPEC;

  /**
   * @var int
   */
  public $i32Value = null;
  /**
   * @var string
   */
  public $stringValue = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'i32Value',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'stringValue',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['i32Value'])) {
        $this->i32Value = $vals['i32Value'];
      }
      if (isset($vals['stringValue'])) {
        $this->stringValue = $vals['stringValue'];
      }
    }
  }

  public function getName() {
    return 'TTypeQualifierValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->i32Value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stringValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TTypeQualifierValue');
    if ($this->i32Value !== null) {
      $xfer += $output->writeFieldBegin('i32Value', TType::I32, 1);
      $xfer += $output->writeI32($this->i32Value);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stringValue !== null) {
      $xfer += $output->writeFieldBegin('stringValue', TType::STRING, 2);
      $xfer += $output->writeString($this->stringValue);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TTypeQualifiers {
  static $_TSPEC;

  /**
   * @var array
   */
  public $qualifiers = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'qualifiers',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\ThriftSQL\TTypeQualifierValue',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['qualifiers'])) {
        $this->qualifiers = $vals['qualifiers'];
      }
    }
  }

  public function getName() {
    return 'TTypeQualifiers';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->qualifiers = array();
            $_size0 = 0;
            $_ktype1 = 0;
            $_vtype2 = 0;
            $xfer += $input->readMapBegin($_ktype1, $_vtype2, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $key5 = '';
              $val6 = new \ThriftSQL\TTypeQualifierValue();
              $xfer += $input->readString($key5);
              $val6 = new \ThriftSQL\TTypeQualifierValue();
              $xfer += $val6->read($input);
              $this->qualifiers[$key5] = $val6;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TTypeQualifiers');
    if ($this->qualifiers !== null) {
      if (!is_array($this->qualifiers)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('qualifiers', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->qualifiers));
        {
          foreach ($this->qualifiers as $kiter7 => $viter8)
          {
            $xfer += $output->writeString($kiter7);
            $xfer += $viter8->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TPrimitiveTypeEntry {
  static $_TSPEC;

  /**
   * @var int
   */
  public $type = null;
  /**
   * @var \ThriftSQL\TTypeQualifiers
   */
  public $typeQualifiers = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'typeQualifiers',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TTypeQualifiers',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['typeQualifiers'])) {
        $this->typeQualifiers = $vals['typeQualifiers'];
      }
    }
  }

  public function getName() {
    return 'TPrimitiveTypeEntry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->typeQualifiers = new \ThriftSQL\TTypeQualifiers();
            $xfer += $this->typeQualifiers->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TPrimitiveTypeEntry');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 1);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->typeQualifiers !== null) {
      if (!is_object($this->typeQualifiers)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('typeQualifiers', TType::STRUCT, 2);
      $xfer += $this->typeQualifiers->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TArrayTypeEntry {
  static $_TSPEC;

  /**
   * @var int
   */
  public $objectTypePtr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'objectTypePtr',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['objectTypePtr'])) {
        $this->objectTypePtr = $vals['objectTypePtr'];
      }
    }
  }

  public function getName() {
    return 'TArrayTypeEntry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->objectTypePtr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TArrayTypeEntry');
    if ($this->objectTypePtr !== null) {
      $xfer += $output->writeFieldBegin('objectTypePtr', TType::I32, 1);
      $xfer += $output->writeI32($this->objectTypePtr);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TMapTypeEntry {
  static $_TSPEC;

  /**
   * @var int
   */
  public $keyTypePtr = null;
  /**
   * @var int
   */
  public $valueTypePtr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keyTypePtr',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'valueTypePtr',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keyTypePtr'])) {
        $this->keyTypePtr = $vals['keyTypePtr'];
      }
      if (isset($vals['valueTypePtr'])) {
        $this->valueTypePtr = $vals['valueTypePtr'];
      }
    }
  }

  public function getName() {
    return 'TMapTypeEntry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->keyTypePtr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->valueTypePtr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TMapTypeEntry');
    if ($this->keyTypePtr !== null) {
      $xfer += $output->writeFieldBegin('keyTypePtr', TType::I32, 1);
      $xfer += $output->writeI32($this->keyTypePtr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->valueTypePtr !== null) {
      $xfer += $output->writeFieldBegin('valueTypePtr', TType::I32, 2);
      $xfer += $output->writeI32($this->valueTypePtr);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TStructTypeEntry {
  static $_TSPEC;

  /**
   * @var array
   */
  public $nameToTypePtr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'nameToTypePtr',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['nameToTypePtr'])) {
        $this->nameToTypePtr = $vals['nameToTypePtr'];
      }
    }
  }

  public function getName() {
    return 'TStructTypeEntry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->nameToTypePtr = array();
            $_size9 = 0;
            $_ktype10 = 0;
            $_vtype11 = 0;
            $xfer += $input->readMapBegin($_ktype10, $_vtype11, $_size9);
            for ($_i13 = 0; $_i13 < $_size9; ++$_i13)
            {
              $key14 = '';
              $val15 = 0;
              $xfer += $input->readString($key14);
              $xfer += $input->readI32($val15);
              $this->nameToTypePtr[$key14] = $val15;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TStructTypeEntry');
    if ($this->nameToTypePtr !== null) {
      if (!is_array($this->nameToTypePtr)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('nameToTypePtr', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::I32, count($this->nameToTypePtr));
        {
          foreach ($this->nameToTypePtr as $kiter16 => $viter17)
          {
            $xfer += $output->writeString($kiter16);
            $xfer += $output->writeI32($viter17);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TUnionTypeEntry {
  static $_TSPEC;

  /**
   * @var array
   */
  public $nameToTypePtr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'nameToTypePtr',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['nameToTypePtr'])) {
        $this->nameToTypePtr = $vals['nameToTypePtr'];
      }
    }
  }

  public function getName() {
    return 'TUnionTypeEntry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->nameToTypePtr = array();
            $_size18 = 0;
            $_ktype19 = 0;
            $_vtype20 = 0;
            $xfer += $input->readMapBegin($_ktype19, $_vtype20, $_size18);
            for ($_i22 = 0; $_i22 < $_size18; ++$_i22)
            {
              $key23 = '';
              $val24 = 0;
              $xfer += $input->readString($key23);
              $xfer += $input->readI32($val24);
              $this->nameToTypePtr[$key23] = $val24;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TUnionTypeEntry');
    if ($this->nameToTypePtr !== null) {
      if (!is_array($this->nameToTypePtr)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('nameToTypePtr', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::I32, count($this->nameToTypePtr));
        {
          foreach ($this->nameToTypePtr as $kiter25 => $viter26)
          {
            $xfer += $output->writeString($kiter25);
            $xfer += $output->writeI32($viter26);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TUserDefinedTypeEntry {
  static $_TSPEC;

  /**
   * @var string
   */
  public $typeClassName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'typeClassName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['typeClassName'])) {
        $this->typeClassName = $vals['typeClassName'];
      }
    }
  }

  public function getName() {
    return 'TUserDefinedTypeEntry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->typeClassName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TUserDefinedTypeEntry');
    if ($this->typeClassName !== null) {
      $xfer += $output->writeFieldBegin('typeClassName', TType::STRING, 1);
      $xfer += $output->writeString($this->typeClassName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TTypeEntry {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TPrimitiveTypeEntry
   */
  public $primitiveEntry = null;
  /**
   * @var \ThriftSQL\TArrayTypeEntry
   */
  public $arrayEntry = null;
  /**
   * @var \ThriftSQL\TMapTypeEntry
   */
  public $mapEntry = null;
  /**
   * @var \ThriftSQL\TStructTypeEntry
   */
  public $structEntry = null;
  /**
   * @var \ThriftSQL\TUnionTypeEntry
   */
  public $unionEntry = null;
  /**
   * @var \ThriftSQL\TUserDefinedTypeEntry
   */
  public $userDefinedTypeEntry = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'primitiveEntry',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TPrimitiveTypeEntry',
          ),
        2 => array(
          'var' => 'arrayEntry',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TArrayTypeEntry',
          ),
        3 => array(
          'var' => 'mapEntry',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TMapTypeEntry',
          ),
        4 => array(
          'var' => 'structEntry',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStructTypeEntry',
          ),
        5 => array(
          'var' => 'unionEntry',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TUnionTypeEntry',
          ),
        6 => array(
          'var' => 'userDefinedTypeEntry',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TUserDefinedTypeEntry',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['primitiveEntry'])) {
        $this->primitiveEntry = $vals['primitiveEntry'];
      }
      if (isset($vals['arrayEntry'])) {
        $this->arrayEntry = $vals['arrayEntry'];
      }
      if (isset($vals['mapEntry'])) {
        $this->mapEntry = $vals['mapEntry'];
      }
      if (isset($vals['structEntry'])) {
        $this->structEntry = $vals['structEntry'];
      }
      if (isset($vals['unionEntry'])) {
        $this->unionEntry = $vals['unionEntry'];
      }
      if (isset($vals['userDefinedTypeEntry'])) {
        $this->userDefinedTypeEntry = $vals['userDefinedTypeEntry'];
      }
    }
  }

  public function getName() {
    return 'TTypeEntry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->primitiveEntry = new \ThriftSQL\TPrimitiveTypeEntry();
            $xfer += $this->primitiveEntry->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->arrayEntry = new \ThriftSQL\TArrayTypeEntry();
            $xfer += $this->arrayEntry->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->mapEntry = new \ThriftSQL\TMapTypeEntry();
            $xfer += $this->mapEntry->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->structEntry = new \ThriftSQL\TStructTypeEntry();
            $xfer += $this->structEntry->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->unionEntry = new \ThriftSQL\TUnionTypeEntry();
            $xfer += $this->unionEntry->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->userDefinedTypeEntry = new \ThriftSQL\TUserDefinedTypeEntry();
            $xfer += $this->userDefinedTypeEntry->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TTypeEntry');
    if ($this->primitiveEntry !== null) {
      if (!is_object($this->primitiveEntry)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('primitiveEntry', TType::STRUCT, 1);
      $xfer += $this->primitiveEntry->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->arrayEntry !== null) {
      if (!is_object($this->arrayEntry)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('arrayEntry', TType::STRUCT, 2);
      $xfer += $this->arrayEntry->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mapEntry !== null) {
      if (!is_object($this->mapEntry)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('mapEntry', TType::STRUCT, 3);
      $xfer += $this->mapEntry->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->structEntry !== null) {
      if (!is_object($this->structEntry)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('structEntry', TType::STRUCT, 4);
      $xfer += $this->structEntry->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->unionEntry !== null) {
      if (!is_object($this->unionEntry)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('unionEntry', TType::STRUCT, 5);
      $xfer += $this->unionEntry->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->userDefinedTypeEntry !== null) {
      if (!is_object($this->userDefinedTypeEntry)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('userDefinedTypeEntry', TType::STRUCT, 6);
      $xfer += $this->userDefinedTypeEntry->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TTypeDesc {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TTypeEntry[]
   */
  public $types = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'types',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ThriftSQL\TTypeEntry',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['types'])) {
        $this->types = $vals['types'];
      }
    }
  }

  public function getName() {
    return 'TTypeDesc';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->types = array();
            $_size27 = 0;
            $_etype30 = 0;
            $xfer += $input->readListBegin($_etype30, $_size27);
            for ($_i31 = 0; $_i31 < $_size27; ++$_i31)
            {
              $elem32 = null;
              $elem32 = new \ThriftSQL\TTypeEntry();
              $xfer += $elem32->read($input);
              $this->types []= $elem32;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TTypeDesc');
    if ($this->types !== null) {
      if (!is_array($this->types)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('types', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->types));
        {
          foreach ($this->types as $iter33)
          {
            $xfer += $iter33->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TColumnDesc {
  static $_TSPEC;

  /**
   * @var string
   */
  public $columnName = null;
  /**
   * @var \ThriftSQL\TTypeDesc
   */
  public $typeDesc = null;
  /**
   * @var int
   */
  public $position = null;
  /**
   * @var string
   */
  public $comment = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'columnName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'typeDesc',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TTypeDesc',
          ),
        3 => array(
          'var' => 'position',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'comment',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['columnName'])) {
        $this->columnName = $vals['columnName'];
      }
      if (isset($vals['typeDesc'])) {
        $this->typeDesc = $vals['typeDesc'];
      }
      if (isset($vals['position'])) {
        $this->position = $vals['position'];
      }
      if (isset($vals['comment'])) {
        $this->comment = $vals['comment'];
      }
    }
  }

  public function getName() {
    return 'TColumnDesc';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->columnName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->typeDesc = new \ThriftSQL\TTypeDesc();
            $xfer += $this->typeDesc->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->position);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->comment);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TColumnDesc');
    if ($this->columnName !== null) {
      $xfer += $output->writeFieldBegin('columnName', TType::STRING, 1);
      $xfer += $output->writeString($this->columnName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->typeDesc !== null) {
      if (!is_object($this->typeDesc)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('typeDesc', TType::STRUCT, 2);
      $xfer += $this->typeDesc->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->position !== null) {
      $xfer += $output->writeFieldBegin('position', TType::I32, 3);
      $xfer += $output->writeI32($this->position);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->comment !== null) {
      $xfer += $output->writeFieldBegin('comment', TType::STRING, 4);
      $xfer += $output->writeString($this->comment);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TTableSchema {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TColumnDesc[]
   */
  public $columns = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ThriftSQL\TColumnDesc',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
    }
  }

  public function getName() {
    return 'TTableSchema';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size34 = 0;
            $_etype37 = 0;
            $xfer += $input->readListBegin($_etype37, $_size34);
            for ($_i38 = 0; $_i38 < $_size34; ++$_i38)
            {
              $elem39 = null;
              $elem39 = new \ThriftSQL\TColumnDesc();
              $xfer += $elem39->read($input);
              $this->columns []= $elem39;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TTableSchema');
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->columns));
        {
          foreach ($this->columns as $iter40)
          {
            $xfer += $iter40->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TBoolValue {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TBoolValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TBoolValue');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::BOOL, 1);
      $xfer += $output->writeBool($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TByteValue {
  static $_TSPEC;

  /**
   * @var int
   */
  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::BYTE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TByteValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TByteValue');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::BYTE, 1);
      $xfer += $output->writeByte($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TI16Value {
  static $_TSPEC;

  /**
   * @var int
   */
  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TI16Value';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TI16Value');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::I16, 1);
      $xfer += $output->writeI16($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TI32Value {
  static $_TSPEC;

  /**
   * @var int
   */
  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TI32Value';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TI32Value');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::I32, 1);
      $xfer += $output->writeI32($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TI64Value {
  static $_TSPEC;

  /**
   * @var int
   */
  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TI64Value';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TI64Value');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::I64, 1);
      $xfer += $output->writeI64($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TDoubleValue {
  static $_TSPEC;

  /**
   * @var double
   */
  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TDoubleValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TDoubleValue');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::DOUBLE, 1);
      $xfer += $output->writeDouble($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TStringValue {
  static $_TSPEC;

  /**
   * @var string
   */
  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TStringValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TStringValue');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 1);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TColumnValue {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TBoolValue
   */
  public $boolVal = null;
  /**
   * @var \ThriftSQL\TByteValue
   */
  public $byteVal = null;
  /**
   * @var \ThriftSQL\TI16Value
   */
  public $i16Val = null;
  /**
   * @var \ThriftSQL\TI32Value
   */
  public $i32Val = null;
  /**
   * @var \ThriftSQL\TI64Value
   */
  public $i64Val = null;
  /**
   * @var \ThriftSQL\TDoubleValue
   */
  public $doubleVal = null;
  /**
   * @var \ThriftSQL\TStringValue
   */
  public $stringVal = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'boolVal',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TBoolValue',
          ),
        2 => array(
          'var' => 'byteVal',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TByteValue',
          ),
        3 => array(
          'var' => 'i16Val',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TI16Value',
          ),
        4 => array(
          'var' => 'i32Val',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TI32Value',
          ),
        5 => array(
          'var' => 'i64Val',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TI64Value',
          ),
        6 => array(
          'var' => 'doubleVal',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TDoubleValue',
          ),
        7 => array(
          'var' => 'stringVal',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStringValue',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['boolVal'])) {
        $this->boolVal = $vals['boolVal'];
      }
      if (isset($vals['byteVal'])) {
        $this->byteVal = $vals['byteVal'];
      }
      if (isset($vals['i16Val'])) {
        $this->i16Val = $vals['i16Val'];
      }
      if (isset($vals['i32Val'])) {
        $this->i32Val = $vals['i32Val'];
      }
      if (isset($vals['i64Val'])) {
        $this->i64Val = $vals['i64Val'];
      }
      if (isset($vals['doubleVal'])) {
        $this->doubleVal = $vals['doubleVal'];
      }
      if (isset($vals['stringVal'])) {
        $this->stringVal = $vals['stringVal'];
      }
    }
  }

  public function getName() {
    return 'TColumnValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->boolVal = new \ThriftSQL\TBoolValue();
            $xfer += $this->boolVal->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->byteVal = new \ThriftSQL\TByteValue();
            $xfer += $this->byteVal->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->i16Val = new \ThriftSQL\TI16Value();
            $xfer += $this->i16Val->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->i32Val = new \ThriftSQL\TI32Value();
            $xfer += $this->i32Val->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->i64Val = new \ThriftSQL\TI64Value();
            $xfer += $this->i64Val->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->doubleVal = new \ThriftSQL\TDoubleValue();
            $xfer += $this->doubleVal->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->stringVal = new \ThriftSQL\TStringValue();
            $xfer += $this->stringVal->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TColumnValue');
    if ($this->boolVal !== null) {
      if (!is_object($this->boolVal)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('boolVal', TType::STRUCT, 1);
      $xfer += $this->boolVal->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->byteVal !== null) {
      if (!is_object($this->byteVal)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('byteVal', TType::STRUCT, 2);
      $xfer += $this->byteVal->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i16Val !== null) {
      if (!is_object($this->i16Val)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('i16Val', TType::STRUCT, 3);
      $xfer += $this->i16Val->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i32Val !== null) {
      if (!is_object($this->i32Val)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('i32Val', TType::STRUCT, 4);
      $xfer += $this->i32Val->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i64Val !== null) {
      if (!is_object($this->i64Val)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('i64Val', TType::STRUCT, 5);
      $xfer += $this->i64Val->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->doubleVal !== null) {
      if (!is_object($this->doubleVal)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('doubleVal', TType::STRUCT, 6);
      $xfer += $this->doubleVal->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stringVal !== null) {
      if (!is_object($this->stringVal)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('stringVal', TType::STRUCT, 7);
      $xfer += $this->stringVal->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TRow {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TColumnValue[]
   */
  public $colVals = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'colVals',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ThriftSQL\TColumnValue',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['colVals'])) {
        $this->colVals = $vals['colVals'];
      }
    }
  }

  public function getName() {
    return 'TRow';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->colVals = array();
            $_size41 = 0;
            $_etype44 = 0;
            $xfer += $input->readListBegin($_etype44, $_size41);
            for ($_i45 = 0; $_i45 < $_size41; ++$_i45)
            {
              $elem46 = null;
              $elem46 = new \ThriftSQL\TColumnValue();
              $xfer += $elem46->read($input);
              $this->colVals []= $elem46;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TRow');
    if ($this->colVals !== null) {
      if (!is_array($this->colVals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('colVals', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->colVals));
        {
          foreach ($this->colVals as $iter47)
          {
            $xfer += $iter47->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TBoolColumn {
  static $_TSPEC;

  /**
   * @var bool[]
   */
  public $values = null;
  /**
   * @var string
   */
  public $nulls = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::BOOL,
          'elem' => array(
            'type' => TType::BOOL,
            ),
          ),
        2 => array(
          'var' => 'nulls',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
      if (isset($vals['nulls'])) {
        $this->nulls = $vals['nulls'];
      }
    }
  }

  public function getName() {
    return 'TBoolColumn';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size48 = 0;
            $_etype51 = 0;
            $xfer += $input->readListBegin($_etype51, $_size48);
            for ($_i52 = 0; $_i52 < $_size48; ++$_i52)
            {
              $elem53 = null;
              $xfer += $input->readBool($elem53);
              $this->values []= $elem53;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->nulls);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TBoolColumn');
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 1);
      {
        $output->writeListBegin(TType::BOOL, count($this->values));
        {
          foreach ($this->values as $iter54)
          {
            $xfer += $output->writeBool($iter54);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nulls !== null) {
      $xfer += $output->writeFieldBegin('nulls', TType::STRING, 2);
      $xfer += $output->writeString($this->nulls);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TByteColumn {
  static $_TSPEC;

  /**
   * @var int[]
   */
  public $values = null;
  /**
   * @var string
   */
  public $nulls = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::BYTE,
          'elem' => array(
            'type' => TType::BYTE,
            ),
          ),
        2 => array(
          'var' => 'nulls',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
      if (isset($vals['nulls'])) {
        $this->nulls = $vals['nulls'];
      }
    }
  }

  public function getName() {
    return 'TByteColumn';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size55 = 0;
            $_etype58 = 0;
            $xfer += $input->readListBegin($_etype58, $_size55);
            for ($_i59 = 0; $_i59 < $_size55; ++$_i59)
            {
              $elem60 = null;
              $xfer += $input->readByte($elem60);
              $this->values []= $elem60;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->nulls);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TByteColumn');
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 1);
      {
        $output->writeListBegin(TType::BYTE, count($this->values));
        {
          foreach ($this->values as $iter61)
          {
            $xfer += $output->writeByte($iter61);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nulls !== null) {
      $xfer += $output->writeFieldBegin('nulls', TType::STRING, 2);
      $xfer += $output->writeString($this->nulls);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TI16Column {
  static $_TSPEC;

  /**
   * @var int[]
   */
  public $values = null;
  /**
   * @var string
   */
  public $nulls = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::I16,
          'elem' => array(
            'type' => TType::I16,
            ),
          ),
        2 => array(
          'var' => 'nulls',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
      if (isset($vals['nulls'])) {
        $this->nulls = $vals['nulls'];
      }
    }
  }

  public function getName() {
    return 'TI16Column';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size62 = 0;
            $_etype65 = 0;
            $xfer += $input->readListBegin($_etype65, $_size62);
            for ($_i66 = 0; $_i66 < $_size62; ++$_i66)
            {
              $elem67 = null;
              $xfer += $input->readI16($elem67);
              $this->values []= $elem67;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->nulls);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TI16Column');
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 1);
      {
        $output->writeListBegin(TType::I16, count($this->values));
        {
          foreach ($this->values as $iter68)
          {
            $xfer += $output->writeI16($iter68);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nulls !== null) {
      $xfer += $output->writeFieldBegin('nulls', TType::STRING, 2);
      $xfer += $output->writeString($this->nulls);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TI32Column {
  static $_TSPEC;

  /**
   * @var int[]
   */
  public $values = null;
  /**
   * @var string
   */
  public $nulls = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        2 => array(
          'var' => 'nulls',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
      if (isset($vals['nulls'])) {
        $this->nulls = $vals['nulls'];
      }
    }
  }

  public function getName() {
    return 'TI32Column';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size69 = 0;
            $_etype72 = 0;
            $xfer += $input->readListBegin($_etype72, $_size69);
            for ($_i73 = 0; $_i73 < $_size69; ++$_i73)
            {
              $elem74 = null;
              $xfer += $input->readI32($elem74);
              $this->values []= $elem74;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->nulls);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TI32Column');
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 1);
      {
        $output->writeListBegin(TType::I32, count($this->values));
        {
          foreach ($this->values as $iter75)
          {
            $xfer += $output->writeI32($iter75);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nulls !== null) {
      $xfer += $output->writeFieldBegin('nulls', TType::STRING, 2);
      $xfer += $output->writeString($this->nulls);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TI64Column {
  static $_TSPEC;

  /**
   * @var int[]
   */
  public $values = null;
  /**
   * @var string
   */
  public $nulls = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        2 => array(
          'var' => 'nulls',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
      if (isset($vals['nulls'])) {
        $this->nulls = $vals['nulls'];
      }
    }
  }

  public function getName() {
    return 'TI64Column';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size76 = 0;
            $_etype79 = 0;
            $xfer += $input->readListBegin($_etype79, $_size76);
            for ($_i80 = 0; $_i80 < $_size76; ++$_i80)
            {
              $elem81 = null;
              $xfer += $input->readI64($elem81);
              $this->values []= $elem81;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->nulls);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TI64Column');
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 1);
      {
        $output->writeListBegin(TType::I64, count($this->values));
        {
          foreach ($this->values as $iter82)
          {
            $xfer += $output->writeI64($iter82);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nulls !== null) {
      $xfer += $output->writeFieldBegin('nulls', TType::STRING, 2);
      $xfer += $output->writeString($this->nulls);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TDoubleColumn {
  static $_TSPEC;

  /**
   * @var double[]
   */
  public $values = null;
  /**
   * @var string
   */
  public $nulls = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::DOUBLE,
          'elem' => array(
            'type' => TType::DOUBLE,
            ),
          ),
        2 => array(
          'var' => 'nulls',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
      if (isset($vals['nulls'])) {
        $this->nulls = $vals['nulls'];
      }
    }
  }

  public function getName() {
    return 'TDoubleColumn';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size83 = 0;
            $_etype86 = 0;
            $xfer += $input->readListBegin($_etype86, $_size83);
            for ($_i87 = 0; $_i87 < $_size83; ++$_i87)
            {
              $elem88 = null;
              $xfer += $input->readDouble($elem88);
              $this->values []= $elem88;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->nulls);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TDoubleColumn');
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 1);
      {
        $output->writeListBegin(TType::DOUBLE, count($this->values));
        {
          foreach ($this->values as $iter89)
          {
            $xfer += $output->writeDouble($iter89);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nulls !== null) {
      $xfer += $output->writeFieldBegin('nulls', TType::STRING, 2);
      $xfer += $output->writeString($this->nulls);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TStringColumn {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $values = null;
  /**
   * @var string
   */
  public $nulls = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'nulls',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
      if (isset($vals['nulls'])) {
        $this->nulls = $vals['nulls'];
      }
    }
  }

  public function getName() {
    return 'TStringColumn';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size90 = 0;
            $_etype93 = 0;
            $xfer += $input->readListBegin($_etype93, $_size90);
            for ($_i94 = 0; $_i94 < $_size90; ++$_i94)
            {
              $elem95 = null;
              $xfer += $input->readString($elem95);
              $this->values []= $elem95;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->nulls);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TStringColumn');
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->values));
        {
          foreach ($this->values as $iter96)
          {
            $xfer += $output->writeString($iter96);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nulls !== null) {
      $xfer += $output->writeFieldBegin('nulls', TType::STRING, 2);
      $xfer += $output->writeString($this->nulls);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TBinaryColumn {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $values = null;
  /**
   * @var string
   */
  public $nulls = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'nulls',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
      if (isset($vals['nulls'])) {
        $this->nulls = $vals['nulls'];
      }
    }
  }

  public function getName() {
    return 'TBinaryColumn';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size97 = 0;
            $_etype100 = 0;
            $xfer += $input->readListBegin($_etype100, $_size97);
            for ($_i101 = 0; $_i101 < $_size97; ++$_i101)
            {
              $elem102 = null;
              $xfer += $input->readString($elem102);
              $this->values []= $elem102;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->nulls);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TBinaryColumn');
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->values));
        {
          foreach ($this->values as $iter103)
          {
            $xfer += $output->writeString($iter103);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nulls !== null) {
      $xfer += $output->writeFieldBegin('nulls', TType::STRING, 2);
      $xfer += $output->writeString($this->nulls);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TColumn {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TBoolColumn
   */
  public $boolVal = null;
  /**
   * @var \ThriftSQL\TByteColumn
   */
  public $byteVal = null;
  /**
   * @var \ThriftSQL\TI16Column
   */
  public $i16Val = null;
  /**
   * @var \ThriftSQL\TI32Column
   */
  public $i32Val = null;
  /**
   * @var \ThriftSQL\TI64Column
   */
  public $i64Val = null;
  /**
   * @var \ThriftSQL\TDoubleColumn
   */
  public $doubleVal = null;
  /**
   * @var \ThriftSQL\TStringColumn
   */
  public $stringVal = null;
  /**
   * @var \ThriftSQL\TBinaryColumn
   */
  public $binaryVal = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'boolVal',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TBoolColumn',
          ),
        2 => array(
          'var' => 'byteVal',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TByteColumn',
          ),
        3 => array(
          'var' => 'i16Val',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TI16Column',
          ),
        4 => array(
          'var' => 'i32Val',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TI32Column',
          ),
        5 => array(
          'var' => 'i64Val',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TI64Column',
          ),
        6 => array(
          'var' => 'doubleVal',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TDoubleColumn',
          ),
        7 => array(
          'var' => 'stringVal',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStringColumn',
          ),
        8 => array(
          'var' => 'binaryVal',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TBinaryColumn',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['boolVal'])) {
        $this->boolVal = $vals['boolVal'];
      }
      if (isset($vals['byteVal'])) {
        $this->byteVal = $vals['byteVal'];
      }
      if (isset($vals['i16Val'])) {
        $this->i16Val = $vals['i16Val'];
      }
      if (isset($vals['i32Val'])) {
        $this->i32Val = $vals['i32Val'];
      }
      if (isset($vals['i64Val'])) {
        $this->i64Val = $vals['i64Val'];
      }
      if (isset($vals['doubleVal'])) {
        $this->doubleVal = $vals['doubleVal'];
      }
      if (isset($vals['stringVal'])) {
        $this->stringVal = $vals['stringVal'];
      }
      if (isset($vals['binaryVal'])) {
        $this->binaryVal = $vals['binaryVal'];
      }
    }
  }

  public function getName() {
    return 'TColumn';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->boolVal = new \ThriftSQL\TBoolColumn();
            $xfer += $this->boolVal->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->byteVal = new \ThriftSQL\TByteColumn();
            $xfer += $this->byteVal->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->i16Val = new \ThriftSQL\TI16Column();
            $xfer += $this->i16Val->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->i32Val = new \ThriftSQL\TI32Column();
            $xfer += $this->i32Val->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->i64Val = new \ThriftSQL\TI64Column();
            $xfer += $this->i64Val->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->doubleVal = new \ThriftSQL\TDoubleColumn();
            $xfer += $this->doubleVal->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->stringVal = new \ThriftSQL\TStringColumn();
            $xfer += $this->stringVal->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRUCT) {
            $this->binaryVal = new \ThriftSQL\TBinaryColumn();
            $xfer += $this->binaryVal->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TColumn');
    if ($this->boolVal !== null) {
      if (!is_object($this->boolVal)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('boolVal', TType::STRUCT, 1);
      $xfer += $this->boolVal->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->byteVal !== null) {
      if (!is_object($this->byteVal)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('byteVal', TType::STRUCT, 2);
      $xfer += $this->byteVal->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i16Val !== null) {
      if (!is_object($this->i16Val)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('i16Val', TType::STRUCT, 3);
      $xfer += $this->i16Val->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i32Val !== null) {
      if (!is_object($this->i32Val)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('i32Val', TType::STRUCT, 4);
      $xfer += $this->i32Val->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i64Val !== null) {
      if (!is_object($this->i64Val)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('i64Val', TType::STRUCT, 5);
      $xfer += $this->i64Val->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->doubleVal !== null) {
      if (!is_object($this->doubleVal)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('doubleVal', TType::STRUCT, 6);
      $xfer += $this->doubleVal->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stringVal !== null) {
      if (!is_object($this->stringVal)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('stringVal', TType::STRUCT, 7);
      $xfer += $this->stringVal->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->binaryVal !== null) {
      if (!is_object($this->binaryVal)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('binaryVal', TType::STRUCT, 8);
      $xfer += $this->binaryVal->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TRowSet {
  static $_TSPEC;

  /**
   * @var int
   */
  public $startRowOffset = null;
  /**
   * @var \ThriftSQL\TRow[]
   */
  public $rows = null;
  /**
   * @var \ThriftSQL\TColumn[]
   */
  public $columns = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'startRowOffset',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'rows',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ThriftSQL\TRow',
            ),
          ),
        3 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ThriftSQL\TColumn',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['startRowOffset'])) {
        $this->startRowOffset = $vals['startRowOffset'];
      }
      if (isset($vals['rows'])) {
        $this->rows = $vals['rows'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
    }
  }

  public function getName() {
    return 'TRowSet';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->startRowOffset);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->rows = array();
            $_size104 = 0;
            $_etype107 = 0;
            $xfer += $input->readListBegin($_etype107, $_size104);
            for ($_i108 = 0; $_i108 < $_size104; ++$_i108)
            {
              $elem109 = null;
              $elem109 = new \ThriftSQL\TRow();
              $xfer += $elem109->read($input);
              $this->rows []= $elem109;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size110 = 0;
            $_etype113 = 0;
            $xfer += $input->readListBegin($_etype113, $_size110);
            for ($_i114 = 0; $_i114 < $_size110; ++$_i114)
            {
              $elem115 = null;
              $elem115 = new \ThriftSQL\TColumn();
              $xfer += $elem115->read($input);
              $this->columns []= $elem115;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TRowSet');
    if ($this->startRowOffset !== null) {
      $xfer += $output->writeFieldBegin('startRowOffset', TType::I64, 1);
      $xfer += $output->writeI64($this->startRowOffset);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rows !== null) {
      if (!is_array($this->rows)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rows', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->rows));
        {
          foreach ($this->rows as $iter116)
          {
            $xfer += $iter116->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->columns));
        {
          foreach ($this->columns as $iter117)
          {
            $xfer += $iter117->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TStatus {
  static $_TSPEC;

  /**
   * @var int
   */
  public $statusCode = null;
  /**
   * @var string[]
   */
  public $infoMessages = null;
  /**
   * @var string
   */
  public $sqlState = null;
  /**
   * @var int
   */
  public $errorCode = null;
  /**
   * @var string
   */
  public $errorMessage = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'statusCode',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'infoMessages',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'sqlState',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'errorCode',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'errorMessage',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['statusCode'])) {
        $this->statusCode = $vals['statusCode'];
      }
      if (isset($vals['infoMessages'])) {
        $this->infoMessages = $vals['infoMessages'];
      }
      if (isset($vals['sqlState'])) {
        $this->sqlState = $vals['sqlState'];
      }
      if (isset($vals['errorCode'])) {
        $this->errorCode = $vals['errorCode'];
      }
      if (isset($vals['errorMessage'])) {
        $this->errorMessage = $vals['errorMessage'];
      }
    }
  }

  public function getName() {
    return 'TStatus';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->statusCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->infoMessages = array();
            $_size118 = 0;
            $_etype121 = 0;
            $xfer += $input->readListBegin($_etype121, $_size118);
            for ($_i122 = 0; $_i122 < $_size118; ++$_i122)
            {
              $elem123 = null;
              $xfer += $input->readString($elem123);
              $this->infoMessages []= $elem123;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->sqlState);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->errorCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessage);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TStatus');
    if ($this->statusCode !== null) {
      $xfer += $output->writeFieldBegin('statusCode', TType::I32, 1);
      $xfer += $output->writeI32($this->statusCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->infoMessages !== null) {
      if (!is_array($this->infoMessages)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('infoMessages', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->infoMessages));
        {
          foreach ($this->infoMessages as $iter124)
          {
            $xfer += $output->writeString($iter124);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sqlState !== null) {
      $xfer += $output->writeFieldBegin('sqlState', TType::STRING, 3);
      $xfer += $output->writeString($this->sqlState);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorCode !== null) {
      $xfer += $output->writeFieldBegin('errorCode', TType::I32, 4);
      $xfer += $output->writeI32($this->errorCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorMessage !== null) {
      $xfer += $output->writeFieldBegin('errorMessage', TType::STRING, 5);
      $xfer += $output->writeString($this->errorMessage);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THandleIdentifier {
  static $_TSPEC;

  /**
   * @var string
   */
  public $guid = null;
  /**
   * @var string
   */
  public $secret = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'guid',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'secret',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['guid'])) {
        $this->guid = $vals['guid'];
      }
      if (isset($vals['secret'])) {
        $this->secret = $vals['secret'];
      }
    }
  }

  public function getName() {
    return 'THandleIdentifier';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->guid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->secret);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THandleIdentifier');
    if ($this->guid !== null) {
      $xfer += $output->writeFieldBegin('guid', TType::STRING, 1);
      $xfer += $output->writeString($this->guid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->secret !== null) {
      $xfer += $output->writeFieldBegin('secret', TType::STRING, 2);
      $xfer += $output->writeString($this->secret);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TSessionHandle {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\THandleIdentifier
   */
  public $sessionId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionId',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\THandleIdentifier',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionId'])) {
        $this->sessionId = $vals['sessionId'];
      }
    }
  }

  public function getName() {
    return 'TSessionHandle';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionId = new \ThriftSQL\THandleIdentifier();
            $xfer += $this->sessionId->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TSessionHandle');
    if ($this->sessionId !== null) {
      if (!is_object($this->sessionId)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionId', TType::STRUCT, 1);
      $xfer += $this->sessionId->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TOperationHandle {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\THandleIdentifier
   */
  public $operationId = null;
  /**
   * @var int
   */
  public $operationType = null;
  /**
   * @var bool
   */
  public $hasResultSet = null;
  /**
   * @var double
   */
  public $modifiedRowCount = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operationId',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\THandleIdentifier',
          ),
        2 => array(
          'var' => 'operationType',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'hasResultSet',
          'type' => TType::BOOL,
          ),
        4 => array(
          'var' => 'modifiedRowCount',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operationId'])) {
        $this->operationId = $vals['operationId'];
      }
      if (isset($vals['operationType'])) {
        $this->operationType = $vals['operationType'];
      }
      if (isset($vals['hasResultSet'])) {
        $this->hasResultSet = $vals['hasResultSet'];
      }
      if (isset($vals['modifiedRowCount'])) {
        $this->modifiedRowCount = $vals['modifiedRowCount'];
      }
    }
  }

  public function getName() {
    return 'TOperationHandle';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->operationId = new \ThriftSQL\THandleIdentifier();
            $xfer += $this->operationId->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->operationType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->hasResultSet);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->modifiedRowCount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TOperationHandle');
    if ($this->operationId !== null) {
      if (!is_object($this->operationId)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationId', TType::STRUCT, 1);
      $xfer += $this->operationId->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationType !== null) {
      $xfer += $output->writeFieldBegin('operationType', TType::I32, 2);
      $xfer += $output->writeI32($this->operationType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hasResultSet !== null) {
      $xfer += $output->writeFieldBegin('hasResultSet', TType::BOOL, 3);
      $xfer += $output->writeBool($this->hasResultSet);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->modifiedRowCount !== null) {
      $xfer += $output->writeFieldBegin('modifiedRowCount', TType::DOUBLE, 4);
      $xfer += $output->writeDouble($this->modifiedRowCount);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TOpenSessionReq {
  static $_TSPEC;

  /**
   * @var int
   */
  public $client_protocol =   5;
  /**
   * @var string
   */
  public $username = null;
  /**
   * @var string
   */
  public $password = null;
  /**
   * @var array
   */
  public $configuration = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'client_protocol',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'username',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'password',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'configuration',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['client_protocol'])) {
        $this->client_protocol = $vals['client_protocol'];
      }
      if (isset($vals['username'])) {
        $this->username = $vals['username'];
      }
      if (isset($vals['password'])) {
        $this->password = $vals['password'];
      }
      if (isset($vals['configuration'])) {
        $this->configuration = $vals['configuration'];
      }
    }
  }

  public function getName() {
    return 'TOpenSessionReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->client_protocol);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->username);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->password);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->configuration = array();
            $_size125 = 0;
            $_ktype126 = 0;
            $_vtype127 = 0;
            $xfer += $input->readMapBegin($_ktype126, $_vtype127, $_size125);
            for ($_i129 = 0; $_i129 < $_size125; ++$_i129)
            {
              $key130 = '';
              $val131 = '';
              $xfer += $input->readString($key130);
              $xfer += $input->readString($val131);
              $this->configuration[$key130] = $val131;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TOpenSessionReq');
    if ($this->client_protocol !== null) {
      $xfer += $output->writeFieldBegin('client_protocol', TType::I32, 1);
      $xfer += $output->writeI32($this->client_protocol);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->username !== null) {
      $xfer += $output->writeFieldBegin('username', TType::STRING, 2);
      $xfer += $output->writeString($this->username);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->password !== null) {
      $xfer += $output->writeFieldBegin('password', TType::STRING, 3);
      $xfer += $output->writeString($this->password);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->configuration !== null) {
      if (!is_array($this->configuration)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('configuration', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->configuration));
        {
          foreach ($this->configuration as $kiter132 => $viter133)
          {
            $xfer += $output->writeString($kiter132);
            $xfer += $output->writeString($viter133);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TOpenSessionResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;
  /**
   * @var int
   */
  public $serverProtocolVersion =   5;
  /**
   * @var \ThriftSQL\TSessionHandle
   */
  public $sessionHandle = null;
  /**
   * @var array
   */
  public $configuration = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        2 => array(
          'var' => 'serverProtocolVersion',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TSessionHandle',
          ),
        4 => array(
          'var' => 'configuration',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['serverProtocolVersion'])) {
        $this->serverProtocolVersion = $vals['serverProtocolVersion'];
      }
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
      if (isset($vals['configuration'])) {
        $this->configuration = $vals['configuration'];
      }
    }
  }

  public function getName() {
    return 'TOpenSessionResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->serverProtocolVersion);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new \ThriftSQL\TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->configuration = array();
            $_size134 = 0;
            $_ktype135 = 0;
            $_vtype136 = 0;
            $xfer += $input->readMapBegin($_ktype135, $_vtype136, $_size134);
            for ($_i138 = 0; $_i138 < $_size134; ++$_i138)
            {
              $key139 = '';
              $val140 = '';
              $xfer += $input->readString($key139);
              $xfer += $input->readString($val140);
              $this->configuration[$key139] = $val140;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TOpenSessionResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->serverProtocolVersion !== null) {
      $xfer += $output->writeFieldBegin('serverProtocolVersion', TType::I32, 2);
      $xfer += $output->writeI32($this->serverProtocolVersion);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 3);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->configuration !== null) {
      if (!is_array($this->configuration)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('configuration', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->configuration));
        {
          foreach ($this->configuration as $kiter141 => $viter142)
          {
            $xfer += $output->writeString($kiter141);
            $xfer += $output->writeString($viter142);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCloseSessionReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TSessionHandle
   */
  public $sessionHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TSessionHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
    }
  }

  public function getName() {
    return 'TCloseSessionReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new \ThriftSQL\TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCloseSessionReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCloseSessionResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
    }
  }

  public function getName() {
    return 'TCloseSessionResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCloseSessionResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetInfoValue {
  static $_TSPEC;

  /**
   * @var string
   */
  public $stringValue = null;
  /**
   * @var int
   */
  public $smallIntValue = null;
  /**
   * @var int
   */
  public $integerBitmask = null;
  /**
   * @var int
   */
  public $integerFlag = null;
  /**
   * @var int
   */
  public $binaryValue = null;
  /**
   * @var int
   */
  public $lenValue = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'stringValue',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'smallIntValue',
          'type' => TType::I16,
          ),
        3 => array(
          'var' => 'integerBitmask',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'integerFlag',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'binaryValue',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'lenValue',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['stringValue'])) {
        $this->stringValue = $vals['stringValue'];
      }
      if (isset($vals['smallIntValue'])) {
        $this->smallIntValue = $vals['smallIntValue'];
      }
      if (isset($vals['integerBitmask'])) {
        $this->integerBitmask = $vals['integerBitmask'];
      }
      if (isset($vals['integerFlag'])) {
        $this->integerFlag = $vals['integerFlag'];
      }
      if (isset($vals['binaryValue'])) {
        $this->binaryValue = $vals['binaryValue'];
      }
      if (isset($vals['lenValue'])) {
        $this->lenValue = $vals['lenValue'];
      }
    }
  }

  public function getName() {
    return 'TGetInfoValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stringValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->smallIntValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->integerBitmask);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->integerFlag);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->binaryValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->lenValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetInfoValue');
    if ($this->stringValue !== null) {
      $xfer += $output->writeFieldBegin('stringValue', TType::STRING, 1);
      $xfer += $output->writeString($this->stringValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->smallIntValue !== null) {
      $xfer += $output->writeFieldBegin('smallIntValue', TType::I16, 2);
      $xfer += $output->writeI16($this->smallIntValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->integerBitmask !== null) {
      $xfer += $output->writeFieldBegin('integerBitmask', TType::I32, 3);
      $xfer += $output->writeI32($this->integerBitmask);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->integerFlag !== null) {
      $xfer += $output->writeFieldBegin('integerFlag', TType::I32, 4);
      $xfer += $output->writeI32($this->integerFlag);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->binaryValue !== null) {
      $xfer += $output->writeFieldBegin('binaryValue', TType::I32, 5);
      $xfer += $output->writeI32($this->binaryValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lenValue !== null) {
      $xfer += $output->writeFieldBegin('lenValue', TType::I64, 6);
      $xfer += $output->writeI64($this->lenValue);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetInfoReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TSessionHandle
   */
  public $sessionHandle = null;
  /**
   * @var int
   */
  public $infoType = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TSessionHandle',
          ),
        2 => array(
          'var' => 'infoType',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
      if (isset($vals['infoType'])) {
        $this->infoType = $vals['infoType'];
      }
    }
  }

  public function getName() {
    return 'TGetInfoReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new \ThriftSQL\TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->infoType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetInfoReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->infoType !== null) {
      $xfer += $output->writeFieldBegin('infoType', TType::I32, 2);
      $xfer += $output->writeI32($this->infoType);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetInfoResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;
  /**
   * @var \ThriftSQL\TGetInfoValue
   */
  public $infoValue = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        2 => array(
          'var' => 'infoValue',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TGetInfoValue',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['infoValue'])) {
        $this->infoValue = $vals['infoValue'];
      }
    }
  }

  public function getName() {
    return 'TGetInfoResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->infoValue = new \ThriftSQL\TGetInfoValue();
            $xfer += $this->infoValue->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetInfoResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->infoValue !== null) {
      if (!is_object($this->infoValue)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('infoValue', TType::STRUCT, 2);
      $xfer += $this->infoValue->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TExecuteStatementReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TSessionHandle
   */
  public $sessionHandle = null;
  /**
   * @var string
   */
  public $statement = null;
  /**
   * @var array
   */
  public $confOverlay = null;
  /**
   * @var bool
   */
  public $runAsync = false;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TSessionHandle',
          ),
        2 => array(
          'var' => 'statement',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'confOverlay',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'runAsync',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
      if (isset($vals['statement'])) {
        $this->statement = $vals['statement'];
      }
      if (isset($vals['confOverlay'])) {
        $this->confOverlay = $vals['confOverlay'];
      }
      if (isset($vals['runAsync'])) {
        $this->runAsync = $vals['runAsync'];
      }
    }
  }

  public function getName() {
    return 'TExecuteStatementReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new \ThriftSQL\TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->statement);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->confOverlay = array();
            $_size143 = 0;
            $_ktype144 = 0;
            $_vtype145 = 0;
            $xfer += $input->readMapBegin($_ktype144, $_vtype145, $_size143);
            for ($_i147 = 0; $_i147 < $_size143; ++$_i147)
            {
              $key148 = '';
              $val149 = '';
              $xfer += $input->readString($key148);
              $xfer += $input->readString($val149);
              $this->confOverlay[$key148] = $val149;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->runAsync);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TExecuteStatementReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->statement !== null) {
      $xfer += $output->writeFieldBegin('statement', TType::STRING, 2);
      $xfer += $output->writeString($this->statement);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->confOverlay !== null) {
      if (!is_array($this->confOverlay)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('confOverlay', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->confOverlay));
        {
          foreach ($this->confOverlay as $kiter150 => $viter151)
          {
            $xfer += $output->writeString($kiter150);
            $xfer += $output->writeString($viter151);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->runAsync !== null) {
      $xfer += $output->writeFieldBegin('runAsync', TType::BOOL, 4);
      $xfer += $output->writeBool($this->runAsync);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TExecuteStatementResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;
  /**
   * @var \ThriftSQL\TOperationHandle
   */
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        2 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TExecuteStatementResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new \ThriftSQL\TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TExecuteStatementResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetTypeInfoReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TSessionHandle
   */
  public $sessionHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TSessionHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetTypeInfoReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new \ThriftSQL\TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetTypeInfoReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetTypeInfoResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;
  /**
   * @var \ThriftSQL\TOperationHandle
   */
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        2 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetTypeInfoResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new \ThriftSQL\TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetTypeInfoResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetCatalogsReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TSessionHandle
   */
  public $sessionHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TSessionHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetCatalogsReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new \ThriftSQL\TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetCatalogsReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetCatalogsResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;
  /**
   * @var \ThriftSQL\TOperationHandle
   */
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        2 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetCatalogsResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new \ThriftSQL\TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetCatalogsResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetSchemasReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TSessionHandle
   */
  public $sessionHandle = null;
  /**
   * @var string
   */
  public $catalogName = null;
  /**
   * @var string
   */
  public $schemaName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TSessionHandle',
          ),
        2 => array(
          'var' => 'catalogName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'schemaName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
      if (isset($vals['catalogName'])) {
        $this->catalogName = $vals['catalogName'];
      }
      if (isset($vals['schemaName'])) {
        $this->schemaName = $vals['schemaName'];
      }
    }
  }

  public function getName() {
    return 'TGetSchemasReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new \ThriftSQL\TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catalogName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schemaName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetSchemasReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catalogName !== null) {
      $xfer += $output->writeFieldBegin('catalogName', TType::STRING, 2);
      $xfer += $output->writeString($this->catalogName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->schemaName !== null) {
      $xfer += $output->writeFieldBegin('schemaName', TType::STRING, 3);
      $xfer += $output->writeString($this->schemaName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetSchemasResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;
  /**
   * @var \ThriftSQL\TOperationHandle
   */
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        2 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetSchemasResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new \ThriftSQL\TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetSchemasResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetTablesReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TSessionHandle
   */
  public $sessionHandle = null;
  /**
   * @var string
   */
  public $catalogName = null;
  /**
   * @var string
   */
  public $schemaName = null;
  /**
   * @var string
   */
  public $tableName = null;
  /**
   * @var string[]
   */
  public $tableTypes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TSessionHandle',
          ),
        2 => array(
          'var' => 'catalogName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'schemaName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'tableTypes',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
      if (isset($vals['catalogName'])) {
        $this->catalogName = $vals['catalogName'];
      }
      if (isset($vals['schemaName'])) {
        $this->schemaName = $vals['schemaName'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['tableTypes'])) {
        $this->tableTypes = $vals['tableTypes'];
      }
    }
  }

  public function getName() {
    return 'TGetTablesReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new \ThriftSQL\TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catalogName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schemaName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->tableTypes = array();
            $_size152 = 0;
            $_etype155 = 0;
            $xfer += $input->readListBegin($_etype155, $_size152);
            for ($_i156 = 0; $_i156 < $_size152; ++$_i156)
            {
              $elem157 = null;
              $xfer += $input->readString($elem157);
              $this->tableTypes []= $elem157;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetTablesReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catalogName !== null) {
      $xfer += $output->writeFieldBegin('catalogName', TType::STRING, 2);
      $xfer += $output->writeString($this->catalogName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->schemaName !== null) {
      $xfer += $output->writeFieldBegin('schemaName', TType::STRING, 3);
      $xfer += $output->writeString($this->schemaName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 4);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableTypes !== null) {
      if (!is_array($this->tableTypes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tableTypes', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRING, count($this->tableTypes));
        {
          foreach ($this->tableTypes as $iter158)
          {
            $xfer += $output->writeString($iter158);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetTablesResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;
  /**
   * @var \ThriftSQL\TOperationHandle
   */
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        2 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetTablesResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new \ThriftSQL\TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetTablesResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetTableTypesReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TSessionHandle
   */
  public $sessionHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TSessionHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetTableTypesReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new \ThriftSQL\TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetTableTypesReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetTableTypesResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;
  /**
   * @var \ThriftSQL\TOperationHandle
   */
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        2 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetTableTypesResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new \ThriftSQL\TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetTableTypesResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetColumnsReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TSessionHandle
   */
  public $sessionHandle = null;
  /**
   * @var string
   */
  public $catalogName = null;
  /**
   * @var string
   */
  public $schemaName = null;
  /**
   * @var string
   */
  public $tableName = null;
  /**
   * @var string
   */
  public $columnName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TSessionHandle',
          ),
        2 => array(
          'var' => 'catalogName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'schemaName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'columnName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
      if (isset($vals['catalogName'])) {
        $this->catalogName = $vals['catalogName'];
      }
      if (isset($vals['schemaName'])) {
        $this->schemaName = $vals['schemaName'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['columnName'])) {
        $this->columnName = $vals['columnName'];
      }
    }
  }

  public function getName() {
    return 'TGetColumnsReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new \ThriftSQL\TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catalogName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schemaName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->columnName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetColumnsReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catalogName !== null) {
      $xfer += $output->writeFieldBegin('catalogName', TType::STRING, 2);
      $xfer += $output->writeString($this->catalogName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->schemaName !== null) {
      $xfer += $output->writeFieldBegin('schemaName', TType::STRING, 3);
      $xfer += $output->writeString($this->schemaName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 4);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columnName !== null) {
      $xfer += $output->writeFieldBegin('columnName', TType::STRING, 5);
      $xfer += $output->writeString($this->columnName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetColumnsResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;
  /**
   * @var \ThriftSQL\TOperationHandle
   */
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        2 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetColumnsResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new \ThriftSQL\TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetColumnsResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetFunctionsReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TSessionHandle
   */
  public $sessionHandle = null;
  /**
   * @var string
   */
  public $catalogName = null;
  /**
   * @var string
   */
  public $schemaName = null;
  /**
   * @var string
   */
  public $functionName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TSessionHandle',
          ),
        2 => array(
          'var' => 'catalogName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'schemaName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'functionName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
      if (isset($vals['catalogName'])) {
        $this->catalogName = $vals['catalogName'];
      }
      if (isset($vals['schemaName'])) {
        $this->schemaName = $vals['schemaName'];
      }
      if (isset($vals['functionName'])) {
        $this->functionName = $vals['functionName'];
      }
    }
  }

  public function getName() {
    return 'TGetFunctionsReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new \ThriftSQL\TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catalogName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schemaName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->functionName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetFunctionsReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catalogName !== null) {
      $xfer += $output->writeFieldBegin('catalogName', TType::STRING, 2);
      $xfer += $output->writeString($this->catalogName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->schemaName !== null) {
      $xfer += $output->writeFieldBegin('schemaName', TType::STRING, 3);
      $xfer += $output->writeString($this->schemaName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->functionName !== null) {
      $xfer += $output->writeFieldBegin('functionName', TType::STRING, 4);
      $xfer += $output->writeString($this->functionName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetFunctionsResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;
  /**
   * @var \ThriftSQL\TOperationHandle
   */
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        2 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetFunctionsResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new \ThriftSQL\TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetFunctionsResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetOperationStatusReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TOperationHandle
   */
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetOperationStatusReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new \ThriftSQL\TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetOperationStatusReq');
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 1);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetOperationStatusResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;
  /**
   * @var int
   */
  public $operationState = null;
  /**
   * @var string
   */
  public $sqlState = null;
  /**
   * @var int
   */
  public $errorCode = null;
  /**
   * @var string
   */
  public $errorMessage = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        2 => array(
          'var' => 'operationState',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'sqlState',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'errorCode',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'errorMessage',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['operationState'])) {
        $this->operationState = $vals['operationState'];
      }
      if (isset($vals['sqlState'])) {
        $this->sqlState = $vals['sqlState'];
      }
      if (isset($vals['errorCode'])) {
        $this->errorCode = $vals['errorCode'];
      }
      if (isset($vals['errorMessage'])) {
        $this->errorMessage = $vals['errorMessage'];
      }
    }
  }

  public function getName() {
    return 'TGetOperationStatusResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->operationState);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->sqlState);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->errorCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessage);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetOperationStatusResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationState !== null) {
      $xfer += $output->writeFieldBegin('operationState', TType::I32, 2);
      $xfer += $output->writeI32($this->operationState);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sqlState !== null) {
      $xfer += $output->writeFieldBegin('sqlState', TType::STRING, 3);
      $xfer += $output->writeString($this->sqlState);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorCode !== null) {
      $xfer += $output->writeFieldBegin('errorCode', TType::I32, 4);
      $xfer += $output->writeI32($this->errorCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorMessage !== null) {
      $xfer += $output->writeFieldBegin('errorMessage', TType::STRING, 5);
      $xfer += $output->writeString($this->errorMessage);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCancelOperationReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TOperationHandle
   */
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TCancelOperationReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new \ThriftSQL\TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCancelOperationReq');
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 1);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCancelOperationResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
    }
  }

  public function getName() {
    return 'TCancelOperationResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCancelOperationResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCloseOperationReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TOperationHandle
   */
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TCloseOperationReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new \ThriftSQL\TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCloseOperationReq');
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 1);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCloseOperationResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
    }
  }

  public function getName() {
    return 'TCloseOperationResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCloseOperationResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetResultSetMetadataReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TOperationHandle
   */
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetResultSetMetadataReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new \ThriftSQL\TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetResultSetMetadataReq');
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 1);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetResultSetMetadataResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;
  /**
   * @var \ThriftSQL\TTableSchema
   */
  public $schema = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        2 => array(
          'var' => 'schema',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TTableSchema',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['schema'])) {
        $this->schema = $vals['schema'];
      }
    }
  }

  public function getName() {
    return 'TGetResultSetMetadataResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->schema = new \ThriftSQL\TTableSchema();
            $xfer += $this->schema->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetResultSetMetadataResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->schema !== null) {
      if (!is_object($this->schema)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('schema', TType::STRUCT, 2);
      $xfer += $this->schema->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TFetchResultsReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TOperationHandle
   */
  public $operationHandle = null;
  /**
   * @var int
   */
  public $orientation =   0;
  /**
   * @var int
   */
  public $maxRows = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TOperationHandle',
          ),
        2 => array(
          'var' => 'orientation',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'maxRows',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
      if (isset($vals['orientation'])) {
        $this->orientation = $vals['orientation'];
      }
      if (isset($vals['maxRows'])) {
        $this->maxRows = $vals['maxRows'];
      }
    }
  }

  public function getName() {
    return 'TFetchResultsReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new \ThriftSQL\TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->orientation);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->maxRows);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TFetchResultsReq');
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 1);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->orientation !== null) {
      $xfer += $output->writeFieldBegin('orientation', TType::I32, 2);
      $xfer += $output->writeI32($this->orientation);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxRows !== null) {
      $xfer += $output->writeFieldBegin('maxRows', TType::I64, 3);
      $xfer += $output->writeI64($this->maxRows);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TFetchResultsResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;
  /**
   * @var bool
   */
  public $hasMoreRows = null;
  /**
   * @var \ThriftSQL\TRowSet
   */
  public $results = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        2 => array(
          'var' => 'hasMoreRows',
          'type' => TType::BOOL,
          ),
        3 => array(
          'var' => 'results',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TRowSet',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['hasMoreRows'])) {
        $this->hasMoreRows = $vals['hasMoreRows'];
      }
      if (isset($vals['results'])) {
        $this->results = $vals['results'];
      }
    }
  }

  public function getName() {
    return 'TFetchResultsResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->hasMoreRows);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->results = new \ThriftSQL\TRowSet();
            $xfer += $this->results->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TFetchResultsResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hasMoreRows !== null) {
      $xfer += $output->writeFieldBegin('hasMoreRows', TType::BOOL, 2);
      $xfer += $output->writeBool($this->hasMoreRows);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->results !== null) {
      if (!is_object($this->results)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('results', TType::STRUCT, 3);
      $xfer += $this->results->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetDelegationTokenReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TSessionHandle
   */
  public $sessionHandle = null;
  /**
   * @var string
   */
  public $owner = null;
  /**
   * @var string
   */
  public $renewer = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TSessionHandle',
          ),
        2 => array(
          'var' => 'owner',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'renewer',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
      if (isset($vals['owner'])) {
        $this->owner = $vals['owner'];
      }
      if (isset($vals['renewer'])) {
        $this->renewer = $vals['renewer'];
      }
    }
  }

  public function getName() {
    return 'TGetDelegationTokenReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new \ThriftSQL\TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->owner);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->renewer);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetDelegationTokenReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->owner !== null) {
      $xfer += $output->writeFieldBegin('owner', TType::STRING, 2);
      $xfer += $output->writeString($this->owner);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->renewer !== null) {
      $xfer += $output->writeFieldBegin('renewer', TType::STRING, 3);
      $xfer += $output->writeString($this->renewer);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetDelegationTokenResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;
  /**
   * @var string
   */
  public $delegationToken = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        2 => array(
          'var' => 'delegationToken',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['delegationToken'])) {
        $this->delegationToken = $vals['delegationToken'];
      }
    }
  }

  public function getName() {
    return 'TGetDelegationTokenResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->delegationToken);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetDelegationTokenResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->delegationToken !== null) {
      $xfer += $output->writeFieldBegin('delegationToken', TType::STRING, 2);
      $xfer += $output->writeString($this->delegationToken);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCancelDelegationTokenReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TSessionHandle
   */
  public $sessionHandle = null;
  /**
   * @var string
   */
  public $delegationToken = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TSessionHandle',
          ),
        2 => array(
          'var' => 'delegationToken',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
      if (isset($vals['delegationToken'])) {
        $this->delegationToken = $vals['delegationToken'];
      }
    }
  }

  public function getName() {
    return 'TCancelDelegationTokenReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new \ThriftSQL\TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->delegationToken);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCancelDelegationTokenReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->delegationToken !== null) {
      $xfer += $output->writeFieldBegin('delegationToken', TType::STRING, 2);
      $xfer += $output->writeString($this->delegationToken);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCancelDelegationTokenResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
    }
  }

  public function getName() {
    return 'TCancelDelegationTokenResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCancelDelegationTokenResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TRenewDelegationTokenReq {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TSessionHandle
   */
  public $sessionHandle = null;
  /**
   * @var string
   */
  public $delegationToken = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TSessionHandle',
          ),
        2 => array(
          'var' => 'delegationToken',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
      if (isset($vals['delegationToken'])) {
        $this->delegationToken = $vals['delegationToken'];
      }
    }
  }

  public function getName() {
    return 'TRenewDelegationTokenReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new \ThriftSQL\TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->delegationToken);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TRenewDelegationTokenReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->delegationToken !== null) {
      $xfer += $output->writeFieldBegin('delegationToken', TType::STRING, 2);
      $xfer += $output->writeString($this->delegationToken);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TRenewDelegationTokenResp {
  static $_TSPEC;

  /**
   * @var \ThriftSQL\TStatus
   */
  public $status = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ThriftSQL\TStatus',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
    }
  }

  public function getName() {
    return 'TRenewDelegationTokenResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ThriftSQL\TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TRenewDelegationTokenResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

final class Constant extends \Thrift\Type\TConstant {
  static protected $PRIMITIVE_TYPES;
  static protected $COMPLEX_TYPES;
  static protected $COLLECTION_TYPES;
  static protected $TYPE_NAMES;
  static protected $CHARACTER_MAXIMUM_LENGTH;
  static protected $PRECISION;
  static protected $SCALE;

  static protected function init_PRIMITIVE_TYPES() {
    return array(
            0 => true,
            1 => true,
            2 => true,
            3 => true,
            4 => true,
            5 => true,
            6 => true,
            7 => true,
            8 => true,
            9 => true,
            15 => true,
            16 => true,
            17 => true,
            18 => true,
            19 => true,
    );
  }

  static protected function init_COMPLEX_TYPES() {
    return array(
            10 => true,
            11 => true,
            12 => true,
            13 => true,
            14 => true,
    );
  }

  static protected function init_COLLECTION_TYPES() {
    return array(
            10 => true,
            11 => true,
    );
  }

  static protected function init_TYPE_NAMES() {
    return array(
            0 => "BOOLEAN",
            1 => "TINYINT",
            2 => "SMALLINT",
            3 => "INT",
            4 => "BIGINT",
            5 => "FLOAT",
            6 => "DOUBLE",
            7 => "STRING",
            8 => "TIMESTAMP",
            9 => "BINARY",
            10 => "ARRAY",
            11 => "MAP",
            12 => "STRUCT",
            13 => "UNIONTYPE",
            15 => "DECIMAL",
            16 => "NULL",
            17 => "DATE",
            18 => "VARCHAR",
            19 => "CHAR",
    );
  }

  static protected function init_CHARACTER_MAXIMUM_LENGTH() {
    return "characterMaximumLength";
  }

  static protected function init_PRECISION() {
    return "precision";
  }

  static protected function init_SCALE() {
    return "scale";
  }
}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift
 */

namespace Thrift\Base;

use Thrift\Type\TType;

/**
 * Base class from which other Thrift structs extend. This is so that we can
 * cut back on the size of the generated code which is turning out to have a
 * nontrivial cost just to load thanks to the wondrously abysmal implementation
 * of PHP. Note that code is intentionally duplicated in here to avoid making
 * function calls for every field or member of a container..
 */
abstract class TBase {

  static $tmethod = array(TType::BOOL   => 'Bool',
                          TType::BYTE   => 'Byte',
                          TType::I16    => 'I16',
                          TType::I32    => 'I32',
                          TType::I64    => 'I64',
                          TType::DOUBLE => 'Double',
                          TType::STRING => 'String');

  abstract function read($input);

  abstract function write($output);

  public function __construct($spec=null, $vals=null) {
    if (is_array($spec) && is_array($vals)) {
      foreach ($spec as $fid => $fspec) {
        $var = $fspec['var'];
        if (isset($vals[$var])) {
          $this->$var = $vals[$var];
        }
      }
    }
  }

  public function __wakeup()
  {
    $this->__construct(get_object_vars($this));
  }

  private function _readMap(&$var, $spec, $input) {
    $xfer = 0;
    $ktype = $spec['ktype'];
    $vtype = $spec['vtype'];
    $kread = $vread = null;
    if (isset(TBase::$tmethod[$ktype])) {
      $kread = 'read'.TBase::$tmethod[$ktype];
    } else {
      $kspec = $spec['key'];
    }
    if (isset(TBase::$tmethod[$vtype])) {
      $vread = 'read'.TBase::$tmethod[$vtype];
    } else {
      $vspec = $spec['val'];
    }
    $var = array();
    $_ktype = $_vtype = $size = 0;
    $xfer += $input->readMapBegin($_ktype, $_vtype, $size);
    for ($i = 0; $i < $size; ++$i) {
      $key = $val = null;
      if ($kread !== null) {
        $xfer += $input->$kread($key);
      } else {
        switch ($ktype) {
        case TType::STRUCT:
          $class = $kspec['class'];
          $key = new $class();
          $xfer += $key->read($input);
          break;
        case TType::MAP:
          $xfer += $this->_readMap($key, $kspec, $input);
          break;
        case TType::LST:
          $xfer += $this->_readList($key, $kspec, $input, false);
          break;
        case TType::SET:
          $xfer += $this->_readList($key, $kspec, $input, true);
          break;
        }
      }
      if ($vread !== null) {
        $xfer += $input->$vread($val);
      } else {
        switch ($vtype) {
        case TType::STRUCT:
          $class = $vspec['class'];
          $val = new $class();
          $xfer += $val->read($input);
          break;
        case TType::MAP:
          $xfer += $this->_readMap($val, $vspec, $input);
          break;
        case TType::LST:
          $xfer += $this->_readList($val, $vspec, $input, false);
          break;
        case TType::SET:
          $xfer += $this->_readList($val, $vspec, $input, true);
          break;
        }
      }
      $var[$key] = $val;
    }
    $xfer += $input->readMapEnd();
    return $xfer;
  }

  private function _readList(&$var, $spec, $input, $set=false) {
    $xfer = 0;
    $etype = $spec['etype'];
    $eread = $vread = null;
    if (isset(TBase::$tmethod[$etype])) {
      $eread = 'read'.TBase::$tmethod[$etype];
    } else {
      $espec = $spec['elem'];
    }
    $var = array();
    $_etype = $size = 0;
    if ($set) {
      $xfer += $input->readSetBegin($_etype, $size);
    } else {
      $xfer += $input->readListBegin($_etype, $size);
    }
    for ($i = 0; $i < $size; ++$i) {
      $elem = null;
      if ($eread !== null) {
        $xfer += $input->$eread($elem);
      } else {
        $espec = $spec['elem'];
        switch ($etype) {
        case TType::STRUCT:
          $class = $espec['class'];
          $elem = new $class();
          $xfer += $elem->read($input);
          break;
        case TType::MAP:
          $xfer += $this->_readMap($elem, $espec, $input);
          break;
        case TType::LST:
          $xfer += $this->_readList($elem, $espec, $input, false);
          break;
        case TType::SET:
          $xfer += $this->_readList($elem, $espec, $input, true);
          break;
        }
      }
      if ($set) {
        $var[$elem] = true;
      } else {
        $var []= $elem;
      }
    }
    if ($set) {
      $xfer += $input->readSetEnd();
    } else {
      $xfer += $input->readListEnd();
    }
    return $xfer;
  }

  protected function _read($class, $spec, $input) {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true) {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      if (isset($spec[$fid])) {
        $fspec = $spec[$fid];
        $var = $fspec['var'];
        if ($ftype == $fspec['type']) {
          $xfer = 0;
          if (isset(TBase::$tmethod[$ftype])) {
            $func = 'read'.TBase::$tmethod[$ftype];
            $xfer += $input->$func($this->$var);
          } else {
            switch ($ftype) {
            case TType::STRUCT:
              $class = $fspec['class'];
              $this->$var = new $class();
              $xfer += $this->$var->read($input);
              break;
            case TType::MAP:
              $xfer += $this->_readMap($this->$var, $fspec, $input);
              break;
            case TType::LST:
              $xfer += $this->_readList($this->$var, $fspec, $input, false);
              break;
            case TType::SET:
              $xfer += $this->_readList($this->$var, $fspec, $input, true);
              break;
            }
          }
        } else {
          $xfer += $input->skip($ftype);
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  private function _writeMap($var, $spec, $output) {
    $xfer = 0;
    $ktype = $spec['ktype'];
    $vtype = $spec['vtype'];
    $kwrite = $vwrite = null;
    if (isset(TBase::$tmethod[$ktype])) {
      $kwrite = 'write'.TBase::$tmethod[$ktype];
    } else {
      $kspec = $spec['key'];
    }
    if (isset(TBase::$tmethod[$vtype])) {
      $vwrite = 'write'.TBase::$tmethod[$vtype];
    } else {
      $vspec = $spec['val'];
    }
    $xfer += $output->writeMapBegin($ktype, $vtype, count($var));
    foreach ($var as $key => $val) {
      if (isset($kwrite)) {
        $xfer += $output->$kwrite($key);
      } else {
        switch ($ktype) {
        case TType::STRUCT:
          $xfer += $key->write($output);
          break;
        case TType::MAP:
          $xfer += $this->_writeMap($key, $kspec, $output);
          break;
        case TType::LST:
          $xfer += $this->_writeList($key, $kspec, $output, false);
          break;
        case TType::SET:
          $xfer += $this->_writeList($key, $kspec, $output, true);
          break;
        }
      }
      if (isset($vwrite)) {
        $xfer += $output->$vwrite($val);
      } else {
        switch ($vtype) {
        case TType::STRUCT:
          $xfer += $val->write($output);
          break;
        case TType::MAP:
          $xfer += $this->_writeMap($val, $vspec, $output);
          break;
        case TType::LST:
          $xfer += $this->_writeList($val, $vspec, $output, false);
          break;
        case TType::SET:
          $xfer += $this->_writeList($val, $vspec, $output, true);
          break;
        }
      }
    }
    $xfer += $output->writeMapEnd();
    return $xfer;
  }

  private function _writeList($var, $spec, $output, $set=false) {
    $xfer = 0;
    $etype = $spec['etype'];
    $ewrite = null;
    if (isset(TBase::$tmethod[$etype])) {
      $ewrite = 'write'.TBase::$tmethod[$etype];
    } else {
      $espec = $spec['elem'];
    }
    if ($set) {
      $xfer += $output->writeSetBegin($etype, count($var));
    } else {
      $xfer += $output->writeListBegin($etype, count($var));
    }
    foreach ($var as $key => $val) {
      $elem = $set ? $key : $val;
      if (isset($ewrite)) {
        $xfer += $output->$ewrite($elem);
      } else {
        switch ($etype) {
        case TType::STRUCT:
          $xfer += $elem->write($output);
          break;
        case TType::MAP:
          $xfer += $this->_writeMap($elem, $espec, $output);
          break;
        case TType::LST:
          $xfer += $this->_writeList($elem, $espec, $output, false);
          break;
        case TType::SET:
          $xfer += $this->_writeList($elem, $espec, $output, true);
          break;
        }
      }
    }
    if ($set) {
      $xfer += $output->writeSetEnd();
    } else {
      $xfer += $output->writeListEnd();
    }
    return $xfer;
  }

  protected function _write($class, $spec, $output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin($class);
    foreach ($spec as $fid => $fspec) {
      $var = $fspec['var'];
      if ($this->$var !== null) {
        $ftype = $fspec['type'];
        $xfer += $output->writeFieldBegin($var, $ftype, $fid);
        if (isset(TBase::$tmethod[$ftype])) {
          $func = 'write'.TBase::$tmethod[$ftype];
          $xfer += $output->$func($this->$var);
        } else {
          switch ($ftype) {
          case TType::STRUCT:
            $xfer += $this->$var->write($output);
            break;
          case TType::MAP:
            $xfer += $this->_writeMap($this->$var, $fspec, $output);
            break;
          case TType::LST:
            $xfer += $this->_writeList($this->$var, $fspec, $output, false);
            break;
          case TType::SET:
            $xfer += $this->_writeList($this->$var, $fspec, $output, true);
            break;
          }
        }
        $xfer += $output->writeFieldEnd();
      }
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * ClassLoader to load Thrift library and definitions
 * Inspired from UniversalClassLoader from Symfony 2 
 *
 * @package thrift.classloader
 */

namespace Thrift\ClassLoader;

class ThriftClassLoader
{
    /**
     * Namespaces path
     * @var array
     */
    protected $namespaces = array();

    /**
     * Thrift definition paths
     * @var type
     */
    protected $definitions = array();

    /**
     * Do we use APC cache ?
     * @var boolean
     */
    protected $apc = false;

    /**
     * APC Cache prefix
     * @var string
     */
    protected $apc_prefix;

    /**
     * Set autoloader to use APC cache
     * @param boolean $apc
     * @param string $apc_prefix
     */
    public function __construct($apc = false, $apc_prefix = null)
    {
        $this->apc = $apc;
        $this->apc_prefix = $apc_prefix;
    }

    /**
     * Registers a namespace.
     *
     * @param string       $namespace The namespace
     * @param array|string $paths     The location(s) of the namespace
     */
    public function registerNamespace($namespace, $paths)
    {
        $this->namespaces[$namespace] = (array) $paths;
    }

    /**
     * Registers a Thrift definition namespace.
     *
     * @param string       $namespace The definition namespace
     * @param array|string $paths     The location(s) of the definition namespace
     */
    public function registerDefinition($namespace, $paths)
    {
        $this->definitions[$namespace] = (array) $paths;
    }

    /**
     * Registers this instance as an autoloader.
     *
     * @param Boolean $prepend Whether to prepend the autoloader or not
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }

    /**
     * Loads the given class, definition or interface.
     *
     * @param string $class The name of the class
     */
    public function loadClass($class)
    {
        if (
            (true === $this->apc && ($file = $this->findFileInApc($class))) or
            ($file = $this->findFile($class))
        )
        {
            require_once $file;
        }
    }

    /**
     * Loads the given class or interface in APC.
     * @param string $class The name of the class
     * @return string
     */
    protected function findFileInApc($class)
    {
        if (false === $file = apc_fetch($this->apc_prefix.$class)) {
            apc_store($this->apc_prefix.$class, $file = $this->findFile($class));
        }

        return $file;
    }

    /**
     * Find class in namespaces or definitions directories
     * @param string $class
     * @return string
     */
    public function findFile($class)
    {
        // Remove first backslash
        if ('\\' == $class[0])
        {
            $class = substr($class, 1);
        }

        if (false !== $pos = strrpos($class, '\\'))
        {
            // Namespaced class name
            $namespace = substr($class, 0, $pos);

            // Iterate in normal namespaces
            foreach ($this->namespaces as $ns => $dirs)
            {
                //Don't interfere with other autoloaders
                if (0 !== strpos($namespace, $ns))
                {
                    continue;
                }

                foreach ($dirs as $dir)
                {
                    $className = substr($class, $pos + 1);

                    $file = $dir.DIRECTORY_SEPARATOR.
                                 str_replace('\\', DIRECTORY_SEPARATOR, $namespace).
                                 DIRECTORY_SEPARATOR.
                                 $className.'.php';

                    if (file_exists($file))
                    {
                        return $file;
                    }
                }
            }

            // Iterate in Thrift namespaces

            // Remove first part of namespace
            $m = explode('\\', $class);

            // Ignore wrong call
            if(count($m) <= 1)
            {
                return;
            }

            $class = array_pop($m);
            $namespace = implode('\\', $m);

            foreach ($this->definitions as $ns => $dirs)
            {
                //Don't interfere with other autoloaders
                if (0 !== strpos($namespace, $ns))
                {
                    continue;
                }

                foreach ($dirs as $dir)
                {
                    /**
                     * Available in service: Interface, Client, Processor, Rest
                     * And every service methods (_.+)
                     */
                    if(
                        0 === preg_match('#(.+)(if|client|processor|rest)$#i', $class, $n) and
                        0 === preg_match('#(.+)_[a-z0-9]+_(args|result)$#i', $class, $n)
                    )
                    {
                        $className = 'Types';
                    }
                    else
                    {
                        $className = $n[1];
                    }

                    $file = $dir.DIRECTORY_SEPARATOR .
                                 str_replace('\\', DIRECTORY_SEPARATOR, $namespace) .
                                 DIRECTORY_SEPARATOR .
                                 $className . '.php';

                    if (file_exists($file))
                    {
                        return $file;
                    }
                }
            }
        }
    }
}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift
 */

namespace Thrift\Exception;

use Thrift\Exception\TException;
use Thrift\Type\TType;

class TApplicationException extends TException {
  static $_TSPEC =
    array(1 => array('var' => 'message',
                     'type' => TType::STRING),
          2 => array('var' => 'code',
                     'type' => TType::I32));

  const UNKNOWN = 0;
  const UNKNOWN_METHOD = 1;
  const INVALID_MESSAGE_TYPE = 2;
  const WRONG_METHOD_NAME = 3;
  const BAD_SEQUENCE_ID = 4;
  const MISSING_RESULT = 5;
  const INTERNAL_ERROR = 6;
  const PROTOCOL_ERROR = 7;
  const INVALID_TRANSFORM = 8;
  const INVALID_PROTOCOL = 9;
  const UNSUPPORTED_CLIENT_TYPE = 10;

  function __construct($message=null, $code=0) {
    parent::__construct($message, $code);
  }

  public function read($output) {
    return $this->_read('TApplicationException', self::$_TSPEC, $output);
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TApplicationException');
    if ($message = $this->getMessage()) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($message);
      $xfer += $output->writeFieldEnd();
    }
    if ($code = $this->getCode()) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 2);
      $xfer += $output->writeI32($code);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift
 */

namespace Thrift\Exception;

use Thrift\Type\TType;
use Thrift\Base\TBase;

/**
 * NOTE(mcslee): This currently contains a ton of duplicated code from TBase
 * because we need to save CPU cycles and this is not yet in an extension.
 * Ideally we'd multiply-inherit TException from both Exception and Base, but
 * that's not possible in PHP and there are no modules either, so for now we
 * apologetically take a trip to HackTown.
 *
 * Can be called with standard Exception constructor (message, code) or with
 * Thrift Base object constructor (spec, vals).
 *
 * @param mixed $p1 Message (string) or type-spec (array)
 * @param mixed $p2 Code (integer) or values (array)
 */
class TException extends \Exception {
  function __construct($p1=null, $p2=0) {
    if (is_array($p1) && is_array($p2)) {
      $spec = $p1;
      $vals = $p2;
      foreach ($spec as $fid => $fspec) {
        $var = $fspec['var'];
        if (isset($vals[$var])) {
          $this->$var = $vals[$var];
        }
      }
    } else {
      parent::__construct($p1, $p2);
    }
  }

  static $tmethod = array(TType::BOOL   => 'Bool',
                          TType::BYTE   => 'Byte',
                          TType::I16    => 'I16',
                          TType::I32    => 'I32',
                          TType::I64    => 'I64',
                          TType::DOUBLE => 'Double',
                          TType::STRING => 'String');

  private function _readMap(&$var, $spec, $input) {
    $xfer = 0;
    $ktype = $spec['ktype'];
    $vtype = $spec['vtype'];
    $kread = $vread = null;
    if (isset(TBase::$tmethod[$ktype])) {
      $kread = 'read'.TBase::$tmethod[$ktype];
    } else {
      $kspec = $spec['key'];
    }
    if (isset(TBase::$tmethod[$vtype])) {
      $vread = 'read'.TBase::$tmethod[$vtype];
    } else {
      $vspec = $spec['val'];
    }
    $var = array();
    $_ktype = $_vtype = $size = 0;
    $xfer += $input->readMapBegin($_ktype, $_vtype, $size);
    for ($i = 0; $i < $size; ++$i) {
      $key = $val = null;
      if ($kread !== null) {
        $xfer += $input->$kread($key);
      } else {
        switch ($ktype) {
        case TType::STRUCT:
          $class = $kspec['class'];
          $key = new $class();
          $xfer += $key->read($input);
          break;
        case TType::MAP:
          $xfer += $this->_readMap($key, $kspec, $input);
          break;
        case TType::LST:
          $xfer += $this->_readList($key, $kspec, $input, false);
          break;
        case TType::SET:
          $xfer += $this->_readList($key, $kspec, $input, true);
          break;
        }
      }
      if ($vread !== null) {
        $xfer += $input->$vread($val);
      } else {
        switch ($vtype) {
        case TType::STRUCT:
          $class = $vspec['class'];
          $val = new $class();
          $xfer += $val->read($input);
          break;
        case TType::MAP:
          $xfer += $this->_readMap($val, $vspec, $input);
          break;
        case TType::LST:
          $xfer += $this->_readList($val, $vspec, $input, false);
          break;
        case TType::SET:
          $xfer += $this->_readList($val, $vspec, $input, true);
          break;
        }
      }
      $var[$key] = $val;
    }
    $xfer += $input->readMapEnd();
    return $xfer;
  }

  private function _readList(&$var, $spec, $input, $set=false) {
    $xfer = 0;
    $etype = $spec['etype'];
    $eread = $vread = null;
    if (isset(TBase::$tmethod[$etype])) {
      $eread = 'read'.TBase::$tmethod[$etype];
    } else {
      $espec = $spec['elem'];
    }
    $var = array();
    $_etype = $size = 0;
    if ($set) {
      $xfer += $input->readSetBegin($_etype, $size);
    } else {
      $xfer += $input->readListBegin($_etype, $size);
    }
    for ($i = 0; $i < $size; ++$i) {
      $elem = null;
      if ($eread !== null) {
        $xfer += $input->$eread($elem);
      } else {
        $espec = $spec['elem'];
        switch ($etype) {
        case TType::STRUCT:
          $class = $espec['class'];
          $elem = new $class();
          $xfer += $elem->read($input);
          break;
        case TType::MAP:
          $xfer += $this->_readMap($elem, $espec, $input);
          break;
        case TType::LST:
          $xfer += $this->_readList($elem, $espec, $input, false);
          break;
        case TType::SET:
          $xfer += $this->_readList($elem, $espec, $input, true);
          break;
        }
      }
      if ($set) {
        $var[$elem] = true;
      } else {
        $var []= $elem;
      }
    }
    if ($set) {
      $xfer += $input->readSetEnd();
    } else {
      $xfer += $input->readListEnd();
    }
    return $xfer;
  }

  protected function _read($class, $spec, $input) {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true) {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      if (isset($spec[$fid])) {
        $fspec = $spec[$fid];
        $var = $fspec['var'];
        if ($ftype == $fspec['type']) {
          $xfer = 0;
          if (isset(TBase::$tmethod[$ftype])) {
            $func = 'read'.TBase::$tmethod[$ftype];
            $xfer += $input->$func($this->$var);
          } else {
            switch ($ftype) {
            case TType::STRUCT:
              $class = $fspec['class'];
              $this->$var = new $class();
              $xfer += $this->$var->read($input);
              break;
            case TType::MAP:
              $xfer += $this->_readMap($this->$var, $fspec, $input);
              break;
            case TType::LST:
              $xfer += $this->_readList($this->$var, $fspec, $input, false);
              break;
            case TType::SET:
              $xfer += $this->_readList($this->$var, $fspec, $input, true);
              break;
            }
          }
        } else {
          $xfer += $input->skip($ftype);
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  private function _writeMap($var, $spec, $output) {
    $xfer = 0;
    $ktype = $spec['ktype'];
    $vtype = $spec['vtype'];
    $kwrite = $vwrite = null;
    if (isset(TBase::$tmethod[$ktype])) {
      $kwrite = 'write'.TBase::$tmethod[$ktype];
    } else {
      $kspec = $spec['key'];
    }
    if (isset(TBase::$tmethod[$vtype])) {
      $vwrite = 'write'.TBase::$tmethod[$vtype];
    } else {
      $vspec = $spec['val'];
    }
    $xfer += $output->writeMapBegin($ktype, $vtype, count($var));
    foreach ($var as $key => $val) {
      if (isset($kwrite)) {
        $xfer += $output->$kwrite($key);
      } else {
        switch ($ktype) {
        case TType::STRUCT:
          $xfer += $key->write($output);
          break;
        case TType::MAP:
          $xfer += $this->_writeMap($key, $kspec, $output);
          break;
        case TType::LST:
          $xfer += $this->_writeList($key, $kspec, $output, false);
          break;
        case TType::SET:
          $xfer += $this->_writeList($key, $kspec, $output, true);
          break;
        }
      }
      if (isset($vwrite)) {
        $xfer += $output->$vwrite($val);
      } else {
        switch ($vtype) {
        case TType::STRUCT:
          $xfer += $val->write($output);
          break;
        case TType::MAP:
          $xfer += $this->_writeMap($val, $vspec, $output);
          break;
        case TType::LST:
          $xfer += $this->_writeList($val, $vspec, $output, false);
          break;
        case TType::SET:
          $xfer += $this->_writeList($val, $vspec, $output, true);
          break;
        }
      }
    }
    $xfer += $output->writeMapEnd();
    return $xfer;
  }

  private function _writeList($var, $spec, $output, $set=false) {
    $xfer = 0;
    $etype = $spec['etype'];
    $ewrite = null;
    if (isset(TBase::$tmethod[$etype])) {
      $ewrite = 'write'.TBase::$tmethod[$etype];
    } else {
      $espec = $spec['elem'];
    }
    if ($set) {
      $xfer += $output->writeSetBegin($etype, count($var));
    } else {
      $xfer += $output->writeListBegin($etype, count($var));
    }
    foreach ($var as $key => $val) {
      $elem = $set ? $key : $val;
      if (isset($ewrite)) {
        $xfer += $output->$ewrite($elem);
      } else {
        switch ($etype) {
        case TType::STRUCT:
          $xfer += $elem->write($output);
          break;
        case TType::MAP:
          $xfer += $this->_writeMap($elem, $espec, $output);
          break;
        case TType::LST:
          $xfer += $this->_writeList($elem, $espec, $output, false);
          break;
        case TType::SET:
          $xfer += $this->_writeList($elem, $espec, $output, true);
          break;
        }
      }
    }
    if ($set) {
      $xfer += $output->writeSetEnd();
    } else {
      $xfer += $output->writeListEnd();
    }
    return $xfer;
  }

  protected function _write($class, $spec, $output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin($class);
    foreach ($spec as $fid => $fspec) {
      $var = $fspec['var'];
      if ($this->$var !== null) {
        $ftype = $fspec['type'];
        $xfer += $output->writeFieldBegin($var, $ftype, $fid);
        if (isset(TBase::$tmethod[$ftype])) {
          $func = 'write'.TBase::$tmethod[$ftype];
          $xfer += $output->$func($this->$var);
        } else {
          switch ($ftype) {
          case TType::STRUCT:
            $xfer += $this->$var->write($output);
            break;
          case TType::MAP:
            $xfer += $this->_writeMap($this->$var, $fspec, $output);
            break;
          case TType::LST:
            $xfer += $this->_writeList($this->$var, $fspec, $output, false);
            break;
          case TType::SET:
            $xfer += $this->_writeList($this->$var, $fspec, $output, true);
            break;
          }
        }
        $xfer += $output->writeFieldEnd();
      }
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.protocol
 * @author: rmarin (marin.radu@facebook.com)
 */

namespace Thrift\Exception;

use Thrift\Exception\TException;

/**
 * Protocol module. Contains all the types and definitions needed to implement
 * a protocol encoder/decoder.
 *
 * @package thrift.protocol
 */

/**
 * Protocol exceptions
 */
class TProtocolException extends TException {
  const UNKNOWN = 0;
  const INVALID_DATA = 1;
  const NEGATIVE_SIZE = 2;
  const SIZE_LIMIT = 3;
  const BAD_VERSION = 4;
  const NOT_IMPLEMENTED = 5;
  const DEPTH_LIMIT = 6;

  function __construct($message=null, $code=0) {
    parent::__construct($message, $code);
  }
}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.transport
 */

namespace Thrift\Exception;

use Thrift\Exception\TException;

/**
 * Transport exceptions
 */
class TTransportException extends TException {

  const UNKNOWN = 0;
  const NOT_OPEN = 1;
  const ALREADY_OPEN = 2;
  const TIMED_OUT = 3;
  const END_OF_FILE = 4;

  function __construct($message=null, $code=0) {
    parent::__construct($message, $code);
  }
}<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.protocol
 */

namespace Thrift\Factory;

use Thrift\Factory\TProtocolFactory;
use Thrift\Protocol\TBinaryProtocol;

/**
 * Binary Protocol Factory
 */
class TBinaryProtocolFactory implements TProtocolFactory {
  private $strictRead_ = false;
  private $strictWrite_ = false;

  public function __construct($strictRead=false, $strictWrite=false) {
    $this->strictRead_ = $strictRead;
    $this->strictWrite_ = $strictWrite;
  }

  public function getProtocol($trans) {
    return new TBinaryProtocol($trans, $this->strictRead_, $this->strictWrite_);
  }
}<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.protocol
 */

namespace Thrift\Factory;

use Thrift\Factory\TProtocolFactory;
use Thrift\Protocol\TCompactProtocol;

/**
 * Compact Protocol Factory
 */
class TCompactProtocolFactory implements TProtocolFactory {

  public function __construct() {
  }

  public function getProtocol($trans) {
    return new TCompactProtocol($trans);
  }
}<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.protocol
 */

namespace Thrift\Factory;

use Thrift\Factory\TProtocolFactory;
use Thrift\Protocol\TJSONProtocol;

/**
 * JSON Protocol Factory
 */
class TJSONProtocolFactory implements TProtocolFactory
{
    public function __construct()
    {
    }

    public function getProtocol($trans)
    {
        return new TJSONProtocol($trans);
    }
}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.protocol
 */

namespace Thrift\Factory;

/**
 * Protocol factory creates protocol objects from transports
 */
interface TProtocolFactory {
  /**
   * Build a protocol from the base transport
   *
   * @return Thrift\Protocol\TProtocol protocol
   */
  public function getProtocol($trans);
}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

namespace Thrift\Factory;

use Thrift\StringFunc\Mbstring;
use Thrift\StringFunc\Core;

class TStringFuncFactory {
    private static $_instance;

    /**
     * Get the Singleton instance of TStringFunc implementation that is
     * compatible with the current system's mbstring.func_overload settings.
     *
     * @return TStringFunc
     */
    public static function create() {
        if(!self::$_instance) {
            self::_setInstance();
        }

        return self::$_instance;
    }

    private static function _setInstance() {
        /**
         * Cannot use str* functions for byte counting because multibyte
         * characters will be read a single bytes.
         *
         * See: http://us.php.net/manual/en/mbstring.overload.php
         */
        if(ini_get('mbstring.func_overload') & 2) {
            self::$_instance = new Mbstring();
        }
        /**
         * mbstring is not installed or does not have function overloading
         * of the str* functions enabled so use PHP core str* functions for
         * byte counting.
         */
        else {
            self::$_instance = new Core();
        }
    }
}<?php

namespace Thrift\Factory;

use Thrift\Transport\TTransport;

class TTransportFactory {
  /**
   * @static
   * @param TTransport $transport
   * @return TTransport
   */
  public static function getTransport(TTransport $transport) {
    return $transport;
  }
}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.protocol
 */

namespace Thrift\Protocol\JSON;

class BaseContext
{
    function escapeNum()
    {
        return false;
    }

    function write()
    {
    }

    function read()
    {
    }
}<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.protocol
 */

namespace Thrift\Protocol\JSON;

use Thrift\Protocol\JSON\BaseContext;
use Thrift\Protocol\TJSONProtocol;

class ListContext extends BaseContext
{
    private $first_ = true;
    private $p_;

    public function __construct($p) {
        $this->p_ = $p;
    }

    public function write() {
        if ($this->first_) {
            $this->first_ = false;
        } else {
            $this->p_->getTransport()->write(TJSONProtocol::COMMA);
        }
    }

    public function read() {
        if ($this->first_) {
            $this->first_ = false;
        } else {
            $this->p_->readJSONSyntaxChar(TJSONProtocol::COMMA);
        }
    }
}<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.protocol
 */

namespace Thrift\Protocol\JSON;

class LookaheadReader
{
    private $hasData_ = false;
    private $data_ = array();
    private $p_;

    public function __construct($p)
    {
        $this->p_ = $p;
    }

    public function read() {
        if ($this->hasData_) {
            $this->hasData_ = false;
        } else {
            $this->data_ = $this->p_->getTransport()->readAll(1);
        }

        return substr($this->data_, 0, 1);
    }

    public function peek() {
        if (!$this->hasData_) {
            $this->data_ = $this->p_->getTransport()->readAll(1);
        }

        $this->hasData_ = true;
        return substr($this->data_, 0, 1);
    }
}<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.protocol
 */

namespace Thrift\Protocol\JSON;

use Thrift\Protocol\JSON\BaseContext;
use Thrift\Protocol\TJSONProtocol;

class PairContext extends BaseContext {
    private $first_ = true;
    private $colon_ = true;
    private $p_ = null;

    public function __construct($p) {
        $this->p_ = $p;
    }

    public function write() {
        if ($this->first_) {
            $this->first_ = false;
            $this->colon_ = true;
        } else {
            $this->p_->getTransport()->write($this->colon_ ? TJSONProtocol::COLON : TJSONProtocol::COMMA);
            $this->colon_ = !$this->colon_;
        }
    }

    public function read() {
        if ($this->first_) {
            $this->first_ = false;
            $this->colon_ = true;
        } else {
            $this->p_->readJSONSyntaxChar($this->colon_ ? TJSONProtocol::COLON : TJSONProtocol::COMMA);
            $this->colon_ = !$this->colon_;
        }
    }

    public function escapeNum() {
        return $this->colon_;
    }
}<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.protocol
 */

namespace Thrift\Protocol;

use Thrift\Protocol\TProtocol;
use Thrift\Type\TType;
use Thrift\Exception\TProtocolException;
use Thrift\Factory\TStringFuncFactory;

/**
 * Binary implementation of the Thrift protocol.
 *
 */
class TBinaryProtocol extends TProtocol {

  const VERSION_MASK = 0xffff0000;
  const VERSION_1 = 0x80010000;

  protected $strictRead_ = false;
  protected $strictWrite_ = true;

  public function __construct($trans, $strictRead=false, $strictWrite=true) {
    parent::__construct($trans);
    $this->strictRead_ = $strictRead;
    $this->strictWrite_ = $strictWrite;
  }

  public function writeMessageBegin($name, $type, $seqid) {
    if ($this->strictWrite_) {
      $version = self::VERSION_1 | $type;
      return
        $this->writeI32($version) +
        $this->writeString($name) +
        $this->writeI32($seqid);
    } else {
      return
        $this->writeString($name) +
        $this->writeByte($type) +
        $this->writeI32($seqid);
    }
  }

  public function writeMessageEnd() {
    return 0;
  }

  public function writeStructBegin($name) {
    return 0;
  }

  public function writeStructEnd() {
    return 0;
  }

  public function writeFieldBegin($fieldName, $fieldType, $fieldId) {
    return
      $this->writeByte($fieldType) +
      $this->writeI16($fieldId);
  }

  public function writeFieldEnd() {
    return 0;
  }

  public function writeFieldStop() {
    return
      $this->writeByte(TType::STOP);
  }

  public function writeMapBegin($keyType, $valType, $size) {
    return
      $this->writeByte($keyType) +
      $this->writeByte($valType) +
      $this->writeI32($size);
  }

  public function writeMapEnd() {
    return 0;
  }

  public function writeListBegin($elemType, $size) {
    return
      $this->writeByte($elemType) +
      $this->writeI32($size);
  }

  public function writeListEnd() {
    return 0;
  }

  public function writeSetBegin($elemType, $size) {
    return
      $this->writeByte($elemType) +
      $this->writeI32($size);
  }

  public function writeSetEnd() {
    return 0;
  }

  public function writeBool($value) {
    $data = pack('c', $value ? 1 : 0);
    $this->trans_->write($data, 1);
    return 1;
  }

  public function writeByte($value) {
    $data = pack('c', $value);
    $this->trans_->write($data, 1);
    return 1;
  }

  public function writeI16($value) {
    $data = pack('n', $value);
    $this->trans_->write($data, 2);
    return 2;
  }

  public function writeI32($value) {
    $data = pack('N', $value);
    $this->trans_->write($data, 4);
    return 4;
  }

  public function writeI64($value) {
    // If we are on a 32bit architecture we have to explicitly deal with
    // 64-bit twos-complement arithmetic since PHP wants to treat all ints
    // as signed and any int over 2^31 - 1 as a float
    if (PHP_INT_SIZE == 4) {
      $neg = $value < 0;

      if ($neg) {
        $value *= -1;
      }

      $hi = (int)($value / 4294967296);
      $lo = (int)$value;

      if ($neg) {
        $hi = ~$hi;
        $lo = ~$lo;
        if (($lo & (int)0xffffffff) == (int)0xffffffff) {
          $lo = 0;
          $hi++;
        } else {
          $lo++;
        }
      }
      $data = pack('N2', $hi, $lo);

    } else {
      $hi = $value >> 32;
      $lo = $value & 0xFFFFFFFF;
      $data = pack('N2', $hi, $lo);
    }

    $this->trans_->write($data, 8);
    return 8;
  }

  public function writeDouble($value) {
    $data = pack('d', $value);
    $this->trans_->write(strrev($data), 8);
    return 8;
  }

  public function writeString($value) {
    $len = TStringFuncFactory::create()->strlen($value);
    $result = $this->writeI32($len);
    if ($len) {
      $this->trans_->write($value, $len);
    }
    return $result + $len;
  }

  public function readMessageBegin(&$name, &$type, &$seqid) {
    $result = $this->readI32($sz);
    if ($sz < 0) {
      $version = (int) ($sz & self::VERSION_MASK);
      if ($version != (int) self::VERSION_1) {
        throw new TProtocolException('Bad version identifier: '.$sz, TProtocolException::BAD_VERSION);
      }
      $type = $sz & 0x000000ff;
      $result +=
        $this->readString($name) +
        $this->readI32($seqid);
    } else {
      if ($this->strictRead_) {
        throw new TProtocolException('No version identifier, old protocol client?', TProtocolException::BAD_VERSION);
      } else {
        // Handle pre-versioned input
        $name = $this->trans_->readAll($sz);
        $result +=
          $sz +
          $this->readByte($type) +
          $this->readI32($seqid);
      }
    }
    return $result;
  }

  public function readMessageEnd() {
    return 0;
  }

  public function readStructBegin(&$name) {
    $name = '';
    return 0;
  }

  public function readStructEnd() {
    return 0;
  }

  public function readFieldBegin(&$name, &$fieldType, &$fieldId) {
    $result = $this->readByte($fieldType);
    if ($fieldType == TType::STOP) {
      $fieldId = 0;
      return $result;
    }
    $result += $this->readI16($fieldId);
    return $result;
  }

  public function readFieldEnd() {
    return 0;
  }

  public function readMapBegin(&$keyType, &$valType, &$size) {
    return
      $this->readByte($keyType) +
      $this->readByte($valType) +
      $this->readI32($size);
  }

  public function readMapEnd() {
    return 0;
  }

  public function readListBegin(&$elemType, &$size) {
    return
      $this->readByte($elemType) +
      $this->readI32($size);
  }

  public function readListEnd() {
    return 0;
  }

  public function readSetBegin(&$elemType, &$size) {
    return
      $this->readByte($elemType) +
      $this->readI32($size);
  }

  public function readSetEnd() {
    return 0;
  }

  public function readBool(&$value) {
    $data = $this->trans_->readAll(1);
    $arr = unpack('c', $data);
    $value = $arr[1] == 1;
    return 1;
  }

  public function readByte(&$value) {
    $data = $this->trans_->readAll(1);
    $arr = unpack('c', $data);
    $value = $arr[1];
    return 1;
  }

  public function readI16(&$value) {
    $data = $this->trans_->readAll(2);
    $arr = unpack('n', $data);
    $value = $arr[1];
    if ($value > 0x7fff) {
      $value = 0 - (($value - 1) ^ 0xffff);
    }
    return 2;
  }

  public function readI32(&$value) {
    $data = $this->trans_->readAll(4);
    $arr = unpack('N', $data);
    $value = $arr[1];
    if ($value > 0x7fffffff) {
      $value = 0 - (($value - 1) ^ 0xffffffff);
    }
    return 4;
  }

  public function readI64(&$value) {
    $data = $this->trans_->readAll(8);

    $arr = unpack('N2', $data);

    // If we are on a 32bit architecture we have to explicitly deal with
    // 64-bit twos-complement arithmetic since PHP wants to treat all ints
    // as signed and any int over 2^31 - 1 as a float
    if (PHP_INT_SIZE == 4) {

      $hi = $arr[1];
      $lo = $arr[2];
      $isNeg = $hi  < 0;

      // Check for a negative
      if ($isNeg) {
        $hi = ~$hi & (int)0xffffffff;
        $lo = ~$lo & (int)0xffffffff;

        if ($lo == (int)0xffffffff) {
          $hi++;
          $lo = 0;
        } else {
          $lo++;
        }
      }

      // Force 32bit words in excess of 2G to pe positive - we deal wigh sign
      // explicitly below

      if ($hi & (int)0x80000000) {
        $hi &= (int)0x7fffffff;
        $hi += 0x80000000;
      }

      if ($lo & (int)0x80000000) {
        $lo &= (int)0x7fffffff;
        $lo += 0x80000000;
      }

      $value = $hi * 4294967296 + $lo;

      if ($isNeg) {
        $value = 0 - $value;
      }
    } else {

      // Upcast negatives in LSB bit
      if ($arr[2] & 0x80000000) {
        $arr[2] = $arr[2] & 0xffffffff;
      }

      // Check for a negative
      if ($arr[1] & 0x80000000) {
        $arr[1] = $arr[1] & 0xffffffff;
        $arr[1] = $arr[1] ^ 0xffffffff;
        $arr[2] = $arr[2] ^ 0xffffffff;
        $value = 0 - $arr[1]*4294967296 - $arr[2] - 1;
      } else {
        $value = $arr[1]*4294967296 + $arr[2];
      }
    }

    return 8;
  }

  public function readDouble(&$value) {
    $data = strrev($this->trans_->readAll(8));
    $arr = unpack('d', $data);
    $value = $arr[1];
    return 8;
  }

  public function readString(&$value) {
    $result = $this->readI32($len);
    if ($len) {
      $value = $this->trans_->readAll($len);
    } else {
      $value = '';
    }
    return $result + $len;
  }
}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.protocol
 */

namespace Thrift\Protocol;

use Thrift\Protocol\TBinaryProtocol;
use Thrift\Transport\TBufferedTransport;

/**
 * Accelerated binary protocol: used in conjunction with the thrift_protocol
 * extension for faster deserialization
 */
class TBinaryProtocolAccelerated extends TBinaryProtocol {
  public function __construct($trans, $strictRead=false, $strictWrite=true) {
    // If the transport doesn't implement putBack, wrap it in a
    // TBufferedTransport (which does)
    
    // NOTE (t.heintz): This is very evil to do, because the TBufferedTransport may swallow bytes, which
    // are then never written to the underlying transport. This happens precisely when a number of bytes
    // less than the max buffer size (512 by default) is written to the transport and then flush() is NOT
    // called. In that case the data stays in the writeBuffer of the transport, from where it can never be
    // accessed again (for example through read()).
    //
    // Since the caller of this method does not know about the wrapping transport, this creates bugs which
    // are very difficult to find. Hence the wrapping of a transport in a buffer should be left to the
    // calling code. An interface could used to mandate the presence of the putBack() method in the transport.
    //
    // I am leaving this code in nonetheless, because there may be applications depending on this behavior.
    //
    // @see THRIFT-1579
    
    if (!method_exists($trans, 'putBack')) {
      $trans = new TBufferedTransport($trans);
    }
    parent::__construct($trans, $strictRead, $strictWrite);
  }
  public function isStrictRead() {
    return $this->strictRead_;
  }
  public function isStrictWrite() {
    return $this->strictWrite_;
  }
}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.protocol
 */

namespace Thrift\Protocol;

use Thrift\Protocol\TProtocol;
use Thrift\Type\TType;
use Thrift\Exception\TProtocolException;
use Thrift\Factory\TStringFuncFactory;

/**
 * Compact implementation of the Thrift protocol.
 *
 */
class TCompactProtocol extends TProtocol {

  const COMPACT_STOP = 0x00;
  const COMPACT_TRUE = 0x01;
  const COMPACT_FALSE = 0x02;
  const COMPACT_BYTE = 0x03;
  const COMPACT_I16 = 0x04;
  const COMPACT_I32 = 0x05;
  const COMPACT_I64 = 0x06;
  const COMPACT_DOUBLE = 0x07;
  const COMPACT_BINARY = 0x08;
  const COMPACT_LIST = 0x09;
  const COMPACT_SET = 0x0A;
  const COMPACT_MAP = 0x0B;
  const COMPACT_STRUCT = 0x0C;

  const STATE_CLEAR = 0;
  const STATE_FIELD_WRITE = 1;
  const STATE_VALUE_WRITE = 2;
  const STATE_CONTAINER_WRITE = 3;
  const STATE_BOOL_WRITE = 4;
  const STATE_FIELD_READ = 5;
  const STATE_CONTAINER_READ = 6;
  const STATE_VALUE_READ = 7;
  const STATE_BOOL_READ = 8;

  const VERSION_MASK = 0x1f;
  const VERSION = 1;
  const PROTOCOL_ID = 0x82;
  const TYPE_MASK = 0xe0;
  const TYPE_BITS = 0x07;
  const TYPE_SHIFT_AMOUNT = 5;

  protected static $ctypes = array(
    TType::STOP => TCompactProtocol::COMPACT_STOP,
    TType::BOOL => TCompactProtocol::COMPACT_TRUE, // used for collection
    TType::BYTE => TCompactProtocol::COMPACT_BYTE,
    TType::I16 => TCompactProtocol::COMPACT_I16,
    TType::I32 => TCompactProtocol::COMPACT_I32,
    TType::I64 => TCompactProtocol::COMPACT_I64,
    TType::DOUBLE => TCompactProtocol::COMPACT_DOUBLE,
    TType::STRING => TCompactProtocol::COMPACT_BINARY,
    TType::STRUCT => TCompactProtocol::COMPACT_STRUCT,
    TType::LST => TCompactProtocol::COMPACT_LIST,
    TType::SET => TCompactProtocol::COMPACT_SET,
    TType::MAP => TCompactProtocol::COMPACT_MAP,
  );

  protected static $ttypes = array(
    TCompactProtocol::COMPACT_STOP => TType::STOP ,
    TCompactProtocol::COMPACT_TRUE => TType::BOOL, // used for collection
    TCompactProtocol::COMPACT_FALSE => TType::BOOL,
    TCompactProtocol::COMPACT_BYTE => TType::BYTE,
    TCompactProtocol::COMPACT_I16 => TType::I16,
    TCompactProtocol::COMPACT_I32 => TType::I32,
    TCompactProtocol::COMPACT_I64 => TType::I64,
    TCompactProtocol::COMPACT_DOUBLE => TType::DOUBLE,
    TCompactProtocol::COMPACT_BINARY => TType::STRING,
    TCompactProtocol::COMPACT_STRUCT => TType::STRUCT,
    TCompactProtocol::COMPACT_LIST => TType::LST,
    TCompactProtocol::COMPACT_SET => TType::SET,
    TCompactProtocol::COMPACT_MAP => TType::MAP,
  );

  protected $state = TCompactProtocol::STATE_CLEAR;
  protected $lastFid = 0;
  protected $boolFid = null;
  protected $boolValue = null;
  protected $structs = array();
  protected $containers = array();

  // Some varint / zigzag helper methods
  public function toZigZag($n, $bits) {
    return ($n << 1) ^ ($n >> ($bits - 1));
  }

  public function fromZigZag($n) {
    return ($n >> 1) ^ -($n & 1);
  }

  public function getVarint($data) {
    $out = "";
    while (true) {
      if (($data & ~0x7f) === 0) {
        $out .= chr($data);
        break;
      } else {
        $out .= chr(($data & 0xff) | 0x80);
        $data = $data >> 7;
      }
    }
    return $out;
  }

  public function writeVarint($data) {
    $out = $this->getVarint($data);
    $result = TStringFuncFactory::create()->strlen($out);
    $this->trans_->write($out, $result);
    return $result;
  }

  public function readVarint(&$result) {
    $idx = 0;
    $shift = 0;
    $result = 0;
    while (true) {
      $x = $this->trans_->readAll(1);
      $arr = unpack('C', $x);
      $byte = $arr[1];
      $idx += 1;
      $result |= ($byte & 0x7f) << $shift;
      if (($byte >> 7) === 0) {
        return $idx;
      }
      $shift += 7;
    }

    return $idx;
  }

  public function __construct($trans) {
    parent::__construct($trans);
  }

  public function writeMessageBegin($name, $type, $seqid) {
    $written =
      $this->writeUByte(TCompactProtocol::PROTOCOL_ID) +
      $this->writeUByte(TCompactProtocol::VERSION |
                        ($type << TCompactProtocol::TYPE_SHIFT_AMOUNT)) +
      $this->writeVarint($seqid) +
      $this->writeString($name);
    $this->state = TCompactProtocol::STATE_VALUE_WRITE;
    return $written;
  }

  public function writeMessageEnd() {
    $this->state = TCompactProtocol::STATE_CLEAR;
    return 0;
  }

  public function writeStructBegin($name) {
    $this->structs[] = array($this->state, $this->lastFid);
    $this->state = TCompactProtocol::STATE_FIELD_WRITE;
    $this->lastFid = 0;
    return 0;
  }

  public function writeStructEnd() {
    $old_values = array_pop($this->structs);
    $this->state = $old_values[0];
    $this->lastFid = $old_values[1];
    return 0;
  }

  public function writeFieldStop() {
    return $this->writeByte(0);
  }

  public function writeFieldHeader($type, $fid) {
    $written = 0;
    $delta = $fid - $this->lastFid;
    if (0 < $delta && $delta <= 15) {
      $written = $this->writeUByte(($delta << 4) | $type);
    } else {
      $written = $this->writeByte($type) +
        $this->writeI16($fid);
    }
    $this->lastFid = $fid;
    return $written;
  }

  public function writeFieldBegin($field_name, $field_type, $field_id) {
    if ($field_type == TTYPE::BOOL) {
      $this->state = TCompactProtocol::STATE_BOOL_WRITE;
      $this->boolFid = $field_id;
      return 0;
    } else {
      $this->state = TCompactProtocol::STATE_VALUE_WRITE;
      return $this->writeFieldHeader(self::$ctypes[$field_type], $field_id);
    }
  }

  public function writeFieldEnd() {
    $this->state = TCompactProtocol::STATE_FIELD_WRITE;
    return 0;
  }

  public function writeCollectionBegin($etype, $size) {
    $written = 0;
    if ($size <= 14) {
      $written = $this->writeUByte($size << 4 |
                                    self::$ctypes[$etype]);
    } else {
      $written = $this->writeUByte(0xf0 |
                                   self::$ctypes[$etype]) +
        $this->writeVarint($size);
    }
    $this->containers[] = $this->state;
    $this->state = TCompactProtocol::STATE_CONTAINER_WRITE;

    return $written;
  }

  public function writeMapBegin($key_type, $val_type, $size) {
    $written = 0;
    if ($size == 0) {
      $written = $this->writeByte(0);
    } else {
      $written = $this->writeVarint($size) +
        $this->writeUByte(self::$ctypes[$key_type] << 4 |
                          self::$ctypes[$val_type]);
    }
    $this->containers[] = $this->state;
    return $written;
  }

  public function writeCollectionEnd() {
    $this->state = array_pop($this->containers);
    return 0;
  }

  public function writeMapEnd() {
    return $this->writeCollectionEnd();
  }

  public function writeListBegin($elem_type, $size) {
    return $this->writeCollectionBegin($elem_type, $size);
  }

  public function writeListEnd() {
    return $this->writeCollectionEnd();
  }

  public function writeSetBegin($elem_type, $size) {
    return $this->writeCollectionBegin($elem_type, $size);
  }

  public function writeSetEnd() {
    return $this->writeCollectionEnd();
  }

  public function writeBool($value) {
    if ($this->state == TCompactProtocol::STATE_BOOL_WRITE) {
      $ctype = TCompactProtocol::COMPACT_FALSE;
      if ($value) {
        $ctype = TCompactProtocol::COMPACT_TRUE;
      }
      return $this->writeFieldHeader($ctype, $this->boolFid);
    } else if ($this->state == TCompactProtocol::STATE_CONTAINER_WRITE) {
      return $this->writeByte($value ? 1 : 0);
    } else {
      throw new TProtocolException('Invalid state in compact protocol');
    }
  }

  public function writeByte($value) {
    $data = pack('c', $value);
    $this->trans_->write($data, 1);
    return 1;
  }

  public function writeUByte($byte) {
    $this->trans_->write(pack('C', $byte), 1);
    return 1;
  }

  public function writeI16($value) {
    $thing = $this->toZigZag($value, 16);
    return $this->writeVarint($thing);
  }

  public function writeI32($value) {
    $thing = $this->toZigZag($value, 32);
    return $this->writeVarint($thing);
  }

  public function writeDouble($value) {
    $data = pack('d', $value);
    $this->trans_->write($data, 8);
    return 8;
  }

  public function writeString($value) {
    $len = TStringFuncFactory::create()->strlen($value);
    $result = $this->writeVarint($len);
    if ($len) {
      $this->trans_->write($value, $len);
    }
    return $result + $len;
  }

  public function readFieldBegin(&$name, &$field_type, &$field_id) {
    $result = $this->readUByte($field_type);

    if (($field_type & 0x0f) == TType::STOP) {
      $field_id = 0;
      return $result;
    }
    $delta = $field_type >> 4;
    if ($delta == 0) {
      $result += $this->readI16($field_id);
    } else {
      $field_id = $this->lastFid + $delta;
    }
    $this->lastFid = $field_id;
    $field_type = $this->getTType($field_type & 0x0f);
    if ($field_type == TCompactProtocol::COMPACT_TRUE) {
      $this->state = TCompactProtocol::STATE_BOOL_READ;
      $this->boolValue = true;
    } else if ($field_type == TCompactProtocol::COMPACT_FALSE) {
      $this->state = TCompactProtocol::STATE_BOOL_READ;
      $this->boolValue = false;
    } else {
      $this->state = TCompactProtocol::STATE_VALUE_READ;
    }
    return $result;
  }

  public function readFieldEnd() {
    $this->state = TCompactProtocol::STATE_FIELD_READ;
    return 0;
  }

  public function readUByte(&$value) {
    $data = $this->trans_->readAll(1);
    $arr = unpack('C', $data);
    $value = $arr[1];
    return 1;
  }

  public function readByte(&$value) {
    $data = $this->trans_->readAll(1);
    $arr = unpack('c', $data);
    $value = $arr[1];
    return 1;
  }

  public function readZigZag(&$value) {
    $result = $this->readVarint($value);
    $value = $this->fromZigZag($value);
    return $result;
  }

  public function readMessageBegin(&$name, &$type, &$seqid) {
    $protoId = 0;
    $result = $this->readUByte($protoId);
    if ($protoId != TCompactProtocol::PROTOCOL_ID) {
      throw new TProtocolException('Bad protocol id in TCompact message');
    }
    $verType = 0;
    $result += $this->readUByte($verType);
    $type = ($verType >> TCompactProtocol::TYPE_SHIFT_AMOUNT) & TCompactProtocol::TYPE_BITS;
    $version = $verType & TCompactProtocol::VERSION_MASK;
    if ($version != TCompactProtocol::VERSION) {
      throw new TProtocolException('Bad version in TCompact message');
    }
    $result += $this->readVarint($seqid);
    $result += $this->readString($name);

    return $result;
  }

  public function readMessageEnd() {
    return 0;
  }

  public function readStructBegin(&$name) {
    $name = ''; // unused
    $this->structs[] = array($this->state, $this->lastFid);
    $this->state = TCompactProtocol::STATE_FIELD_READ;
    $this->lastFid = 0;
    return 0;
  }

  public function readStructEnd() {
    $last = array_pop($this->structs);
    $this->state = $last[0];
    $this->lastFid = $last[1];
    return 0;
  }

  public function readCollectionBegin(&$type, &$size) {
    $sizeType = 0;
    $result = $this->readUByte($sizeType);
    $size = $sizeType >> 4;
    $type = $this->getTType($sizeType);
    if ($size == 15) {
      $result += $this->readVarint($size);
    }
    $this->containers[] = $this->state;
    $this->state = TCompactProtocol::STATE_CONTAINER_READ;

    return $result;
  }

  public function readMapBegin(&$key_type, &$val_type, &$size) {
    $result = $this->readVarint($size);
    $types = 0;
    if ($size > 0) {
      $result += $this->readUByte($types);
    }
    $val_type = $this->getTType($types);
    $key_type = $this->getTType($types >> 4);
    $this->containers[] = $this->state;
    $this->state = TCompactProtocol::STATE_CONTAINER_READ;

    return $result;
  }

  public function readCollectionEnd() {
    $this->state = array_pop($this->containers);
    return 0;
  }

  public function readMapEnd() {
    return $this->readCollectionEnd();
  }

  public function readListBegin(&$elem_type, &$size) {
    return $this->readCollectionBegin($elem_type, $size);
  }

  public function readListEnd() {
    return $this->readCollectionEnd();
  }

  public function readSetBegin(&$elem_type, &$size) {
    return $this->readCollectionBegin($elem_type, $size);
  }

  public function readSetEnd() {
    return $this->readCollectionEnd();
  }

  public function readBool(&$value) {
    if ($this->state == TCompactProtocol::STATE_BOOL_READ) {
      $value = $this->boolValue;
      return 0;
    } else if ($this->state == TCompactProtocol::STATE_CONTAINER_READ) {
      return $this->readByte($value);
    } else {
      throw new TProtocolException('Invalid state in compact protocol');
    }
  }

  public function readI16(&$value) {
    return $this->readZigZag($value);
  }

  public function readI32(&$value) {
    return $this->readZigZag($value);
  }

  public function readDouble(&$value) {
    $data = $this->trans_->readAll(8);
    $arr = unpack('d', $data);
    $value = $arr[1];
    return 8;
  }

  public function readString(&$value) {
    $result = $this->readVarint($len);
    if ($len) {
      $value = $this->trans_->readAll($len);
    } else {
      $value = '';
    }
    return $result + $len;
  }

  public function getTType($byte) {
    return self::$ttypes[$byte & 0x0f];
  }

  // If we are on a 32bit architecture we have to explicitly deal with
  // 64-bit twos-complement arithmetic since PHP wants to treat all ints
  // as signed and any int over 2^31 - 1 as a float

  // Read and write I64 as two 32 bit numbers $hi and $lo

  public function readI64(&$value) {
    // Read varint from wire
    $hi = 0;
    $lo = 0;

    $idx = 0;
    $shift = 0;

    while (true) {
      $x = $this->trans_->readAll(1);
      $arr = unpack('C', $x);
      $byte = $arr[1];
      $idx += 1;
      if ($shift < 32) {
        $lo |= (($byte & 0x7f) << $shift) &
          0x00000000ffffffff;
      }
      // Shift hi and lo together.
      if ($shift >= 32) {
        $hi |= (($byte & 0x7f) << ($shift - 32));
      } else if ($shift > 25) {
        $hi |= (($byte & 0x7f) >> ($shift - 25));
      }
      if (($byte >> 7) === 0) {
        break;
      }
      $shift += 7;
    }

    // Now, unzig it.
    $xorer = 0;
    if ($lo & 1) {
      $xorer = 0xffffffff;
    }
    $lo = ($lo >> 1) & 0x7fffffff;
    $lo = $lo | (($hi & 1) << 31);
    $hi = ($hi >> 1) ^ $xorer;
    $lo = $lo ^ $xorer;

    // Now put $hi and $lo back together
    if (true) {
      $isNeg = $hi  < 0;

      // Check for a negative
      if ($isNeg) {
        $hi = ~$hi & (int)0xffffffff;
        $lo = ~$lo & (int)0xffffffff;

        if ($lo == (int)0xffffffff) {
          $hi++;
          $lo = 0;
        } else {
          $lo++;
        }
      }

      // Force 32bit words in excess of 2G to be positive - we deal with sign
      // explicitly below

      if ($hi & (int)0x80000000) {
        $hi &= (int)0x7fffffff;
        $hi += 0x80000000;
      }

      if ($lo & (int)0x80000000) {
        $lo &= (int)0x7fffffff;
        $lo += 0x80000000;
      }

      $value = $hi * 4294967296 + $lo;

      if ($isNeg) {
        $value = 0 - $value;
      }
    } else {

      // Upcast negatives in LSB bit
      if ($arr[2] & 0x80000000) {
        $arr[2] = $arr[2] & 0xffffffff;
      }

      // Check for a negative
      if ($arr[1] & 0x80000000) {
        $arr[1] = $arr[1] & 0xffffffff;
        $arr[1] = $arr[1] ^ 0xffffffff;
        $arr[2] = $arr[2] ^ 0xffffffff;
        $value = 0 - $arr[1] * 4294967296 - $arr[2] - 1;
      } else {
        $value = $arr[1] * 4294967296 + $arr[2];
      }
    }

    return $idx;
  }

  public function writeI64($value) {
    // If we are in an I32 range, use the easy method below.
    if (($value > 4294967296) || ($value < -4294967296)) {
      // Convert $value to $hi and $lo
      $neg = $value < 0;

      if ($neg) {
        $value *= -1;
      }

      $hi = (int)$value >> 32;
      $lo = (int)$value & 0xffffffff;

      if ($neg) {
        $hi = ~$hi;
        $lo = ~$lo;
        if (($lo & (int)0xffffffff) == (int)0xffffffff) {
          $lo = 0;
          $hi++;
        } else {
          $lo++;
        }
      }

      // Now do the zigging and zagging.
      $xorer = 0;
      if ($neg) {
        $xorer = 0xffffffff;
      }
      $lowbit = ($lo >> 31) & 1;
      $hi = ($hi << 1) | $lowbit;
      $lo = ($lo << 1);
      $lo = ($lo ^ $xorer) & 0xffffffff;
      $hi = ($hi ^ $xorer) & 0xffffffff;

      // now write out the varint, ensuring we shift both hi and lo
      $out = "";
      while (true) {
        if (($lo & ~0x7f) === 0 &&
           $hi === 0) {
          $out .= chr($lo);
          break;
        } else {
          $out .= chr(($lo & 0xff) | 0x80);
          $lo = $lo >> 7;
          $lo = $lo | ($hi << 25);
          $hi = $hi >> 7;
          // Right shift carries sign, but we don't want it to.
          $hi = $hi & (127 << 25);
        }
      }

      $ret = TStringFuncFactory::create()->strlen($out);
      $this->trans_->write($out, $ret);

      return $ret;
    } else {
      return $this->writeVarint($this->toZigZag($value, 64));
    }
  }
}
<?php

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.protocol
 */

namespace Thrift\Protocol;

use Thrift\Protocol\TProtocol;
use Thrift\Type\TType;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\JSON\BaseContext;
use Thrift\Protocol\JSON\LookaheadReader;
use Thrift\Protocol\JSON\PairContext;
use Thrift\Protocol\JSON\ListContext;

/**
 * JSON implementation of thrift protocol, ported from Java.
 */
class TJSONProtocol extends TProtocol
{
    const COMMA = ',';
    const COLON = ':';
    const LBRACE = '{';
    const RBRACE = '}';
    const LBRACKET = '[';
    const RBRACKET = ']';
    const QUOTE = '"';
    const BACKSLASH = '\\';
    const ZERO = '0';
    const ESCSEQ = '\\';
    const DOUBLEESC = '__DOUBLE_ESCAPE_SEQUENCE__';

    const VERSION = 1;

    public static $JSON_CHAR_TABLE = array(
        /*  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F */
        0, 0, 0, 0, 0, 0, 0, 0, 'b', 't', 'n', 0, 'f', 'r', 0, 0, // 0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 1
        1, 1, '"', 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 2
    );

    public static $ESCAPE_CHARS = array('"', '\\', '/', "b", "f", "n", "r", "t");

    public static $ESCAPE_CHAR_VALS = array(
        '"', '\\', '/', "\x08", "\f", "\n", "\r", "\t",
    );

    const NAME_BOOL = "tf";
    const NAME_BYTE = "i8";
    const NAME_I16 = "i16";
    const NAME_I32 = "i32";
    const NAME_I64 = "i64";
    const NAME_DOUBLE = "dbl";
    const NAME_STRUCT = "rec";
    const NAME_STRING = "str";
    const NAME_MAP = "map";
    const NAME_LIST = "lst";
    const NAME_SET = "set";

    private function getTypeNameForTypeID($typeID)
    {
        switch ($typeID) {
            case TType::BOOL:
                return self::NAME_BOOL;
            case TType::BYTE:
                return self::NAME_BYTE;
            case TType::I16:
                return self::NAME_I16;
            case TType::I32:
                return self::NAME_I32;
            case TType::I64:
                return self::NAME_I64;
            case TType::DOUBLE:
                return self::NAME_DOUBLE;
            case TType::STRING:
                return self::NAME_STRING;
            case TType::STRUCT:
                return self::NAME_STRUCT;
            case TType::MAP:
                return self::NAME_MAP;
            case TType::SET:
                return self::NAME_SET;
            case TType::LST:
                return self::NAME_LIST;
            default:
                throw new TProtocolException("Unrecognized type", TProtocolException::UNKNOWN);
        }
    }

    private function getTypeIDForTypeName($name)
    {
        $result = TType::STOP;

        if (strlen($name) > 1) {
            switch (substr($name, 0, 1)) {
                case 'd':
                    $result = TType::DOUBLE;
                    break;
                case 'i':
                    switch (substr($name, 1, 1)) {
                        case '8':
                            $result = TType::BYTE;
                            break;
                        case '1':
                            $result = TType::I16;
                            break;
                        case '3':
                            $result = TType::I32;
                            break;
                        case '6':
                            $result = TType::I64;
                            break;
                    }
                    break;
                case 'l':
                    $result = TType::LST;
                    break;
                case 'm':
                    $result = TType::MAP;
                    break;
                case 'r':
                    $result = TType::STRUCT;
                    break;
                case 's':
                    if (substr($name, 1, 1) == 't') {
                        $result = TType::STRING;
                    }
                    else if (substr($name, 1, 1) == 'e') {
                        $result = TType::SET;
                    }
                    break;
                case 't':
                    $result = TType::BOOL;
                    break;
            }
        }
        if ($result == TType::STOP) {
            throw new TProtocolException("Unrecognized type", TProtocolException::INVALID_DATA);
        }
        return $result;
    }

    public $contextStack_ = array();
    public $context_;
    public $reader_;

    private function pushContext($c) {
        array_push($this->contextStack_, $this->context_);
        $this->context_ = $c;
    }

    private function popContext() {
        $this->context_ = array_pop($this->contextStack_);
    }

    public function __construct($trans) {
        parent::__construct($trans);
        $this->context_ = new BaseContext();
        $this->reader_ = new LookaheadReader($this);
    }

    public function reset() {
        $this->contextStack_ = array();
        $this->context_ = new BaseContext();
        $this->reader_ = new LookaheadReader($this);
    }

    private $tmpbuf_ = array(4);

    public function readJSONSyntaxChar($b) {
        $ch = $this->reader_->read();

        if (substr($ch, 0, 1) != $b) {
            throw new TProtocolException("Unexpected character: " . $ch, TProtocolException::INVALID_DATA);
        }
    }

    private function hexVal($s) {
        for ($i = 0; $i < strlen($s); $i++) {
            $ch = substr($s, $i, 1);

            if (!($ch >= "a" && $ch <= "f") && !($ch >= "0" && $ch <= "9")) {
                throw new TProtocolException("Expected hex character " . $ch, TProtocolException::INVALID_DATA);
            }
        }

        return hexdec($s);
    }

    private function hexChar($val) {
        return dechex($val);
    }

    private function writeJSONString($b) {
        $this->context_->write();

        if (is_numeric($b) && $this->context_->escapeNum()) {
            $this->trans_->write(self::QUOTE);
        }

        $this->trans_->write(json_encode($b));

        if (is_numeric($b) && $this->context_->escapeNum()) {
            $this->trans_->write(self::QUOTE);
        }
    }

    private function writeJSONInteger($num) {
        $this->context_->write();

        if ($this->context_->escapeNum()) {
            $this->trans_->write(self::QUOTE);
        }

        $this->trans_->write($num);

        if ($this->context_->escapeNum()) {
            $this->trans_->write(self::QUOTE);
        }
    }

    private function writeJSONDouble($num) {
        $this->context_->write();

        if ($this->context_->escapeNum()) {
            $this->trans_->write(self::QUOTE);
        }

        $this->trans_->write(json_encode($num));

        if ($this->context_->escapeNum()) {
            $this->trans_->write(self::QUOTE);
        }
    }

    private function writeJSONBase64($data) {
        $this->context_->write();
        $this->trans_->write(self::QUOTE);
        $this->trans_->write(json_encode(base64_encode($data)));
        $this->trans_->write(self::QUOTE);
    }

    private function writeJSONObjectStart() {
      $this->context_->write();
      $this->trans_->write(self::LBRACE);
      $this->pushContext(new PairContext($this));
    }

    private function writeJSONObjectEnd() {
      $this->popContext();
      $this->trans_->write(self::RBRACE);
    }

    private function writeJSONArrayStart() {
      $this->context_->write();
      $this->trans_->write(self::LBRACKET);
      $this->pushContext(new ListContext($this));
    }

    private function writeJSONArrayEnd() {
      $this->popContext();
      $this->trans_->write(self::RBRACKET);
    }

    private function readJSONString($skipContext) {
      if (!$skipContext) {
        $this->context_->read();
      }

      $jsonString = '';
      $lastChar = NULL;
      while (true) {
        $ch = $this->reader_->read();
        $jsonString .= $ch;
        if ($ch == self::QUOTE &&
          $lastChar !== NULL &&
            $lastChar !== self::ESCSEQ) {
          break;
        }
        if ($ch == self::ESCSEQ && $lastChar == self::ESCSEQ) {
          $lastChar = self::DOUBLEESC;
        } else {
          $lastChar = $ch;
        }
      }
      return json_decode($jsonString);
    }

    private function isJSONNumeric($b) {
        switch ($b) {
            case '+':
            case '-':
            case '.':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'E':
            case 'e':
              return true;
            }
        return false;
    }

    private function readJSONNumericChars() {
        $strbld = array();

        while (true) {
            $ch = $this->reader_->peek();

            if (!$this->isJSONNumeric($ch)) {
                break;
            }

            $strbld[] = $this->reader_->read();
        }

        return implode("", $strbld);
    }

    private function readJSONInteger() {
        $this->context_->read();

        if ($this->context_->escapeNum()) {
            $this->readJSONSyntaxChar(self::QUOTE);
        }

        $str = $this->readJSONNumericChars();

        if ($this->context_->escapeNum()) {
            $this->readJSONSyntaxChar(self::QUOTE);
        }

        if (!is_numeric($str)) {
            throw new TProtocolException("Invalid data in numeric: " . $str, TProtocolException::INVALID_DATA);
        }

        return intval($str);
    }

    /**
     * Identical to readJSONInteger but without the final cast.
     * Needed for proper handling of i64 on 32 bit machines.  Why a
     * separate function?  So we don't have to force the rest of the
     * use cases through the extra conditional.
     */
    private function readJSONIntegerAsString() {
        $this->context_->read();

        if ($this->context_->escapeNum()) {
            $this->readJSONSyntaxChar(self::QUOTE);
        }

        $str = $this->readJSONNumericChars();

        if ($this->context_->escapeNum()) {
            $this->readJSONSyntaxChar(self::QUOTE);
        }

        if (!is_numeric($str)) {
            throw new TProtocolException("Invalid data in numeric: " . $str, TProtocolException::INVALID_DATA);
        }

        return $str;
    }

    private function readJSONDouble() {
        $this->context_->read();

        if (substr($this->reader_->peek(), 0, 1) == self::QUOTE) {
            $arr = $this->readJSONString(true);

            if ($arr == "NaN") {
                return NAN;
            } else if ($arr == "Infinity") {
                return INF;
            } else if (!$this->context_->escapeNum()) {
                throw new TProtocolException("Numeric data unexpectedly quoted " . $arr,
                                              TProtocolException::INVALID_DATA);
            }

            return floatval($arr);
        } else {
            if ($this->context_->escapeNum()) {
                $this->readJSONSyntaxChar(self::QUOTE);
            }

            return floatval($this->readJSONNumericChars());
        }
    }

    private function readJSONBase64() {
        $arr = $this->readJSONString(false);
        $data = base64_decode($arr, true);

        if ($data === false) {
            throw new TProtocolException("Invalid base64 data " . $arr, TProtocolException::INVALID_DATA);
        }

        return $data;
    }

    private function readJSONObjectStart() {
        $this->context_->read();
        $this->readJSONSyntaxChar(self::LBRACE);
        $this->pushContext(new PairContext($this));
    }

    private function readJSONObjectEnd() {
        $this->readJSONSyntaxChar(self::RBRACE);
        $this->popContext();
    }

    private function readJSONArrayStart()
    {
        $this->context_->read();
        $this->readJSONSyntaxChar(self::LBRACKET);
        $this->pushContext(new ListContext($this));
    }

    private function readJSONArrayEnd() {
        $this->readJSONSyntaxChar(self::RBRACKET);
        $this->popContext();
    }

    /**
     * Writes the message header
     *
     * @param string $name Function name
     * @param int $type message type TMessageType::CALL or TMessageType::REPLY
     * @param int $seqid The sequence id of this message
     */
    public function writeMessageBegin($name, $type, $seqid) {
        $this->writeJSONArrayStart();
        $this->writeJSONInteger(self::VERSION);
        $this->writeJSONString($name);
        $this->writeJSONInteger($type);
        $this->writeJSONInteger($seqid);
    }

    /**
     * Close the message
     */
    public function writeMessageEnd() {
        $this->writeJSONArrayEnd();
    }

    /**
     * Writes a struct header.
     *
     * @param string     $name Struct name
     * @throws TException on write error
     * @return int How many bytes written
     */
    public function writeStructBegin($name) {
        $this->writeJSONObjectStart();
    }

    /**
     * Close a struct.
     *
     * @throws TException on write error
     * @return int How many bytes written
     */
    public function writeStructEnd() {
        $this->writeJSONObjectEnd();
    }

    public function writeFieldBegin($fieldName, $fieldType, $fieldId) {
        $this->writeJSONInteger($fieldId);
        $this->writeJSONObjectStart();
        $this->writeJSONString($this->getTypeNameForTypeID($fieldType));
    }

    public function writeFieldEnd() {
        $this->writeJsonObjectEnd();
    }

    public function writeFieldStop() {
    }

    public function writeMapBegin($keyType, $valType, $size) {
        $this->writeJSONArrayStart();
        $this->writeJSONString($this->getTypeNameForTypeID($keyType));
        $this->writeJSONString($this->getTypeNameForTypeID($valType));
        $this->writeJSONInteger($size);
        $this->writeJSONObjectStart();
    }

    public function writeMapEnd() {
        $this->writeJSONObjectEnd();
        $this->writeJSONArrayEnd();
    }

    public function writeListBegin($elemType, $size) {
        $this->writeJSONArrayStart();
        $this->writeJSONString($this->getTypeNameForTypeID($elemType));
        $this->writeJSONInteger($size);
    }

    public function writeListEnd() {
        $this->writeJSONArrayEnd();
    }

    public function writeSetBegin($elemType, $size) {
        $this->writeJSONArrayStart();
        $this->writeJSONString($this->getTypeNameForTypeID($elemType));
        $this->writeJSONInteger($size);
    }

    public function writeSetEnd() {
        $this->writeJSONArrayEnd();
    }

    public function writeBool($bool) {
        $this->writeJSONInteger($bool ? 1 : 0);
    }

    public function writeByte($byte) {
        $this->writeJSONInteger($byte);
    }

    public function writeI16($i16) {
        $this->writeJSONInteger($i16);
    }

    public function writeI32($i32) {
        $this->writeJSONInteger($i32);
    }

    public function writeI64($i64) {
        $this->writeJSONInteger($i64);
    }

    public function writeDouble($dub) {
        $this->writeJSONDouble($dub);
    }

    public function writeString($str) {
        $this->writeJSONString($str);
    }

    /**
     * Reads the message header
     *
     * @param string $name Function name
     * @param int $type message type TMessageType::CALL or TMessageType::REPLY
     * @parem int $seqid The sequence id of this message
     */
    public function readMessageBegin(&$name, &$type, &$seqid) {
        $this->readJSONArrayStart();

        if ($this->readJSONInteger() != self::VERSION) {
            throw new TProtocolException("Message contained bad version", TProtocolException::BAD_VERSION);
        }

        $name = $this->readJSONString(false);
        $type = $this->readJSONInteger();
        $seqid = $this->readJSONInteger();

        return true;
    }

    /**
     * Read the close of message
     */
    public function readMessageEnd() {
        $this->readJSONArrayEnd();
    }

    public function readStructBegin(&$name) {
        $this->readJSONObjectStart();
        return 0;
    }

    public function readStructEnd() {
        $this->readJSONObjectEnd();
    }

    public function readFieldBegin(&$name, &$fieldType, &$fieldId) {
        $ch = $this->reader_->peek();
        $name = "";

        if (substr($ch, 0, 1) == self::RBRACE) {
            $fieldType = TType::STOP;
        } else {
            $fieldId = $this->readJSONInteger();
            $this->readJSONObjectStart();
            $fieldType = $this->getTypeIDForTypeName($this->readJSONString(false));
        }
    }

    public function readFieldEnd() {
        $this->readJSONObjectEnd();
    }

    public function readMapBegin(&$keyType, &$valType, &$size) {
        $this->readJSONArrayStart();
        $keyType = $this->getTypeIDForTypeName($this->readJSONString(false));
        $valType = $this->getTypeIDForTypeName($this->readJSONString(false));
        $size = $this->readJSONInteger();
        $this->readJSONObjectStart();
    }

    public function readMapEnd() {
        $this->readJSONObjectEnd();
        $this->readJSONArrayEnd();
    }

    public function readListBegin(&$elemType, &$size) {
        $this->readJSONArrayStart();
        $elemType = $this->getTypeIDForTypeName($this->readJSONString(false));
        $size = $this->readJSONInteger();
        return true;
    }

    public function readListEnd() {
        $this->readJSONArrayEnd();
    }

    public function readSetBegin(&$elemType, &$size) {
        $this->readJSONArrayStart();
        $elemType = $this->getTypeIDForTypeName($this->readJSONString(false));
        $size = $this->readJSONInteger();
        return true;
    }

    public function readSetEnd() {
        $this->readJSONArrayEnd();
    }

    public function readBool(&$bool) {
        $bool = $this->readJSONInteger() == 0 ? false : true;
        return true;
    }

    public function readByte(&$byte) {
        $byte = $this->readJSONInteger();
        return true;
    }

    public function readI16(&$i16) {
        $i16 = $this->readJSONInteger();
        return true;
    }

    public function readI32(&$i32) {
        $i32 = $this->readJSONInteger();
        return true;
    }

    public function readI64(&$i64) {
        if ( PHP_INT_SIZE === 4 ) {
            $i64 = $this->readJSONIntegerAsString();
        } else {
            $i64 = $this->readJSONInteger();
        }
        return true;
    }

    public function readDouble(&$dub) {
        $dub = $this->readJSONDouble();
        return true;
    }

    public function readString(&$str) {
        $str = $this->readJSONString(false);
        return true;
    }
}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.protocol
 */

namespace Thrift\Protocol;

use Thrift\Type\TMessageType;

/**
 * <code>TMultiplexedProtocol</code> is a protocol-independent concrete decorator
 * that allows a Thrift client to communicate with a multiplexing Thrift server,
 * by prepending the service name to the function name during function calls.
 *
 * @package Thrift\Protocol
 */
class TMultiplexedProtocol extends TProtocolDecorator
{
    /**
     * Separator between service name and function name.
     * Should be the same as used at multiplexed Thrift server.
     *
     * @var string
     */
    const SEPARATOR = ":";

    /**
     * The name of service.
     *
     * @var string
     */
    private $serviceName_;

    /**
     * Constructor of <code>TMultiplexedProtocol</code> class.
     *
     * Wrap the specified protocol, allowing it to be used to communicate with a
     * multiplexing server.  The <code>$serviceName</code> is required as it is
     * prepended to the message header so that the multiplexing server can broker
     * the function call to the proper service.
     *
     * @param TProtocol $protocol
     * @param string    $serviceName The name of service.
     */
    public function __construct(TProtocol $protocol, $serviceName)
    {
        parent::__construct($protocol);
        $this->serviceName_ = $serviceName;
    }

    /**
     * Writes the message header.
     * Prepends the service name to the function name, separated by <code>TMultiplexedProtocol::SEPARATOR</code>.
     *
     * @param string $name  Function name.
     * @param int    $type  Message type.
     * @param int    $seqid The sequence id of this message.
     */
    public function writeMessageBegin($name, $type, $seqid)
    {
        if ($type == TMessageType::CALL || $type == TMessageType::ONEWAY) {
            $nameWithService = $this->serviceName_ . self::SEPARATOR . $name;
            parent::writeMessageBegin($nameWithService, $type, $seqid);
        } else {
            parent::writeMessageBegin($name, $type, $seqid);
        }
    }
}
 <?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.protocol
 */

namespace Thrift\Protocol;

use Thrift\Type\TType;
use Thrift\Exception\TProtocolException;

/**
 * Protocol base class module.
 */
abstract class TProtocol {

  /**
   * Underlying transport
   *
   * @var TTransport
   */
  protected $trans_;

  /**
   * Constructor
   */
  protected function __construct($trans) {
    $this->trans_ = $trans;
  }

  /**
   * Accessor for transport
   *
   * @return TTransport
   */
  public function getTransport() {
    return $this->trans_;
  }

  /**
   * Writes the message header
   *
   * @param string $name Function name
   * @param int $type message type TMessageType::CALL or TMessageType::REPLY
   * @param int $seqid The sequence id of this message
   */
  public abstract function writeMessageBegin($name, $type, $seqid);

  /**
   * Close the message
   */
  public abstract function writeMessageEnd();

  /**
   * Writes a struct header.
   *
   * @param string     $name Struct name
   * @throws TException on write error
   * @return int How many bytes written
   */
  public abstract function writeStructBegin($name);

  /**
   * Close a struct.
   *
   * @throws TException on write error
   * @return int How many bytes written
   */
  public abstract function writeStructEnd();

  /*
   * Starts a field.
   *
   * @param string     $name Field name
   * @param int        $type Field type
   * @param int        $fid  Field id
   * @throws TException on write error
   * @return int How many bytes written
   */
  public abstract function writeFieldBegin($fieldName, $fieldType, $fieldId);

  public abstract function writeFieldEnd();

  public abstract function writeFieldStop();

  public abstract function writeMapBegin($keyType, $valType, $size);

  public abstract function writeMapEnd();

  public abstract function writeListBegin($elemType, $size);

  public abstract function writeListEnd();

  public abstract function writeSetBegin($elemType, $size);

  public abstract function writeSetEnd();

  public abstract function writeBool($bool);

  public abstract function writeByte($byte);

  public abstract function writeI16($i16);

  public abstract function writeI32($i32);

  public abstract function writeI64($i64);

  public abstract function writeDouble($dub);

  public abstract function writeString($str);

  /**
   * Reads the message header
   *
   * @param string $name Function name
   * @param int $type message type TMessageType::CALL or TMessageType::REPLY
   * @parem int $seqid The sequence id of this message
   */
  public abstract function readMessageBegin(&$name, &$type, &$seqid);

  /**
   * Read the close of message
   */
  public abstract function readMessageEnd();

  public abstract function readStructBegin(&$name);

  public abstract function readStructEnd();

  public abstract function readFieldBegin(&$name, &$fieldType, &$fieldId);

  public abstract function readFieldEnd();

  public abstract function readMapBegin(&$keyType, &$valType, &$size);

  public abstract function readMapEnd();

  public abstract function readListBegin(&$elemType, &$size);

  public abstract function readListEnd();

  public abstract function readSetBegin(&$elemType, &$size);

  public abstract function readSetEnd();

  public abstract function readBool(&$bool);

  public abstract function readByte(&$byte);

  public abstract function readI16(&$i16);

  public abstract function readI32(&$i32);

  public abstract function readI64(&$i64);

  public abstract function readDouble(&$dub);

  public abstract function readString(&$str);

  /**
   * The skip function is a utility to parse over unrecognized date without
   * causing corruption.
   *
   * @param TType $type What type is it
   */
  public function skip($type) {
    switch ($type) {
    case TType::BOOL:
      return $this->readBool($bool);
    case TType::BYTE:
      return $this->readByte($byte);
    case TType::I16:
      return $this->readI16($i16);
    case TType::I32:
      return $this->readI32($i32);
    case TType::I64:
      return $this->readI64($i64);
    case TType::DOUBLE:
      return $this->readDouble($dub);
    case TType::STRING:
      return $this->readString($str);
    case TType::STRUCT:
      {
        $result = $this->readStructBegin($name);
        while (true) {
          $result += $this->readFieldBegin($name, $ftype, $fid);
          if ($ftype == TType::STOP) {
            break;
          }
          $result += $this->skip($ftype);
          $result += $this->readFieldEnd();
        }
        $result += $this->readStructEnd();
        return $result;
      }
    case TType::MAP:
      {
        $result = $this->readMapBegin($keyType, $valType, $size);
        for ($i = 0; $i < $size; $i++) {
          $result += $this->skip($keyType);
          $result += $this->skip($valType);
        }
        $result += $this->readMapEnd();
        return $result;
      }
    case TType::SET:
      {
        $result = $this->readSetBegin($elemType, $size);
        for ($i = 0; $i < $size; $i++) {
          $result += $this->skip($elemType);
        }
        $result += $this->readSetEnd();
        return $result;
      }
    case TType::LST:
      {
        $result = $this->readListBegin($elemType, $size);
        for ($i = 0; $i < $size; $i++) {
          $result += $this->skip($elemType);
        }
        $result += $this->readListEnd();
        return $result;
      }
    default:
      throw new TProtocolException('Unknown field type: '.$type,
                                   TProtocolException::INVALID_DATA);
    }
  }

  /**
   * Utility for skipping binary data
   *
   * @param TTransport $itrans TTransport object
   * @param int        $type   Field type
   */
  public static function skipBinary($itrans, $type) {
    switch ($type) {
    case TType::BOOL:
      return $itrans->readAll(1);
    case TType::BYTE:
      return $itrans->readAll(1);
    case TType::I16:
      return $itrans->readAll(2);
    case TType::I32:
      return $itrans->readAll(4);
    case TType::I64:
      return $itrans->readAll(8);
    case TType::DOUBLE:
      return $itrans->readAll(8);
    case TType::STRING:
      $len = unpack('N', $itrans->readAll(4));
      $len = $len[1];
      if ($len > 0x7fffffff) {
        $len = 0 - (($len - 1) ^ 0xffffffff);
      }
      return 4 + $itrans->readAll($len);
    case TType::STRUCT:
      {
        $result = 0;
        while (true) {
          $ftype = 0;
          $fid = 0;
          $data = $itrans->readAll(1);
          $arr = unpack('c', $data);
          $ftype = $arr[1];
          if ($ftype == TType::STOP) {
            break;
          }
          // I16 field id
          $result += $itrans->readAll(2);
          $result += self::skipBinary($itrans, $ftype);
        }
        return $result;
      }
    case TType::MAP:
      {
        // Ktype
        $data = $itrans->readAll(1);
        $arr = unpack('c', $data);
        $ktype = $arr[1];
        // Vtype
        $data = $itrans->readAll(1);
        $arr = unpack('c', $data);
        $vtype = $arr[1];
        // Size
        $data = $itrans->readAll(4);
        $arr = unpack('N', $data);
        $size = $arr[1];
        if ($size > 0x7fffffff) {
          $size = 0 - (($size - 1) ^ 0xffffffff);
        }
        $result = 6;
        for ($i = 0; $i < $size; $i++) {
          $result += self::skipBinary($itrans, $ktype);
          $result += self::skipBinary($itrans, $vtype);
        }
        return $result;
      }
    case TType::SET:
    case TType::LST:
      {
        // Vtype
        $data = $itrans->readAll(1);
        $arr = unpack('c', $data);
        $vtype = $arr[1];
        // Size
        $data = $itrans->readAll(4);
        $arr = unpack('N', $data);
        $size = $arr[1];
        if ($size > 0x7fffffff) {
          $size = 0 - (($size - 1) ^ 0xffffffff);
        }
        $result = 5;
        for ($i = 0; $i < $size; $i++) {
          $result += self::skipBinary($itrans, $vtype);
        }
        return $result;
      }
    default:
      throw new TProtocolException('Unknown field type: '.$type,
                                   TProtocolException::INVALID_DATA);
    }
  }
}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.protocol
 */

namespace Thrift\Protocol;
use Thrift\Exception\TException;

/**
 * <code>TProtocolDecorator</code> forwards all requests to an enclosed
 * <code>TProtocol</code> instance, providing a way to author concise
 * concrete decorator subclasses. While it has no abstract methods, it
 * is marked abstract as a reminder that by itself, it does not modify
 * the behaviour of the enclosed <code>TProtocol</code>.
 *
 * @package Thrift\Protocol
 */
abstract class TProtocolDecorator extends TProtocol
{
    /**
     * Instance of protocol, to which all operations will be forwarded.
     *
     * @var TProtocol
     */
    private $concreteProtocol_;

    /**
     * Constructor of <code>TProtocolDecorator</code> class.
     * Encloses the specified protocol.
     *
     * @param TProtocol $protocol All operations will be forward to this instance. Must be non-null.
     */
    protected function __construct(TProtocol $protocol)
    {
        parent::__construct($protocol->getTransport());
        $this->concreteProtocol_ = $protocol;
    }

    /**
     * Writes the message header.
     *
     * @param string $name  Function name
     * @param int    $type  message type TMessageType::CALL or TMessageType::REPLY
     * @param int    $seqid The sequence id of this message
     */
    public function writeMessageBegin($name, $type, $seqid)
    {
        return $this->concreteProtocol_->writeMessageBegin($name, $type, $seqid);
    }

    /**
     * Closes the message.
     */
    public function writeMessageEnd()
    {
        return $this->concreteProtocol_->writeMessageEnd();
    }

    /**
     * Writes a struct header.
     *
     * @param string $name Struct name
     *
     * @throws TException on write error
     * @return int How many bytes written
     */
    public function writeStructBegin($name)
    {
        return $this->concreteProtocol_->writeStructBegin($name);
    }

    /**
     * Close a struct.
     *
     * @throws TException on write error
     * @return int How many bytes written
     */
    public function writeStructEnd()
    {
        return $this->concreteProtocol_->writeStructEnd();
    }

    public function writeFieldBegin($fieldName, $fieldType, $fieldId)
    {
        return $this->concreteProtocol_->writeFieldBegin($fieldName, $fieldType, $fieldId);
    }

    public function writeFieldEnd()
    {
        return $this->concreteProtocol_->writeFieldEnd();
    }

    public function writeFieldStop()
    {
        return $this->concreteProtocol_->writeFieldStop();
    }

    public function writeMapBegin($keyType, $valType, $size)
    {
        return $this->concreteProtocol_->writeMapBegin($keyType, $valType, $size);
    }

    public function writeMapEnd()
    {
        return $this->concreteProtocol_->writeMapEnd();
    }

    public function writeListBegin($elemType, $size)
    {
        return $this->concreteProtocol_->writeListBegin($elemType, $size);
    }

    public function writeListEnd()
    {
        return $this->concreteProtocol_->writeListEnd();
    }

    public function writeSetBegin($elemType, $size)
    {
        return $this->concreteProtocol_->writeSetBegin($elemType, $size);
    }

    public function writeSetEnd()
    {
        return $this->concreteProtocol_->writeSetEnd();
    }

    public function writeBool($bool)
    {
        return $this->concreteProtocol_->writeBool($bool);
    }

    public function writeByte($byte)
    {
        return $this->concreteProtocol_->writeByte($byte);
    }

    public function writeI16($i16)
    {
        return $this->concreteProtocol_->writeI16($i16);
    }

    public function writeI32($i32)
    {
        return $this->concreteProtocol_->writeI32($i32);
    }

    public function writeI64($i64)
    {
        return $this->concreteProtocol_->writeI64($i64);
    }

    public function writeDouble($dub)
    {
        return $this->concreteProtocol_->writeDouble($dub);
    }

    public function writeString($str)
    {
        return $this->concreteProtocol_->writeString($str);
    }

    /**
     * Reads the message header
     *
     * @param string $name  Function name
     * @param int    $type  message type TMessageType::CALL or TMessageType::REPLY
     * @param int    $seqid The sequence id of this message
     */
    public function readMessageBegin(&$name, &$type, &$seqid)
    {
        return $this->concreteProtocol_->readMessageBegin($name, $type, $seqid);
    }

    /**
     * Read the close of message
     */
    public function readMessageEnd()
    {
        return $this->concreteProtocol_->readMessageEnd();
    }

    public function readStructBegin(&$name)
    {
        return $this->concreteProtocol_->readStructBegin($name);
    }

    public function readStructEnd()
    {
        return $this->concreteProtocol_->readStructEnd();
    }

    public function readFieldBegin(&$name, &$fieldType, &$fieldId)
    {
        return $this->concreteProtocol_->readFieldBegin($name, $fieldType, $fieldId);
    }

    public function readFieldEnd()
    {
        return $this->concreteProtocol_->readFieldEnd();
    }

    public function readMapBegin(&$keyType, &$valType, &$size)
    {
        $this->concreteProtocol_->readMapBegin($keyType, $valType, $size);
    }

    public function readMapEnd()
    {
        return $this->concreteProtocol_->readMapEnd();
    }

    public function readListBegin(&$elemType, &$size)
    {
        $this->concreteProtocol_->readListBegin($elemType, $size);
    }

    public function readListEnd()
    {
        return $this->concreteProtocol_->readListEnd();
    }

    public function readSetBegin(&$elemType, &$size)
    {
        return $this->concreteProtocol_->readSetBegin($elemType, $size);
    }

    public function readSetEnd()
    {
        return $this->concreteProtocol_->readSetEnd();
    }

    public function readBool(&$bool)
    {
        return $this->concreteProtocol_->readBool($bool);
    }

    public function readByte(&$byte)
    {
        return $this->concreteProtocol_->readByte($byte);
    }

    public function readI16(&$i16)
    {
        return $this->concreteProtocol_->readI16($i16);
    }

    public function readI32(&$i32)
    {
        return $this->concreteProtocol_->readI32($i32);
    }

    public function readI64(&$i64)
    {
        return $this->concreteProtocol_->readI64($i64);
    }

    public function readDouble(&$dub)
    {
        return $this->concreteProtocol_->readDouble($dub);
    }

    public function readString(&$str)
    {
        return $this->concreteProtocol_->readString($str);
    }
}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.protocol
 * @author: rmarin (marin.radu@facebook.com)
 */

namespace Thrift\Serializer;

use Thrift\Transport\TMemoryBuffer;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Type\TMessageType;

/**
 * Utility class for serializing and deserializing
 * a thrift object using TBinaryProtocolAccelerated.
 */
class TBinarySerializer {

  // NOTE(rmarin): Because thrift_protocol_write_binary
  // adds a begin message prefix, you cannot specify
  // a transport in which to serialize an object. It has to
  // be a string. Otherwise we will break the compatibility with
  // normal deserialization.
  public static function serialize($object) {
    $transport = new TMemoryBuffer();
    $protocol = new TBinaryProtocolAccelerated($transport);
    if (function_exists('thrift_protocol_write_binary')) {
      thrift_protocol_write_binary($protocol, $object->getName(),
                                   TMessageType::REPLY, $object,
                                   0, $protocol->isStrictWrite());

      $protocol->readMessageBegin($unused_name, $unused_type,
                                  $unused_seqid);
    } else {
      $object->write($protocol);
    }
    $protocol->getTransport()->flush();
    return $transport->getBuffer();
  }

  public static function deserialize($string_object, $class_name) {
     $transport = new TMemoryBuffer();
     $protocol = new TBinaryProtocolAccelerated($transport);
     if (function_exists('thrift_protocol_read_binary')) {
       // NOTE (t.heintz) TBinaryProtocolAccelerated internally wraps our TMemoryBuffer in a
       // TBufferedTransport, so we have to retrieve it again or risk losing data when writing
       // less than 512 bytes to the transport (see the comment there as well).
       // @see THRIFT-1579
       $protocol->writeMessageBegin('', TMessageType::REPLY, 0);
       $protocolTransport = $protocol->getTransport();
       $protocolTransport->write($string_object);
       $protocolTransport->flush();
       return thrift_protocol_read_binary($protocol, $class_name,
                                          $protocol->isStrictRead());
     } else {
       $transport->write($string_object);
       $object = new $class_name();
       $object->read($protocol);
       return $object;
     }
  }
}
<?php

namespace Thrift\Server;

use Thrift\Server\TServer;
use Thrift\Transport\TTransport;
use Thrift\Exception\TException;
use Thrift\Exception\TTransportException;

/**
 * A forking implementation of a Thrift server.
 *
 * @package thrift.server
 */
class TForkingServer extends TServer {
  /**
   * Flag for the main serving loop
   *
   * @var bool
   */
  private $stop_ = false;

  /**
   * List of children.
   *
   * @var array
   */
  protected $children_ = array();

  /**
   * Listens for new client using the supplied
   * transport. We fork when a new connection
   * arrives.
   *
   * @return void
   */
  public function serve() {
    $this->transport_->listen();

    while (!$this->stop_) {
      try {
        $transport = $this->transport_->accept();

        if ($transport != null) {
          $pid = pcntl_fork();

          if ($pid > 0) {
            $this->handleParent($transport, $pid);
          }
          else if ($pid === 0) {
            $this->handleChild($transport);
          }
          else {
            throw new TException('Failed to fork');
          }
        }
      }
      catch (TTransportException $e) { }

      $this->collectChildren();
    }
  }

  /**
   * Code run by the parent
   *
   * @param TTransport $transport
   * @param int $pid
   * @return void
   */
  private function handleParent(TTransport $transport, $pid) {
    $this->children_[$pid] = $transport;
  }

  /**
   * Code run by the child.
   *
   * @param TTransport $transport
   * @return void
   */
  private function handleChild(TTransport $transport) {
    try {
      $inputTransport = $this->inputTransportFactory_->getTransport($transport);
      $outputTransport = $this->outputTransportFactory_->getTransport($transport);
      $inputProtocol = $this->inputProtocolFactory_->getProtocol($inputTransport);
      $outputProtocol = $this->outputProtocolFactory_->getProtocol($outputTransport);
      while ($this->processor_->process($inputProtocol, $outputProtocol)) { }
      @$transport->close();
    }
    catch (TTransportException $e) { }

    exit(0);
  }

  /**
   * Collects any children we may have
   *
   * @return void
   */
  private function collectChildren() {
    foreach ($this->children_ as $pid => $transport) {
      if (pcntl_waitpid($pid, $status, WNOHANG) > 0) {
        unset($this->children_[$pid]);
        if ($transport) @$transport->close();
      }
    }
  }

  /**
   * Stops the server running. Kills the transport
   * and then stops the main serving loop
   *
   * @return void
   */
  public function stop() {
    $this->transport_->close();
    $this->stop_ = true;
  }
}
<?php

namespace Thrift\Server;

use Thrift\Server\TServerTransport;
use Thrift\Factory\TTransportFactory;
use Thrift\Factory\TProtocolFactory;

/**
 * Generic class for a Thrift server.
 *
 * @package thrift.server
 */
abstract class TServer {

  /**
   * Processor to handle new clients
   *
   * @var TProcessor
   */
  protected $processor_;

  /**
   * Server transport to be used for listening
   * and accepting new clients
   *
   * @var TServerTransport
   */
  protected $transport_;

  /**
   * Input transport factory
   *
   * @var TTransportFactory
   */
  protected $inputTransportFactory_;

  /**
   * Output transport factory
   *
   * @var TTransportFactory
   */
  protected $outputTransportFactory_;

  /**
   * Input protocol factory
   *
   * @var TProtocolFactory
   */
  protected $inputProtocolFactory_;

  /**
   * Output protocol factory
   *
   * @var TProtocolFactory
   */
  protected $outputProtocolFactory_;

  /**
   * Sets up all the factories, etc
   *
   * @param object $processor
   * @param TServerTransport $transport
   * @param TTransportFactory $inputTransportFactory
   * @param TTransportFactory $outputTransportFactory
   * @param TProtocolFactory $inputProtocolFactory
   * @param TProtocolFactory $outputProtocolFactory
   * @return void
   */
  public function __construct($processor,
                              TServerTransport $transport,
                              TTransportFactory $inputTransportFactory,
                              TTransportFactory $outputTransportFactory,
                              TProtocolFactory $inputProtocolFactory,
                              TProtocolFactory $outputProtocolFactory) {
    $this->processor_ = $processor;
    $this->transport_ = $transport;
    $this->inputTransportFactory_ = $inputTransportFactory;
    $this->outputTransportFactory_ = $outputTransportFactory;
    $this->inputProtocolFactory_ = $inputProtocolFactory;
    $this->outputProtocolFactory_ = $outputProtocolFactory;
  }

  /**
   * Serves the server. This should never return
   * unless a problem permits it to do so or it
   * is interrupted intentionally
   *
   * @abstract
   * @return void
   */
  abstract public function serve();

  /**
   * Stops the server serving
   *
   * @abstract
   * @return void
   */
  abstract public function stop();
}
<?php

namespace Thrift\Server;

use Thrift\Server\TServerTransport;
use Thrift\Transport\TSocket;

/**
 * Socket implementation of a server agent.
 *
 * @package thrift.transport
 */
class TServerSocket extends TServerTransport {

  /**
   * Handle for the listener socket
   *
   * @var resource
   */
  private $listener_;

  /**
   * Port for the listener to listen on
   *
   * @var int
   */
  private $port_;

  /**
   * Timeout when listening for a new client
   *
   * @var int
   */
  private $acceptTimeout_ = 30000;

  /**
   * Host to listen on
   *
   * @var string
   */
  private $host_;

  /**
   * ServerSocket constructor
   *
   * @param string $host        Host to listen on
   * @param int $port           Port to listen on
   * @return void
   */
  public function __construct($host = 'localhost', $port = 9090) {
    $this->host_ = $host;
    $this->port_ = $port;
  }

  /**
   * Sets the accept timeout
   *
   * @param int $acceptTimeout
   * @return void
   */
  public function setAcceptTimeout($acceptTimeout) {
    $this->acceptTimeout_ = $acceptTimeout;
  }

  /**
   * Opens a new socket server handle
   *
   * @return void
   */
  public function listen() {
    $this->listener_ = stream_socket_server('tcp://' . $this->host_ . ':' . $this->port_);
  }

  /**
   * Closes the socket server handle
   *
   * @return void
   */
  public function close() {
    @fclose($this->listener_);
    $this->listener_ = null;
  }

  /**
   * Implementation of accept. If not client is accepted in the given time
   *
   * @return TSocket
   */
  protected function acceptImpl() {
    $handle = @stream_socket_accept($this->listener_, $this->acceptTimeout_ / 1000.0);
    if(!$handle) return null;

    $socket = new TSocket();
    $socket->setHandle($handle);

    return $socket;
  }
}
<?php

namespace Thrift\Server;

use Thrift\Exception\TTransportException;

/**
 * Generic class for Server agent.
 *
 * @package thrift.transport
 */
abstract class TServerTransport {
  /**
   * List for new clients
   *
   * @abstract
   * @return void
   */
  abstract public function listen();

  /**
   * Close the server
   *
   * @abstract
   * @return void
   */
  abstract public function close();

  /**
   * Subclasses should use this to implement
   * accept.
   *
   * @abstract
   * @return TTransport
   */
  protected abstract function acceptImpl();

  /**
   * Uses the accept implemtation. If null is returned, an
   * exception is thrown.
   *
   * @throws TTransportException
   * @return TTransport
   */
  public function accept() {
    $transport = $this->acceptImpl();

    if ($transport == null) {
      throw new TTransportException("accept() may not return NULL");
    }

    return $transport;
  }
}
<?php

namespace Thrift\Server;

use Thrift\Server\TServer;
use Thrift\Exception\TTransportException;

/**
 * Simple implemtation of a Thrift server.
 *
 * @package thrift.server
 */
class TSimpleServer extends TServer {
  /**
   * Flag for the main serving loop
   *
   * @var bool
   */
  private $stop_ = false;

  /**
   * Listens for new client using the supplied
   * transport. It handles TTransportExceptions
   * to avoid timeouts etc killing it
   *
   * @return void
   */
  public function serve() {
    $this->transport_->listen();

    while (!$this->stop_) {
      try {
        $transport = $this->transport_->accept();

        if ($transport != null) {
          $inputTransport = $this->inputTransportFactory_->getTransport($transport);
          $outputTransport = $this->outputTransportFactory_->getTransport($transport);
          $inputProtocol = $this->inputProtocolFactory_->getProtocol($inputTransport);
          $outputProtocol = $this->outputProtocolFactory_->getProtocol($outputTransport);
          while ($this->processor_->process($inputProtocol, $outputProtocol)) { }
        }
      }
      catch (TTransportException $e) { }
    }
  }

  /**
   * Stops the server running. Kills the transport
   * and then stops the main serving loop
   *
   * @return void
   */
  public function stop() {
    $this->transport_->close();
    $this->stop_ = true;
  }
}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

namespace Thrift\StringFunc;

use Thrift\StringFunc\TStringFunc;

class Core implements TStringFunc {
    public function substr($str, $start, $length = null) {
        // specifying a null $length would return an empty string
        if($length === null) {
            return substr($str, $start);
        }
        return substr($str, $start, $length);
    }

    public function strlen($str) {
        return strlen($str);
    }
}<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

namespace Thrift\StringFunc;

use Thrift\StringFunc\TStringFunc;

class Mbstring implements TStringFunc {
    public function substr($str, $start, $length = null) {
        /**
         * We need to set the charset parameter, which is the second
         * optional parameter and the first optional parameter can't
         * be null or false as a "magic" value because that would
         * cause an empty string to be returned, so we need to
         * actually calculate the proper length value.
         */
        if($length === null) {
            $length = $this->strlen($str) - $start;
        }

        return mb_substr($str, $start, $length, '8bit');
    }

    public function strlen($str) {
        return mb_strlen($str, '8bit');
    }
}<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

namespace Thrift\StringFunc;

interface TStringFunc {
    public function substr($str, $start, $length = null);
    public function strlen($str);
}<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.processor
 */

namespace Thrift;

use Thrift\Exception\TException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TMultiplexedProtocol;
use Thrift\Protocol\TProtocolDecorator;
use Thrift\Type\TMessageType;

/**
 * <code>TMultiplexedProcessor</code> is a Processor allowing
 * a single <code>TServer</code> to provide multiple services.
 *
 * <p>To do so, you instantiate the processor and then register additional
 * processors with it, as shown in the following example:</p>
 *
 * <blockquote><code>
 *     $processor = new TMultiplexedProcessor();
 *
 *     processor->registerProcessor(
 *         "Calculator",
 *         new \tutorial\CalculatorProcessor(new CalculatorHandler()));
 *
 *     processor->registerProcessor(
 *         "WeatherReport",
 *         new \tutorial\WeatherReportProcessor(new WeatherReportHandler()));
 *
 *     $processor->process($protocol, $protocol);
 * </code></blockquote>
 */

class TMultiplexedProcessor {
    private $serviceProcessorMap_;

    /**
     * 'Register' a service with this <code>TMultiplexedProcessor</code>.  This
     * allows us to broker requests to individual services by using the service
     * name to select them at request time.
     *
     * @param serviceName Name of a service, has to be identical to the name
     * declared in the Thrift IDL, e.g. "WeatherReport".
     * @param processor Implementation of a service, ususally referred to
     * as "handlers", e.g. WeatherReportHandler implementing WeatherReport.Iface.
     */
    public function registerProcessor($serviceName, $processor) {
        $this->serviceProcessorMap_[$serviceName] = $processor;
    }

    /**
     * This implementation of <code>process</code> performs the following steps:
     *
     * <ol>
     *     <li>Read the beginning of the message.</li>
     *     <li>Extract the service name from the message.</li>
     *     <li>Using the service name to locate the appropriate processor.</li>
     *     <li>Dispatch to the processor, with a decorated instance of TProtocol
     *         that allows readMessageBegin() to return the original Message.</li>
     * </ol>
     *
     * @throws TException If the message type is not CALL or ONEWAY, if
     * the service name was not found in the message, or if the service
     * name was not found in the service map.
     */
    public function process(TProtocol $input, TProtocol $output) {
        /*
            Use the actual underlying protocol (e.g. TBinaryProtocol) to read the
            message header. This pulls the message "off the wire", which we'll
            deal with at the end of this method.
        */
        $input->readMessageBegin($fname, $mtype, $rseqid);

        if ($mtype !== TMessageType::CALL && $mtype != TMessageType::ONEWAY) {
            throw new TException("This should not have happened!?");
        }

        // Extract the service name and the new Message name.
        if (strpos($fname, TMultiplexedProtocol::SEPARATOR) === false) {
            throw new TException("Service name not found in message name: {$fname}. Did you " .
                "forget to use a TMultiplexProtocol in your client?");
        }
        list($serviceName, $messageName) = explode(':', $fname, 2);
        if (!array_key_exists($serviceName, $this->serviceProcessorMap_)) {
            throw new TException("Service name not found: {$serviceName}.  Did you forget " .
                "to call registerProcessor()?");
        }

        // Dispatch processing to the stored processor
        $processor = $this->serviceProcessorMap_[$serviceName];
        return $processor->process(
            new StoredMessageProtocol($input, $messageName, $mtype, $rseqid), $output
        );
    }
}

/**
 *  Our goal was to work with any protocol. In order to do that, we needed
 *  to allow them to call readMessageBegin() and get the Message in exactly
 *  the standard format, without the service name prepended to the Message name.
 */
class StoredMessageProtocol extends TProtocolDecorator {
    private $fname_, $mtype_, $rseqid_;

    public function __construct(TProtocol $protocol, $fname, $mtype, $rseqid) {
        parent::__construct($protocol);
        $this->fname_  = $fname;
        $this->mtype_  = $mtype;
        $this->rseqid_ = $rseqid;
    }

    public function readMessageBegin(&$name, &$type, &$seqid) {
        $name  = $this->fname_;
        $type  = $this->mtype_;
        $seqid = $this->rseqid_;
    }
}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.transport
 */

namespace Thrift\Transport;

use Thrift\Transport\TTransport;
use Thrift\Factory\TStringFuncFactory;

/**
 * Buffered transport. Stores data to an internal buffer that it doesn't
 * actually write out until flush is called. For reading, we do a greedy
 * read and then serve data out of the internal buffer.
 *
 * @package thrift.transport
 */
class TBufferedTransport extends TTransport {

  /**
   * Constructor. Creates a buffered transport around an underlying transport
   */
  public function __construct($transport=null, $rBufSize=512, $wBufSize=512) {
    $this->transport_ = $transport;
    $this->rBufSize_ = $rBufSize;
    $this->wBufSize_ = $wBufSize;
  }

  /**
   * The underlying transport
   *
   * @var TTransport
   */
  protected $transport_ = null;

  /**
   * The receive buffer size
   *
   * @var int
   */
  protected $rBufSize_ = 512;

  /**
   * The write buffer size
   *
   * @var int
   */
  protected $wBufSize_ = 512;

  /**
   * The write buffer.
   *
   * @var string
   */
  protected $wBuf_ = '';

  /**
   * The read buffer.
   *
   * @var string
   */
  protected $rBuf_ = '';

  public function isOpen() {
    return $this->transport_->isOpen();
  }

  public function open() {
    $this->transport_->open();
  }

  public function close() {
    $this->transport_->close();
  }

  public function putBack($data) {
    if (TStringFuncFactory::create()->strlen($this->rBuf_) === 0) {
      $this->rBuf_ = $data;
    } else {
      $this->rBuf_ = ($data . $this->rBuf_);
    }
  }

  /**
   * The reason that we customize readAll here is that the majority of PHP
   * streams are already internally buffered by PHP. The socket stream, for
   * example, buffers internally and blocks if you call read with $len greater
   * than the amount of data available, unlike recv() in C.
   *
   * Therefore, use the readAll method of the wrapped transport inside
   * the buffered readAll.
   */
  public function readAll($len) {
    $have = TStringFuncFactory::create()->strlen($this->rBuf_);
    if ($have == 0) {
      $data = $this->transport_->readAll($len);
    } else if ($have < $len) {
      $data = $this->rBuf_;
      $this->rBuf_ = '';
      $data .= $this->transport_->readAll($len - $have);
    } else if ($have == $len) {
      $data = $this->rBuf_;
      $this->rBuf_ = '';
    } else if ($have > $len) {
      $data = TStringFuncFactory::create()->substr($this->rBuf_, 0, $len);
      $this->rBuf_ = TStringFuncFactory::create()->substr($this->rBuf_, $len);
    }
    return $data;
  }

  public function read($len) {
    if (TStringFuncFactory::create()->strlen($this->rBuf_) === 0) {
      $this->rBuf_ = $this->transport_->read($this->rBufSize_);
    }

    if (TStringFuncFactory::create()->strlen($this->rBuf_) <= $len) {
      $ret = $this->rBuf_;
      $this->rBuf_ = '';
      return $ret;
    }

    $ret = TStringFuncFactory::create()->substr($this->rBuf_, 0, $len);
    $this->rBuf_ = TStringFuncFactory::create()->substr($this->rBuf_, $len);
    return $ret;
  }

  public function write($buf) {
    $this->wBuf_ .= $buf;
    if (TStringFuncFactory::create()->strlen($this->wBuf_) >= $this->wBufSize_) {
      $out = $this->wBuf_;

      // Note that we clear the internal wBuf_ prior to the underlying write
      // to ensure we're in a sane state (i.e. internal buffer cleaned)
      // if the underlying write throws up an exception
      $this->wBuf_ = '';
      $this->transport_->write($out);
    }
  }

  public function flush() {
    if (TStringFuncFactory::create()->strlen($this->wBuf_) > 0) {
      $out = $this->wBuf_;

      // Note that we clear the internal wBuf_ prior to the underlying write
      // to ensure we're in a sane state (i.e. internal buffer cleaned)
      // if the underlying write throws up an exception
      $this->wBuf_ = '';
      $this->transport_->write($out);
    }
    $this->transport_->flush();
  }

}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.transport
 */

namespace Thrift\Transport;

use Thrift\Transport\TTransport;
use Thrift\Exception\TTransportException;
use Thrift\Factory\TStringFuncFactory;

/**
 * HTTP client for Thrift
 *
 * @package thrift.transport
 */
class TCurlClient extends TTransport {

  private static $curlHandle;

  /**
   * The host to connect to
   *
   * @var string
   */
  protected $host_;

  /**
   * The port to connect on
   *
   * @var int
   */
  protected $port_;

  /**
   * The URI to request
   *
   * @var string
   */
  protected $uri_;

  /**
   * The scheme to use for the request, i.e. http, https
   *
   * @var string
   */
  protected $scheme_;

  /**
   * Buffer for the HTTP request data
   *
   * @var string
   */
  protected $request_;

  /**
   * Buffer for the HTTP response data.
   *
   * @var binary string
   */
  protected $response_;

  /**
   * Read timeout
   *
   * @var float
   */
  protected $timeout_;

  /**
   * Make a new HTTP client.
   *
   * @param string $host
   * @param int    $port
   * @param string $uri
   */
  public function __construct($host, $port=80, $uri='', $scheme = 'http') {
    if ((TStringFuncFactory::create()->strlen($uri) > 0) && ($uri{0} != '/')) {
      $uri = '/'.$uri;
    }
    $this->scheme_ = $scheme;
    $this->host_ = $host;
    $this->port_ = $port;
    $this->uri_ = $uri;
    $this->request_ = '';
    $this->response_ = null;
    $this->timeout_ = null;
  }

  /**
   * Set read timeout
   *
   * @param float $timeout
   */
  public function setTimeoutSecs($timeout) {
    $this->timeout_ = $timeout;
  }

  /**
   * Whether this transport is open.
   *
   * @return boolean true if open
   */
  public function isOpen() {
    return true;
  }

  /**
   * Open the transport for reading/writing
   *
   * @throws TTransportException if cannot open
   */
  public function open() {
  }

  /**
   * Close the transport.
   */
  public function close() {
    $this->request_ = '';
    $this->response_ = null;
  }

  /**
   * Read some data into the array.
   *
   * @param int    $len How much to read
   * @return string The data that has been read
   * @throws TTransportException if cannot read any more data
   */
  public function read($len) {
    if ($len >= strlen($this->response_)) {
      return $this->response_;
    } else {
      $ret = substr($this->response_, 0, $len);
      $this->response_ = substr($this->response_, $len);
      return $ret;
    }
  }

  /**
   * Writes some data into the pending buffer
   *
   * @param string $buf  The data to write
   * @throws TTransportException if writing fails
   */
  public function write($buf) {
    $this->request_ .= $buf;
  }

  /**
   * Opens and sends the actual request over the HTTP connection
   *
   * @throws TTransportException if a writing error occurs
   */
  public function flush() {
    if (!self::$curlHandle) {
      register_shutdown_function(array('Thrift\\Transport\\TCurlClient', 'closeCurlHandle'));
      self::$curlHandle = curl_init();
      curl_setopt(self::$curlHandle, CURLOPT_RETURNTRANSFER, true);
      curl_setopt(self::$curlHandle, CURLOPT_BINARYTRANSFER, true);
      curl_setopt(self::$curlHandle, CURLOPT_USERAGENT, 'PHP/TCurlClient');
      curl_setopt(self::$curlHandle, CURLOPT_CUSTOMREQUEST, 'POST');
      curl_setopt(self::$curlHandle, CURLOPT_FOLLOWLOCATION, true);
      curl_setopt(self::$curlHandle, CURLOPT_MAXREDIRS, 1);
    }
    // God, PHP really has some esoteric ways of doing simple things.
    $host = $this->host_.($this->port_ != 80 ? ':'.$this->port_ : '');
    $fullUrl = $this->scheme_."://".$host.$this->uri_;

    $headers = array('Accept: application/x-thrift',
                     'Content-Type: application/x-thrift',
                     'Content-Length: '.TStringFuncFactory::create()->strlen($this->request_));
    curl_setopt(self::$curlHandle, CURLOPT_HTTPHEADER, $headers);

    if ($this->timeout_ > 0) {
      curl_setopt(self::$curlHandle, CURLOPT_TIMEOUT, $this->timeout_);
    }
    curl_setopt(self::$curlHandle, CURLOPT_POSTFIELDS, $this->request_);
    $this->request_ = '';

    curl_setopt(self::$curlHandle, CURLOPT_URL, $fullUrl);
    $this->response_ = curl_exec(self::$curlHandle);

    // Connect failed?
    if (!$this->response_) {
      curl_close(self::$curlHandle);
      self::$curlHandle = null;
      $error = 'TCurlClient: Could not connect to '.$fullUrl;
      throw new TTransportException($error, TTransportException::NOT_OPEN);
    }
  }

  static function closeCurlHandle() {
    try {
      if (self::$curlHandle) {
        curl_close(self::$curlHandle);
        self::$curlHandle = null;
      }
    } catch (\Exception $x) {
      error_log('There was an error closing the curl handle: ' . $x->getMessage());
    }
  }

}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.transport
 */

namespace Thrift\Transport;

use Thrift\Transport\TTransport;
use Thrift\Factory\TStringFuncFactory;

/**
 * Framed transport. Writes and reads data in chunks that are stamped with
 * their length.
 *
 * @package thrift.transport
 */
class TFramedTransport extends TTransport {

  /**
   * Underlying transport object.
   *
   * @var TTransport
   */
  private $transport_;

  /**
   * Buffer for read data.
   *
   * @var string
   */
  private $rBuf_;

  /**
   * Buffer for queued output data
   *
   * @var string
   */
  private $wBuf_;

  /**
   * Whether to frame reads
   *
   * @var bool
   */
  private $read_;

  /**
   * Whether to frame writes
   *
   * @var bool
   */
  private $write_;

  /**
   * Constructor.
   *
   * @param TTransport $transport Underlying transport
   */
  public function __construct($transport=null, $read=true, $write=true) {
    $this->transport_ = $transport;
    $this->read_ = $read;
    $this->write_ = $write;
  }

  public function isOpen() {
    return $this->transport_->isOpen();
  }

  public function open() {
    $this->transport_->open();
  }

  public function close() {
    $this->transport_->close();
  }

  /**
   * Reads from the buffer. When more data is required reads another entire
   * chunk and serves future reads out of that.
   *
   * @param int $len How much data
   */
  public function read($len) {
    if (!$this->read_) {
      return $this->transport_->read($len);
    }

    if (TStringFuncFactory::create()->strlen($this->rBuf_) === 0) {
      $this->readFrame();
    }

    // Just return full buff
    if ($len >= TStringFuncFactory::create()->strlen($this->rBuf_)) {
      $out = $this->rBuf_;
      $this->rBuf_ = null;
      return $out;
    }

    // Return TStringFuncFactory::create()->substr
    $out = TStringFuncFactory::create()->substr($this->rBuf_, 0, $len);
    $this->rBuf_ = TStringFuncFactory::create()->substr($this->rBuf_, $len);
    return $out;
  }

  /**
   * Put previously read data back into the buffer
   *
   * @param string $data data to return
   */
  public function putBack($data) {
    if (TStringFuncFactory::create()->strlen($this->rBuf_) === 0) {
      $this->rBuf_ = $data;
    } else {
      $this->rBuf_ = ($data . $this->rBuf_);
    }
  }

  /**
   * Reads a chunk of data into the internal read buffer.
   */
  private function readFrame() {
    $buf = $this->transport_->readAll(4);
    $val = unpack('N', $buf);
    $sz = $val[1];

    $this->rBuf_ = $this->transport_->readAll($sz);
  }

  /**
   * Writes some data to the pending output buffer.
   *
   * @param string $buf The data
   * @param int    $len Limit of bytes to write
   */
  public function write($buf, $len=null) {
    if (!$this->write_) {
      return $this->transport_->write($buf, $len);
    }

    if ($len !== null && $len < TStringFuncFactory::create()->strlen($buf)) {
      $buf = TStringFuncFactory::create()->substr($buf, 0, $len);
    }
    $this->wBuf_ .= $buf;
  }

  /**
   * Writes the output buffer to the stream in the format of a 4-byte length
   * followed by the actual data.
   */
  public function flush() {
    if (!$this->write_ || TStringFuncFactory::create()->strlen($this->wBuf_) == 0) {
      return $this->transport_->flush();
    }

    $out = pack('N', TStringFuncFactory::create()->strlen($this->wBuf_));
    $out .= $this->wBuf_;

    // Note that we clear the internal wBuf_ prior to the underlying write
    // to ensure we're in a sane state (i.e. internal buffer cleaned)
    // if the underlying write throws up an exception
    $this->wBuf_ = '';
    $this->transport_->write($out);
    $this->transport_->flush();
  }

}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.transport
 */

namespace Thrift\Transport;

use Thrift\Transport\TTransport;
use Thrift\Exception\TTransportException;
use Thrift\Factory\TStringFuncFactory;

/**
 * HTTP client for Thrift
 *
 * @package thrift.transport
 */
class THttpClient extends TTransport {

  /**
   * The host to connect to
   *
   * @var string
   */
  protected $host_;

  /**
   * The port to connect on
   *
   * @var int
   */
  protected $port_;

  /**
   * The URI to request
   *
   * @var string
   */
  protected $uri_;

  /**
   * The scheme to use for the request, i.e. http, https
   *
   * @var string
   */
  protected $scheme_;

  /**
   * Buffer for the HTTP request data
   *
   * @var string
   */
  protected $buf_;

  /**
   * Input socket stream.
   *
   * @var resource
   */
  protected $handle_;

  /**
   * Read timeout
   *
   * @var float
   */
  protected $timeout_;

  /**
   * http headers
   *
   * @var array
   */
  protected $headers_;

  /**
   * Make a new HTTP client.
   *
   * @param string $host
   * @param int    $port
   * @param string $uri
   */
  public function __construct($host, $port=80, $uri='', $scheme = 'http') {
    if ((TStringFuncFactory::create()->strlen($uri) > 0) && ($uri{0} != '/')) {
      $uri = '/'.$uri;
    }
    $this->scheme_ = $scheme;
    $this->host_ = $host;
    $this->port_ = $port;
    $this->uri_ = $uri;
    $this->buf_ = '';
    $this->handle_ = null;
    $this->timeout_ = null;
    $this->headers_ = array();
  }

  /**
   * Set read timeout
   *
   * @param float $timeout
   */
  public function setTimeoutSecs($timeout) {
    $this->timeout_ = $timeout;
  }

  /**
   * Whether this transport is open.
   *
   * @return boolean true if open
   */
  public function isOpen() {
    return true;
  }

  /**
   * Open the transport for reading/writing
   *
   * @throws TTransportException if cannot open
   */
  public function open() {}

  /**
   * Close the transport.
   */
  public function close() {
    if ($this->handle_) {
      @fclose($this->handle_);
      $this->handle_ = null;
    }
  }

  /**
   * Read some data into the array.
   *
   * @param int    $len How much to read
   * @return string The data that has been read
   * @throws TTransportException if cannot read any more data
   */
  public function read($len) {
    $data = @fread($this->handle_, $len);
    if ($data === FALSE || $data === '') {
      $md = stream_get_meta_data($this->handle_);
      if ($md['timed_out']) {
        throw new TTransportException('THttpClient: timed out reading '.$len.' bytes from '.$this->host_.':'.$this->port_.$this->uri_, TTransportException::TIMED_OUT);
      } else {
        throw new TTransportException('THttpClient: Could not read '.$len.' bytes from '.$this->host_.':'.$this->port_.$this->uri_, TTransportException::UNKNOWN);
      }
    }
    return $data;
  }

  /**
   * Writes some data into the pending buffer
   *
   * @param string $buf  The data to write
   * @throws TTransportException if writing fails
   */
  public function write($buf) {
    $this->buf_ .= $buf;
  }

  /**
   * Opens and sends the actual request over the HTTP connection
   *
   * @throws TTransportException if a writing error occurs
   */
  public function flush() {
    // God, PHP really has some esoteric ways of doing simple things.
    $host = $this->host_.($this->port_ != 80 ? ':'.$this->port_ : '');

    $headers = array();
    $defaultHeaders = array('Host' => $host,
                            'Accept' => 'application/x-thrift',
                            'User-Agent' => 'PHP/THttpClient',
                            'Content-Type' => 'application/x-thrift',
                            'Content-Length' => TStringFuncFactory::create()->strlen($this->buf_));
    foreach (array_merge($defaultHeaders, $this->headers_) as $key => $value) {
        $headers[] = "$key: $value";
    }

    $options = array('method' => 'POST',
                     'header' => implode("\r\n", $headers),
                     'max_redirects' => 1,
                     'content' => $this->buf_);
    if ($this->timeout_ > 0) {
      $options['timeout'] = $this->timeout_;
    }
    $this->buf_ = '';

    $contextid = stream_context_create(array('http' => $options));
    $this->handle_ = @fopen($this->scheme_.'://'.$host.$this->uri_, 'r', false, $contextid);

    // Connect failed?
    if ($this->handle_ === FALSE) {
      $this->handle_ = null;
      $error = 'THttpClient: Could not connect to '.$host.$this->uri_;
      throw new TTransportException($error, TTransportException::NOT_OPEN);
    }
  }

  public function addHeaders($headers) {
    $this->headers_ = array_merge($this->headers_, $headers);
  }

}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.transport
 */

namespace Thrift\Transport;

use Thrift\Transport\TTransport;
use Thrift\Exception\TTransportException;
use Thrift\Factory\TStringFuncFactory;

/**
 * A memory buffer is a tranpsort that simply reads from and writes to an
 * in-memory string buffer. Anytime you call write on it, the data is simply
 * placed into a buffer, and anytime you call read, data is read from that
 * buffer.
 *
 * @package thrift.transport
 */
class TMemoryBuffer extends TTransport {

  /**
   * Constructor. Optionally pass an initial value
   * for the buffer.
   */
  public function __construct($buf = '') {
    $this->buf_ = $buf;
  }

  protected $buf_ = '';

  public function isOpen() {
    return true;
  }

  public function open() {}

  public function close() {}

  public function write($buf) {
    $this->buf_ .= $buf;
  }

  public function read($len) {
    $bufLength = TStringFuncFactory::create()->strlen($this->buf_);

    if ($bufLength === 0) {
      throw new TTransportException('TMemoryBuffer: Could not read ' .
                                    $len . ' bytes from buffer.',
                                    TTransportException::UNKNOWN);
    }

    if ($bufLength <= $len) {
      $ret = $this->buf_;
      $this->buf_ = '';
      return $ret;
    }

    $ret = TStringFuncFactory::create()->substr($this->buf_, 0, $len);
    $this->buf_ = TStringFuncFactory::create()->substr($this->buf_, $len);

    return $ret;
  }

  function getBuffer() {
    return $this->buf_;
  }

  public function available() {
    return TStringFuncFactory::create()->strlen($this->buf_);
  }
}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.transport
 */

namespace Thrift\Transport;

use Thrift\Transport\TTransport;
use Thrift\Exception\TTransportException;

/**
 * Transport that only accepts writes and ignores them.
 * This is useful for measuring the serialized size of structures.
 *
 * @package thrift.transport
 */
class TNullTransport extends TTransport {

  public function isOpen() {
    return true;
  }

  public function open() {}

  public function close() {}

  public function read($len) {
    throw new TTransportException("Can't read from TNullTransport.");
  }

  public function write($buf) {}

}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.transport
 */

namespace Thrift\Transport;

use Thrift\Transport\TTransport;
use Thrift\Exception\TException;
use Thrift\Factory\TStringFuncFactory;

/**
 * Php stream transport. Reads to and writes from the php standard streams
 * php://input and php://output
 *
 * @package thrift.transport
 */
class TPhpStream extends TTransport {

  const MODE_R = 1;
  const MODE_W = 2;

  private $inStream_ = null;

  private $outStream_ = null;

  private $read_ = false;

  private $write_ = false;

  public function __construct($mode) {
    $this->read_ = $mode & self::MODE_R;
    $this->write_ = $mode & self::MODE_W;
  }

  public function open() {
    if ($this->read_) {
      $this->inStream_ = @fopen(self::inStreamName(), 'r');
      if (!is_resource($this->inStream_)) {
        throw new TException('TPhpStream: Could not open php://input');
      }
    }
    if ($this->write_) {
      $this->outStream_ = @fopen('php://output', 'w');
      if (!is_resource($this->outStream_)) {
        throw new TException('TPhpStream: Could not open php://output');
      }
    }
  }

  public function close() {
    if ($this->read_) {
      @fclose($this->inStream_);
      $this->inStream_ = null;
    }
    if ($this->write_) {
      @fclose($this->outStream_);
      $this->outStream_ = null;
    }
  }

  public function isOpen() {
    return
      (!$this->read_ || is_resource($this->inStream_)) &&
      (!$this->write_ || is_resource($this->outStream_));
  }

  public function read($len) {
    $data = @fread($this->inStream_, $len);
    if ($data === FALSE || $data === '') {
      throw new TException('TPhpStream: Could not read '.$len.' bytes');
    }
    return $data;
  }

  public function write($buf) {
    while (TStringFuncFactory::create()->strlen($buf) > 0) {
      $got = @fwrite($this->outStream_, $buf);
      if ($got === 0 || $got === FALSE) {
        throw new TException('TPhpStream: Could not write '.TStringFuncFactory::create()->strlen($buf).' bytes');
      }
      $buf = TStringFuncFactory::create()->substr($buf, $got);
    }
  }

  public function flush() {
    @fflush($this->outStream_);
  }

  private static function inStreamName() {
    if (php_sapi_name() == 'cli') {
      return 'php://stdin';
    }
    return 'php://input';
  }

}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.transport
 */

namespace Thrift\Transport;

use Thrift\Transport\TTransport;
use Thrift\Exception\TException;
use Thrift\Exception\TTransportException;
use Thrift\Factory\TStringFuncFactory;

/**
 * Sockets implementation of the TTransport interface.
 *
 * @package thrift.transport
 */
class TSocket extends TTransport {

  /**
   * Handle to PHP socket
   *
   * @var resource
   */
  private $handle_ = null;

  /**
   * Remote hostname
   *
   * @var string
   */
  protected $host_ = 'localhost';

  /**
   * Remote port
   *
   * @var int
   */
  protected $port_ = '9090';

  /**
   * Send timeout in seconds.
   *
   * Combined with sendTimeoutUsec this is used for send timeouts.
   *
   * @var int
   */
  private $sendTimeoutSec_ = 0;

  /**
   * Send timeout in microseconds.
   *
   * Combined with sendTimeoutSec this is used for send timeouts.
   *
   * @var int
   */
  private $sendTimeoutUsec_ = 100000;

  /**
   * Recv timeout in seconds
   *
   * Combined with recvTimeoutUsec this is used for recv timeouts.
   *
   * @var int
   */
  private $recvTimeoutSec_ = 0;

  /**
   * Recv timeout in microseconds
   *
   * Combined with recvTimeoutSec this is used for recv timeouts.
   *
   * @var int
   */
  private $recvTimeoutUsec_ = 750000;

  /**
   * Persistent socket or plain?
   *
   * @var bool
   */
  protected $persist_ = FALSE;

  /**
   * Debugging on?
   *
   * @var bool
   */
  protected $debug_ = FALSE;

  /**
   * Debug handler
   *
   * @var mixed
   */
  protected $debugHandler_ = null;

  /**
   * Socket constructor
   *
   * @param string $host         Remote hostname
   * @param int    $port         Remote port
   * @param bool   $persist      Whether to use a persistent socket
   * @param string $debugHandler Function to call for error logging
   */
  public function __construct($host='localhost',
                              $port=9090,
                              $persist=FALSE,
                              $debugHandler=null) {
    $this->host_ = $host;
    $this->port_ = $port;
    $this->persist_ = $persist;
    $this->debugHandler_ = $debugHandler ? $debugHandler : 'error_log';
  }

  /**
   * @param resource $handle
   * @return void
   */
  public function setHandle($handle) {
    $this->handle_ = $handle;
  }

  /**
   * Sets the send timeout.
   *
   * @param int $timeout  Timeout in milliseconds.
   */
  public function setSendTimeout($timeout) {
    $this->sendTimeoutSec_ = floor($timeout / 1000);
    $this->sendTimeoutUsec_ =
            ($timeout - ($this->sendTimeoutSec_ * 1000)) * 1000;
  }

  /**
   * Sets the receive timeout.
   *
   * @param int $timeout  Timeout in milliseconds.
   */
  public function setRecvTimeout($timeout) {
    $this->recvTimeoutSec_ = floor($timeout / 1000);
    $this->recvTimeoutUsec_ =
            ($timeout - ($this->recvTimeoutSec_ * 1000)) * 1000;
  }

  /**
   * Sets debugging output on or off
   *
   * @param bool $debug
   */
  public function setDebug($debug) {
    $this->debug_ = $debug;
  }

  /**
   * Get the host that this socket is connected to
   *
   * @return string host
   */
  public function getHost() {
    return $this->host_;
  }

  /**
   * Get the remote port that this socket is connected to
   *
   * @return int port
   */
  public function getPort() {
    return $this->port_;
  }

  /**
   * Tests whether this is open
   *
   * @return bool true if the socket is open
   */
  public function isOpen() {
    return is_resource($this->handle_);
  }

  /**
   * Connects the socket.
   */
  public function open() {
    if ($this->isOpen()) {
      throw new TTransportException('Socket already connected', TTransportException::ALREADY_OPEN);
    }

    if (empty($this->host_)) {
      throw new TTransportException('Cannot open null host', TTransportException::NOT_OPEN);
    }

    if ($this->port_ <= 0) {
      throw new TTransportException('Cannot open without port', TTransportException::NOT_OPEN);
    }

    if ($this->persist_) {
      $this->handle_ = @pfsockopen($this->host_,
                                   $this->port_,
                                   $errno,
                                   $errstr,
                                   $this->sendTimeoutSec_ + ($this->sendTimeoutUsec_ / 1000000));
    } else {
      $this->handle_ = @fsockopen($this->host_,
                                  $this->port_,
                                  $errno,
                                  $errstr,
                                  $this->sendTimeoutSec_ + ($this->sendTimeoutUsec_ / 1000000));
    }

    // Connect failed?
    if ($this->handle_ === FALSE) {
      $error = 'TSocket: Could not connect to '.$this->host_.':'.$this->port_.' ('.$errstr.' ['.$errno.'])';
      if ($this->debug_) {
        call_user_func($this->debugHandler_, $error);
      }
      throw new TException($error);
    }
  }

  /**
   * Closes the socket.
   */
  public function close() {
    if (!$this->persist_) {
      @fclose($this->handle_);
      $this->handle_ = null;
    }
  }

  /**
   * Read from the socket at most $len bytes.
   *
   * This method will not wait for all the requested data, it will return as
   * soon as any data is received.
   *
   * @param int $len Maximum number of bytes to read.
   * @return string Binary data
   */
  public function read($len) {
    $null = null;
    $read = array($this->handle_);
    $readable = @stream_select($read, $null, $null, $this->recvTimeoutSec_, $this->recvTimeoutUsec_);

    if ($readable > 0) {
      $data = @stream_socket_recvfrom($this->handle_, $len);
      if ($data === false) {
          throw new TTransportException('TSocket: Could not read '.$len.' bytes from '.
                               $this->host_.':'.$this->port_);
      } elseif($data == '' && feof($this->handle_)) {
          throw new TTransportException('TSocket read 0 bytes');
        }

      return $data;
    } else if ($readable === 0) {
        throw new TTransportException('TSocket: timed out reading '.$len.' bytes from '.
                             $this->host_.':'.$this->port_);
      } else {
        throw new TTransportException('TSocket: Could not read '.$len.' bytes from '.
                             $this->host_.':'.$this->port_);
      }
    }

  /**
   * Write to the socket.
   *
   * @param string $buf The data to write
   */
  public function write($buf) {
    $null = null;
    $write = array($this->handle_);

    // keep writing until all the data has been written
    while (TStringFuncFactory::create()->strlen($buf) > 0) {
      // wait for stream to become available for writing
      $writable = @stream_select($null, $write, $null, $this->sendTimeoutSec_, $this->sendTimeoutUsec_);
      if ($writable > 0) {
        // write buffer to stream
        $written = @stream_socket_sendto($this->handle_, $buf);
        if ($written === -1 || $written === false) {
          throw new TTransportException('TSocket: Could not write '.TStringFuncFactory::create()->strlen($buf).' bytes '.
                                   $this->host_.':'.$this->port_);
        }
        // determine how much of the buffer is left to write
        $buf = TStringFuncFactory::create()->substr($buf, $written);
      } else if ($writable === 0) {
          throw new TTransportException('TSocket: timed out writing '.TStringFuncFactory::create()->strlen($buf).' bytes from '.
                               $this->host_.':'.$this->port_);
        } else {
            throw new TTransportException('TSocket: Could not write '.TStringFuncFactory::create()->strlen($buf).' bytes '.
                                 $this->host_.':'.$this->port_);
        }
      }
    }

  /**
   * Flush output to the socket.
   *
   * Since read(), readAll() and write() operate on the sockets directly,
   * this is a no-op
   *
   * If you wish to have flushable buffering behaviour, wrap this TSocket
   * in a TBufferedTransport.
   */
  public function flush() {
    // no-op
    }
  }
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.transport
 */

namespace Thrift\Transport;

use Thrift\Transport\TSocket;
use Thrift\Exception\TException;

/**
 * This library makes use of APC cache to make hosts as down in a web
 * environment. If you are running from the CLI or on a system without APC
 * installed, then these null functions will step in and act like cache
 * misses.
 */
if (!function_exists('apc_fetch')) {
  function apc_fetch($key) { return FALSE; }
  function apc_store($key, $var, $ttl=0) { return FALSE; }
}

/**
 * Sockets implementation of the TTransport interface that allows connection
 * to a pool of servers.
 *
 * @package thrift.transport
 */
class TSocketPool extends TSocket {

  /**
   * Remote servers. Array of associative arrays with 'host' and 'port' keys
   */
  private $servers_ = array();

  /**
   * How many times to retry each host in connect
   *
   * @var int
   */
  private $numRetries_ = 1;

  /**
   * Retry interval in seconds, how long to not try a host if it has been
   * marked as down.
   *
   * @var int
   */
  private $retryInterval_ = 60;

  /**
   * Max consecutive failures before marking a host down.
   *
   * @var int
   */
  private $maxConsecutiveFailures_ = 1;

  /**
   * Try hosts in order? or Randomized?
   *
   * @var bool
   */
  private $randomize_ = TRUE;

  /**
   * Always try last host, even if marked down?
   *
   * @var bool
   */
  private $alwaysTryLast_ = TRUE;

  /**
   * Socket pool constructor
   *
   * @param array  $hosts        List of remote hostnames
   * @param mixed  $ports        Array of remote ports, or a single common port
   * @param bool   $persist      Whether to use a persistent socket
   * @param mixed  $debugHandler Function for error logging
   */
  public function __construct($hosts=array('localhost'),
                              $ports=array(9090),
                              $persist=FALSE,
                              $debugHandler=null) {
    parent::__construct(null, 0, $persist, $debugHandler);

    if (!is_array($ports)) {
      $port = $ports;
      $ports = array();
      foreach ($hosts as $key => $val) {
        $ports[$key] = $port;
      }
    }

    foreach ($hosts as $key => $host) {
      $this->servers_ []= array('host' => $host,
                                'port' => $ports[$key]);
    }
  }

  /**
   * Add a server to the pool
   *
   * This function does not prevent you from adding a duplicate server entry.
   *
   * @param string $host hostname or IP
   * @param int $port port
   */
  public function addServer($host, $port) {
    $this->servers_[] = array('host' => $host, 'port' => $port);
  }

  /**
   * Sets how many time to keep retrying a host in the connect function.
   *
   * @param int $numRetries
   */
  public function setNumRetries($numRetries) {
    $this->numRetries_ = $numRetries;
  }

  /**
   * Sets how long to wait until retrying a host if it was marked down
   *
   * @param int $numRetries
   */
  public function setRetryInterval($retryInterval) {
    $this->retryInterval_ = $retryInterval;
  }

  /**
   * Sets how many time to keep retrying a host before marking it as down.
   *
   * @param int $numRetries
   */
  public function setMaxConsecutiveFailures($maxConsecutiveFailures) {
    $this->maxConsecutiveFailures_ = $maxConsecutiveFailures;
  }

  /**
   * Turns randomization in connect order on or off.
   *
   * @param bool $randomize
   */
  public function setRandomize($randomize) {
    $this->randomize_ = $randomize;
  }

  /**
   * Whether to always try the last server.
   *
   * @param bool $alwaysTryLast
   */
  public function setAlwaysTryLast($alwaysTryLast) {
    $this->alwaysTryLast_ = $alwaysTryLast;
  }


  /**
   * Connects the socket by iterating through all the servers in the pool
   * and trying to find one that works.
   */
  public function open() {
    // Check if we want order randomization
    if ($this->randomize_) {
      shuffle($this->servers_);
    }

    // Count servers to identify the "last" one
    $numServers = count($this->servers_);

    for ($i = 0; $i < $numServers; ++$i) {

      // This extracts the $host and $port variables
      extract($this->servers_[$i]);

      // Check APC cache for a record of this server being down
      $failtimeKey = 'thrift_failtime:'.$host.':'.$port.'~';

      // Cache miss? Assume it's OK
      $lastFailtime = apc_fetch($failtimeKey);
      if ($lastFailtime === FALSE) {
        $lastFailtime = 0;
      }

      $retryIntervalPassed = FALSE;

      // Cache hit...make sure enough the retry interval has elapsed
      if ($lastFailtime > 0) {
        $elapsed = time() - $lastFailtime;
        if ($elapsed > $this->retryInterval_) {
          $retryIntervalPassed = TRUE;
          if ($this->debug_) {
            call_user_func($this->debugHandler_,
                           'TSocketPool: retryInterval '.
                           '('.$this->retryInterval_.') '.
                           'has passed for host '.$host.':'.$port);
          }
        }
      }

      // Only connect if not in the middle of a fail interval, OR if this
      // is the LAST server we are trying, just hammer away on it
      $isLastServer = FALSE;
      if ($this->alwaysTryLast_) {
        $isLastServer = ($i == ($numServers - 1));
      }

      if (($lastFailtime === 0) ||
          ($isLastServer) ||
          ($lastFailtime > 0 && $retryIntervalPassed)) {

        // Set underlying TSocket params to this one
        $this->host_ = $host;
        $this->port_ = $port;

        // Try up to numRetries_ connections per server
        for ($attempt = 0; $attempt < $this->numRetries_; $attempt++) {
          try {
            // Use the underlying TSocket open function
            parent::open();

            // Only clear the failure counts if required to do so
            if ($lastFailtime > 0) {
              apc_store($failtimeKey, 0);
            }

            // Successful connection, return now
            return;

          } catch (TException $tx) {
            // Connection failed
          }
        }

        // Mark failure of this host in the cache
        $consecfailsKey = 'thrift_consecfails:'.$host.':'.$port.'~';

        // Ignore cache misses
        $consecfails = apc_fetch($consecfailsKey);
        if ($consecfails === FALSE) {
          $consecfails = 0;
        }

        // Increment by one
        $consecfails++;

        // Log and cache this failure
        if ($consecfails >= $this->maxConsecutiveFailures_) {
          if ($this->debug_) {
            call_user_func($this->debugHandler_,
                           'TSocketPool: marking '.$host.':'.$port.
                           ' as down for '.$this->retryInterval_.' secs '.
                           'after '.$consecfails.' failed attempts.');
          }
          // Store the failure time
          apc_store($failtimeKey, time());

          // Clear the count of consecutive failures
          apc_store($consecfailsKey, 0);
        } else {
          apc_store($consecfailsKey, $consecfails);
        }
      }
    }

    // Oh no; we failed them all. The system is totally ill!
    $error = 'TSocketPool: All hosts in pool are down. ';
    $hosts = array();
    foreach ($this->servers_ as $server) {
      $hosts []= $server['host'].':'.$server['port'];
    }
    $hostlist = implode(',', $hosts);
    $error .= '('.$hostlist.')';
    if ($this->debug_) {
      call_user_func($this->debugHandler_, $error);
    }
    throw new TException($error);
  }
}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift.transport
 */

namespace Thrift\Transport;

use Thrift\Factory\TStringFuncFactory;

/**
 * Base interface for a transport agent.
 *
 * @package thrift.transport
 */
abstract class TTransport {

  /**
   * Whether this transport is open.
   *
   * @return boolean true if open
   */
  public abstract function isOpen();

  /**
   * Open the transport for reading/writing
   *
   * @throws TTransportException if cannot open
   */
  public abstract function open();

  /**
   * Close the transport.
   */
  public abstract function close();

  /**
   * Read some data into the array.
   *
   * @param int    $len How much to read
   * @return string The data that has been read
   * @throws TTransportException if cannot read any more data
   */
  public abstract function read($len);

  /**
   * Guarantees that the full amount of data is read.
   *
   * @return string The data, of exact length
   * @throws TTransportException if cannot read data
   */
  public function readAll($len) {
    // return $this->read($len);

    $data = '';
    $got = 0;
    while (($got = TStringFuncFactory::create()->strlen($data)) < $len) {
      $data .= $this->read($len - $got);
    }
    return $data;
  }

  /**
   * Writes the given data out.
   *
   * @param string $buf  The data to write
   * @throws TTransportException if writing fails
   */
  public abstract function write($buf);

  /**
   * Flushes any pending data out of a buffer
   *
   * @throws TTransportException if a writing error occurs
   */
  public function flush() {}
}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift
 */

namespace Thrift\Type;

/**
 * Base class for constant Management
 */
abstract class TConstant
{
    /**
     * Don't instanciate this class
     */
    protected function __construct() {}

    /**
     * Get a constant value
     * @param string $constant
     * @return mixed
     */
    public static function get($constant)
    {
        if(is_null(static::$$constant))
        {
            static::$$constant = call_user_func(
                    sprintf('static::init_%s', $constant)
                );
        }

        return static::$$constant;
    }
}
<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift
 */

namespace Thrift\Type;

/**
 * Message types for RPC
 */
class TMessageType {
  const CALL  = 1;
  const REPLY = 2;
  const EXCEPTION = 3;
  const ONEWAY = 4;
}<?php
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 * @package thrift
 */

namespace Thrift\Type;

/**
 * Data types that can be sent via Thrift
 */
class TType {
  const STOP   = 0;
  const VOID   = 1;
  const BOOL   = 2;
  const BYTE   = 3;
  const I08    = 3;
  const DOUBLE = 4;
  const I16    = 6;
  const I32    = 8;
  const I64    = 10;
  const STRING = 11;
  const UTF7   = 11;
  const STRUCT = 12;
  const MAP    = 13;
  const SET    = 14;
  const LST    = 15;    // N.B. cannot use LIST keyword in PHP!
  const UTF8   = 16;
  const UTF16  = 17;
}
<?php
/*
 * @package thrift.transport
 */

namespace Thrift\Transport;

use Thrift\Transport\TTransport;
use Thrift\Exception\TTransportException;
use Thrift\Factory\TStringFuncFactory;

/**
 * TTransport that wraps another TTransport and provides SASL.
 *
 * @package thrift.transport
 */
class TSaslClientTransport extends TTransport {

  const START    = 0x01;
  const OK       = 0x02;
  const BAD      = 0x03;
  const ERROR    = 0x04;
  const COMPLETE = 0x05;
  const METHOD   = 'PLAIN';

  /**
   * The TTransport to wrap
   *
   * @var TTransport
   */
  private $transport_;

  /**
   * SASL auth username
   *
   * @var string
   */
  protected $username_ = '';

  /**
   * SASL auth password
   *
   * @var string
   */
  protected $password_ = '';

  /**
   * The SASL handshake is complete
   *
   * @var boolean
   */
  private $saslComplete_ = false;

  /**
   * Buffer for reads
   *
   * @var bytes
   */
  private $readBuffer_ = '';

  /**
   * Buffer for writes
   *
   * @var bytes
   */
  private $writeBuffer_ = '';

  /**
   * Constructor
   *
   * @param TTransport $transport Transport object to be wrapped
   * @param string     $username  SASL username
   * @param string     $password  SASL password
   */
  public function __construct( TTransport $transport, $username, $password ) {
    $this->transport_ = $transport;
    $this->username_ = $username;
    $this->password_ = $password;
  }

  /**
   * Whether this transport is open.
   *
   * @return boolean true if open
   */
  public function isOpen() {
    return $this->saslComplete_;
  }

  /**
   * Open the transport for reading/writing
   *
   * @throws TTransportException if cannot open
   */
  public function open() {
    if ( !$this->transport_->isOpen() ) {
      $this->transport_->open();
    }

    try{
      $auth =  '' . chr(0) . $this->username_ . chr(0) . $this->password_;
      $this->saslWrite_( self::METHOD, self::START );
      $this->saslWrite_( $auth, self::COMPLETE );

      $saslFrame = $this->saslRead_( true );
      $this->saslComplete_ = ( self::COMPLETE == $saslFrame['status'] );

      if ( !$this->saslComplete_ ) {
        throw new TTransportException( 'Could not perform SASL auth.' );
      }
    } catch ( TTransportException $e ) {
      throw $e;
    } catch ( Exception $e ) {
      throw new TTransportException( 'SASL Auth failed: ',  $e->getMessage() );
    }

    return true;
  }

  /**
   * Close the transport.
   */
  public function close() {
    return $this->transport_->close();
  }

  /**
   * Read some data into the array.
   *
   * @param int $len How much to read
   * @return string The data that has been read
   * @throws TTransportException if cannot read any more data
   */
  public function read($len) {
    if ( 0 === TStringFuncFactory::create()->strlen( $this->readBuffer_ ) ) {
      // No more buffered data go fetch a SASL frame
      $saslFrame = $this->saslRead_();
      $this->readBuffer_ = $saslFrame['payload'];
    }

    return $this->getFromBuffer_( $len );
  }

  /**
   * Writes the given data out.
   *
   * @param string $buf  The data to write
   * @throws TTransportException if writing fails
   */
  public function write($buf) {
    $this->writeBuffer_ .= $buf;
  }

  /**
  * Flushes any pending data out of a buffer
  *
  * @throws TTransportException if a writing error occurs
  */
  public function flush() {
    $this->saslWrite_( $this->writeBuffer_ );
    $this->writeBuffer_ = '';
  }

  public function __call($name, $arguments) {
    return call_user_func_array( array( $this->transport_, $name ), $arguments );
  }

  private function saslWrite_( $payload, $status = null ) {
    $header = '';
    if ( null !== $status ) {
      $header .= pack( 'C', $status );
    }
    $header .= pack( 'N', TStringFuncFactory::create()->strlen( $payload ) );
    $this->transport_->write( $header . $payload );
    $this->transport_->flush();
  }

  private function saslRead_($statusByte = false) {
    // Read SASL Header
    if ( $statusByte ) {
      $frame = unpack( 'Cstatus/Nlength', $this->transport_->readAll( 5 ) );
    } else {
      $frame = unpack( 'Nlength', $this->transport_->readAll( 4 ) );
    }

    // Read SASL Payload
    $frame['payload'] = $this->transport_->readAll( $frame['length'] );

    return $frame;
  }

  private function getFromBuffer_($len) {
    if ( TStringFuncFactory::create()->strlen( $this->readBuffer_ ) <= $len ) {
      $return = $this->readBuffer_;
      $this->readBuffer_ = '';
    } else {
      $return = TStringFuncFactory::create()->substr( $this->readBuffer_, 0, $len );
      $this->readBuffer_ = TStringFuncFactory::create()->substr( $this->readBuffer_, $len );
    }

    return $return;
  }
}
<?php
namespace ThriftSQL;

class Exception extends \Exception { }
<?php

namespace ThriftSQL;

class Hive implements \ThriftSQL {
  private $_host;
  private $_port;
  private $_username;
  private $_password;
  private $_timeout;
  private $_transport;
  private $_client;
  private $_sessionHandle;
  protected $_sasl = true;
  
  public function __construct( $host, $port = 10000, $username = null, $password = null, $timeout = null ) {
    $this->_host = $host;
    $this->_port = $port;
    $this->_username = $username;
    $this->_password = $password;
    $this->_timeout = $timeout;
  }

  public function setSasl( $bool ) {
    $this->_sasl = (bool) $bool;
    return $this;
  }

  public function connect() {
    // Check if we have already connected and have a session
    if ( null !== $this->_sessionHandle ) {
      return $this;
    }
    try {
      $this->_transport = new \Thrift\Transport\TSocket( $this->_host, $this->_port );
      if ( null !== $this->_timeout ) {
        $this->_transport->setSendTimeout( $this->_timeout * 1000 );
        $this->_transport->setRecvTimeout( $this->_timeout * 1000 );
      }
      if ( $this->_sasl ) {
        $this->_transport = new \Thrift\Transport\TSaslClientTransport(
          $this->_transport,
          $this->_username,
          $this->_password
        );
      }
      $this->_transport->open();
      $this->_client = new \ThriftSQL\TCLIServiceClient(
        new \Thrift\Protocol\TBinaryProtocol(
          $this->_transport
        )
      );
      $TOpenSessionReq = new \ThriftSQL\TOpenSessionReq();
      if ( null !== $this->_username && null !== $this->_password ) {
        $TOpenSessionReq->username = $this->_username;
        $TOpenSessionReq->password = $this->_password;
      }
      // Ok, let's try to start a session
      $this->_sessionHandle = $this
        ->_client
        ->OpenSession( $TOpenSessionReq )
        ->sessionHandle;
    } catch( Exception $e ) {
      $this->_sessionHandle = null;
      throw new \ThriftSQL\Exception( $e->getMessage() );
    }
    return $this;
  }

  public function query( $queryStr ) {
    try {
      $queryCleaner = new \ThriftSQL\Utils\QueryCleaner();
      $response = $this->_client->ExecuteStatement( new \ThriftSQL\TExecuteStatementReq( array(
        'sessionHandle' => $this->_sessionHandle,
        'statement' => $queryCleaner->clean( $queryStr ),
        'runAsync' => true,
      ) ) );
      return new \ThriftSQL\HiveQuery( $response, $this->_client );
    } catch ( Exception $e ) {
      throw new \ThriftSQL\Exception( $e->getMessage() );
    }
  }

  public function queryAndFetchAll( $queryStr ) {
    try {
      $query = $this->query( $queryStr );
      $query->wait();
      // Collect results
      $resultTuples = array();
      do {
        $responseTuples = $query->fetch(100);
        // No more data we're done
        if ( empty( $responseTuples ) ) {
          return $resultTuples;
        }
        $resultTuples = array_merge( $resultTuples, $responseTuples );
      } while (true);
    } catch( Exception $e ) {
      throw new \ThriftSQL\Exception( $e->getMessage() );
    }
  }

  public function disconnect() {
    // Close session if we have one
    if ( null !== $this->_sessionHandle ) {
      $this->_client->CloseSession( new \ThriftSQL\TCloseSessionReq( array(
        'sessionHandle' => $this->_sessionHandle,
      ) ) );
    }
    $this->_sessionHandle = null;
    // Clear out the client
    $this->_client = null;
    // Close the socket
    if ( null !== $this->_transport ) {
      $this->_transport->close();
    }
    $this->_transport = null;
  }
}
<?php
namespace ThriftSQL;

class Impala implements \ThriftSQL {

  private $_host;
  private $_port;
  private $_username;
  private $_password;
  private $_timeout;
  private $_transport;
  private $_client;

  public function __construct( $host, $port = 21000, $username = null, $password = null, $timeout = null ) {
    $this->_host = $host;
    $this->_port = $port;
    $this->_username = $username; // not used
    $this->_password = $password; // not used
    $this->_timeout = $timeout;
  }

  public function connect() {

    // Check if we have already connected
    if ( null !== $this->_client ) {
      return $this;
    }

    try {
      $this->_transport = new \Thrift\Transport\TSocket( $this->_host, $this->_port );

      if ( null !== $this->_timeout ) {
        $this->_transport->setSendTimeout( $this->_timeout * 1000 );
        $this->_transport->setRecvTimeout( $this->_timeout * 1000 );
      }

      $this->_transport->open();

      $this->_client = new \ThriftSQL\ImpalaServiceClient(
        new \Thrift\Protocol\TBinaryProtocol(
          $this->_transport
        )
      );
    } catch( Exception $e ) {
      $this->_client = null;
      throw new \ThriftSQL\Exception( $e->getMessage() );
    }

    return $this;

  }

  public function query( $queryStr ) {
    try {
      return new ImpalaQuery( $queryStr, $this->_client );
    } catch ( Exception $e ) {
      throw new \ThriftSQL\Exception( $e->getMessage() );
    }
  }

  public function queryAndFetchAll( $queryStr ) {
    try {
      $query = $this->query( $queryStr );
      $query->wait();
      $result = array();
      do {
        $rows = $query->fetch( 100 );
        if ( empty( $rows ) ) {
          break;
        }
        $result = array_merge( $result, $rows );
      } while ( true );
      return $result;
    } catch( Exception $e ) {
      throw new \ThriftSQL\Exception( $e->getMessage() );
    }
  }

  public function disconnect() {

    // Clear out the client
    $this->_client = null;

    // Close the socket
    if ( null !== $this->_transport ) {
      $this->_transport->close();
    }
    $this->_transport = null;

  }
}
<?php
namespace ThriftSQL\Utils;

/**
 * Util to clean up queries; e.g. remove trailing `;`.
 */

class QueryCleaner {

  public function clean( $queryStr ) {
    // Very simplistic
    return trim( $queryStr, "; \t\n\r\0\x0B" );
  }

}
<?php
namespace ThriftSQL\Utils;

/**
 * Util to do exponential sleeping.
 */

class Sleeper {

  private $_iterations = 0;
  private $_slept = 0;

  public function reset() {
    $this->_iterations = 0;
    $this->_slept = 0;

    return $this;
  }

  public function sleep() {
    $mSecs = $this->_getSleepMS();

    usleep( $mSecs * 1000 );

    $this->_iterations++;
    $this->_slept += $mSecs;

    return $this;
  }

  public function getSleptSecs() {
    return $this->_slept / 1000;
  }

  private function _getSleepMS() {
    if ( 14 < $this->_iterations ) {
      return 30000; // Max out at 30 second sleep per check
    }

    return pow( 2, $this->_iterations );
  }

}
<?php

interface ThriftSQL {
  /**
  * @return self
  * @throws \ThriftSQL\Exception
  */
  public function connect();

  /**
  * The simplest use case; takes a query string executes it synchronously and
  * returns the entire result set after collecting it from the server.
  *
  * @param string $queryStr
  * @return array
  * @throws \ThriftSQL\Exception
  */
  public function queryAndFetchAll( $queryStr );

  /**
  * Sends a query string for execution on the server and returns a
  * ThriftSQLQuery object for fetching the results manually.
  *
  * @param string $queryStr
  * @return \ThriftSQLQuery
  * @throws \ThriftSQL\Exception
  */
  public function query( $queryStr );

  /**
  * @return null
  */
  public function disconnect();
}
<?php

namespace ThriftSQL;

class HiveQuery implements \ThriftSQLQuery {

  private $_resp;
  private $_client;
  private $_ready;

  public function __construct( $response, $client ) {
    $this->_resp = $response;
    $this->_ready = false;
    $this->_client = $client;
  }

  public function wait() {
    // Wait for results
    $sleeper = new \ThriftSQL\Utils\Sleeper();
    $sleeper->reset();
    do {
      $slept = $sleeper->sleep()->getSleptSecs();
      if ( $slept > 18000 ) { // 5 Hours
        // TODO: Actually kill the query then throw exception.
        throw new \ThriftSQL\Exception( 'Hive Query Killed!' );
      }
      $TGetOperationStatusResp = $this
        ->_client
        ->GetOperationStatus( new \ThriftSQL\TGetOperationStatusReq( array(
          'operationHandle' => $this->_resp->operationHandle,
        ) ) );
      if ( $this->_isOperationFinished( $TGetOperationStatusResp->operationState ) ) {
        break;
      }
      if ( $this->_isOperationRunning( $TGetOperationStatusResp->operationState ) ) {
        continue;
      }
      // Query in error state
      throw new \ThriftSQL\Exception(
        'Hive ' . \ThriftSQL\TOperationState::$__names[ $TGetOperationStatusResp->operationState ] . "\n" .
        "Error Message: {$TGetOperationStatusResp->errorMessage}"
      );
    } while ( true );

    // Check for errors
    if ( \ThriftSQL\TStatusCode::ERROR_STATUS === $this->_resp->status->statusCode ) {
      throw new \ThriftSQL\Exception( "HIVE QUERY ERROR: {$this->_resp->status->status->errorMessage}" );
    }

    $this->_ready = true;
  }

  public function fetch( $maxRows ) {
    if ( !$this->_ready ) {
      throw new \ThriftSQL\Exception( "Query is not ready. Call `->wait()` before `->fetch()`" );
    }
    try {
      $TFetchResultsResp = $this->_client->FetchResults( new \ThriftSQL\TFetchResultsReq( array(
        'operationHandle' => $this->_resp->operationHandle,
        'maxRows' => $maxRows,
      ) ) );
      /**
       * NOTE: $TFetchResultsResp->hasMoreRows appears broken, it's always
       * false so one needs to keep fetching until they run out of data.
       */
      if ( $TFetchResultsResp->results instanceof \ThriftSQL\TRowSet && !empty( $TFetchResultsResp->results->columns ) ) {
        return $this->_colsToRows( $TFetchResultsResp->results->columns );
      }
      return array();
    } catch ( Exception $e ) {
      throw new \ThriftSQL\Exception( $e->getMessage() );
    }
  }

  private function _colsToRows( $columns ) {
    $result = array();
    foreach ( $columns as $col => $TColumn ) {
      $values = array();
      if ( !is_null( $TColumn->boolVal ) ) {
        $values = $TColumn->boolVal->values;
      }
      if ( !is_null( $TColumn->byteVal ) ) {
        $values = $TColumn->byteVal->values;
      }
      if ( !is_null( $TColumn->i16Val ) ) {
        $values = $TColumn->i16Val->values;
      }
      if ( !is_null( $TColumn->i32Val ) ) {
        $values = $TColumn->i32Val->values;
      }
      if ( !is_null( $TColumn->i64Val ) ) {
        $values = $TColumn->i64Val->values;
      }
      if ( !is_null( $TColumn->doubleVal ) ) {
        $values = $TColumn->doubleVal->values;
      }
      if ( !is_null( $TColumn->stringVal ) ) {
        $values = $TColumn->stringVal->values;
      }
      if ( !is_null( $TColumn->binaryVal ) ) {
        $values = $TColumn->binaryVal->values;
      }
      foreach ( $values as $row => $value ) {
        $result[ $row ][ $col ] = $value;
      }
    }
    return $result;
  }

  private function _isOperationFinished( $state ) {
    return ( \ThriftSQL\TOperationState::FINISHED_STATE == $state );
  }

  private function _isOperationRunning( $state ) {
    return in_array(
      $state,
      array(
        \ThriftSQL\TOperationState::INITIALIZED_STATE, // 0
        \ThriftSQL\TOperationState::RUNNING_STATE,     // 1
        \ThriftSQL\TOperationState::PENDING_STATE,     // 7
      )
    );
  }
}<?php

namespace ThriftSQL;

class ImpalaQuery implements \ThriftSQLQuery {

  private $_handle;
  private $_client;
  private $_ready;

  public function __construct( $queryStr, $client ) {
    $queryCleaner = new \ThriftSQL\Utils\QueryCleaner();

    $this->_client = $client;
    $this->_ready = false;
    $this->_handle = $this->_client->query( new \ThriftSQL\Query( array(
      'query' => $queryCleaner->clean( $queryStr ),
    ) ) );
  }

  public function wait() {
    $sleeper = new \ThriftSQL\Utils\Sleeper();
    
    // Wait for results
    $sleeper->reset();
    do {

      $slept = $sleeper->sleep()->getSleptSecs();

      if ( $slept > 18000 ) { // 5 Hours
        // TODO: Actually kill the query then throw exception.
        throw new \ThriftSQL\Exception( 'Impala Query Killed!' );
      }

      $state = $this
        ->_client
        ->get_state( $this->_handle );

      if ( $this->_isOperationFinished( $state ) ) {
        break;
      }

      if ( $this->_isOperationRunning( $state ) ) {
        continue;
      }

      // Query in error state
      throw new \ThriftSQL\Exception(
        'Query is in an error state: ' . \ThriftSQL\QueryState::$__names[ $state ]
      );

    } while (true);

    $this->_ready = true;
  }

  public function fetch( $maxRows ) {
    if ( !$this->_ready ) {
      throw new \ThriftSQL\Exception( "Query is not ready. Call `->wait()` before `->fetch()`" );
    }
    try {
      $sleeper = new \ThriftSQL\Utils\Sleeper();
      $sleeper->reset();

      do {
        $response = $this->_client->fetch( $this->_handle, false, $maxRows );
        if ( $response->ready ) {
          break;
        }
        $slept = $sleeper->sleep()->getSleptSecs();

        if ( $slept > 60 ) { // 1 minute
          throw new \ThriftSQL\Exception( 'Impala Query took too long to fetch!' );
        }

      } while ( true );

      return $this->_parseResponse( $response );
    } catch( Exception $e ) {
      throw new \ThriftSQL\Exception( $e->getMessage() );
    }
  }

  private function _parseResponse( $response ) {
    $result = array();
    foreach ( $response->data as $row => $rawValues ) {
      $values = explode( "\t", $rawValues, count( $response->columns ) );

      foreach ( $response->columns as $col => $dataType ) {
        switch ($dataType) {
          case 'int':
          case 'bigint':
          case 'smallint':
          case 'tinyint':
            $result[ $row ][ $col ] = intval( $values[ $col ] );
            break;

          case 'decimal':
          case 'double':
          case 'float':
          case 'real':
            $result[ $row ][ $col ] = floatval( $values[ $col ] );
            break;

          case 'boolean':
            $result[ $row ][ $col ] = ( 'true' === $values[ $col ] );
            break;

          case 'char':
          case 'string':
          case 'varchar':
          case 'timestamp':
          default:
            $result[ $row ][ $col ] = $values[ $col ];
            break;
        }
      }
    }
    return $result;
  }

  private function _isOperationFinished( $state ) {
    return ( \ThriftSQL\QueryState::FINISHED == $state );
  }

  private function _isOperationRunning( $state ) {
    return in_array(
      $state,
      array(
        \ThriftSQL\QueryState::CREATED,     // 0
        \ThriftSQL\QueryState::INITIALIZED, // 1
        \ThriftSQL\QueryState::COMPILED,    // 2
        \ThriftSQL\QueryState::RUNNING,     // 3
      )
    );
  }
}<?php

interface ThriftSQLQuery {
  /**
   * Waits for the query to complete execution
   * @return self
   * @throws \ThriftSQL\Exception
   */
  public function wait();

  /**
  * Fetches `n` rows from query results. 
  * Before calling this method, you must call `wait()`.
  *
  * @param int $numRows
  * @return array
  * @throws \ThriftSQL\Exception
  */
  public function fetch( $numRows );
}
Ë†â‚¬Å¡>FÃ«a^QoÃŒPoÃ¥Å½Ã–GBMB